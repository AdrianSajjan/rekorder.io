diff --git a/dist/es/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs b/dist/es/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
index f81cf3410b86473bf037d21d4296bd985daca808..adabc7e355f9fde2fb17326d11d4dfdd98ad3d79 100644
--- a/dist/es/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
+++ b/dist/es/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
@@ -1,4 +1,4 @@
-"use client";
+'use client';
 import { jsx } from 'react/jsx-runtime';
 import * as React from 'react';
 import { useId, useRef, useContext, useInsertionEffect } from 'react';
@@ -9,55 +9,54 @@ import { MotionConfigContext } from '../../context/MotionConfigContext.mjs';
  * to leverage snapshot lifecycle.
  */
 class PopChildMeasure extends React.Component {
-    getSnapshotBeforeUpdate(prevProps) {
-        const element = this.props.childRef.current;
-        if (element && prevProps.isPresent && !this.props.isPresent) {
-            const size = this.props.sizeRef.current;
-            size.height = element.offsetHeight || 0;
-            size.width = element.offsetWidth || 0;
-            size.top = element.offsetTop;
-            size.left = element.offsetLeft;
-        }
-        return null;
-    }
-    /**
-     * Required with getSnapshotBeforeUpdate to stop React complaining.
-     */
-    componentDidUpdate() { }
-    render() {
-        return this.props.children;
+  getSnapshotBeforeUpdate(prevProps) {
+    const element = this.props.childRef.current;
+    if (element && prevProps.isPresent && !this.props.isPresent) {
+      const size = this.props.sizeRef.current;
+      size.height = element.offsetHeight || 0;
+      size.width = element.offsetWidth || 0;
+      size.top = element.offsetTop;
+      size.left = element.offsetLeft;
     }
+    return null;
+  }
+  /**
+   * Required with getSnapshotBeforeUpdate to stop React complaining.
+   */
+  componentDidUpdate() {}
+  render() {
+    return this.props.children;
+  }
 }
-function PopChild({ children, isPresent }) {
-    const id = useId();
-    const ref = useRef(null);
-    const size = useRef({
-        width: 0,
-        height: 0,
-        top: 0,
-        left: 0,
-    });
-    const { nonce } = useContext(MotionConfigContext);
-    /**
-     * We create and inject a style block so we can apply this explicit
-     * sizing in a non-destructive manner by just deleting the style block.
-     *
-     * We can't apply size via render as the measurement happens
-     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the
-     * styles directly on the DOM node, we might be overwriting
-     * styles set via the style prop.
-     */
-    useInsertionEffect(() => {
-        const { width, height, top, left } = size.current;
-        if (isPresent || !ref.current || !width || !height)
-            return;
-        ref.current.dataset.motionPopId = id;
-        const style = document.createElement("style");
-        if (nonce)
-            style.nonce = nonce;
-        document.head.appendChild(style);
-        if (style.sheet) {
-            style.sheet.insertRule(`
+function PopChild({ children, isPresent, root }) {
+  const id = useId();
+  const ref = useRef(null);
+  const size = useRef({
+    width: 0,
+    height: 0,
+    top: 0,
+    left: 0,
+  });
+  const { nonce } = useContext(MotionConfigContext);
+  /**
+   * We create and inject a style block so we can apply this explicit
+   * sizing in a non-destructive manner by just deleting the style block.
+   *
+   * We can't apply size via render as the measurement happens
+   * in getSnapshotBeforeUpdate (post-render), likewise if we apply the
+   * styles directly on the DOM node, we might be overwriting
+   * styles set via the style prop.
+   */
+  useInsertionEffect(() => {
+    const { width, height, top, left } = size.current;
+    if (isPresent || !ref.current || !width || !height) return;
+    ref.current.dataset.motionPopId = id;
+    const style = document.createElement('style');
+    if (nonce) style.nonce = nonce;
+    const parent = root || document.head;
+    parent.appendChild(style);
+    if (style.sheet) {
+      style.sheet.insertRule(`
           [data-motion-pop-id="${id}"] {
             position: absolute !important;
             width: ${width}px !important;
@@ -66,12 +65,12 @@ function PopChild({ children, isPresent }) {
             left: ${left}px !important;
           }
         `);
-        }
-        return () => {
-            document.head.removeChild(style);
-        };
-    }, [isPresent]);
-    return (jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React.cloneElement(children, { ref }) }));
+    }
+    return () => {
+      parent.removeChild(style);
+    };
+  }, [isPresent]);
+  return jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React.cloneElement(children, { ref }) });
 }
 
 export { PopChild };
diff --git a/dist/es/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs b/dist/es/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
index 5ce38b0e9f55ebcb289705ad77b337ea5b5314e6..48b87f60b1991f9f549fff9dacc29ee4aec1b97b 100644
--- a/dist/es/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
+++ b/dist/es/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
@@ -1,4 +1,4 @@
-"use client";
+'use client';
 import { jsx } from 'react/jsx-runtime';
 import * as React from 'react';
 import { useId, useCallback, useMemo } from 'react';
@@ -6,56 +6,55 @@ import { PresenceContext } from '../../context/PresenceContext.mjs';
 import { useConstant } from '../../utils/use-constant.mjs';
 import { PopChild } from './PopChild.mjs';
 
-const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, }) => {
-    const presenceChildren = useConstant(newChildrenMap);
-    const id = useId();
-    const memoizedOnExitComplete = useCallback((childId) => {
-        presenceChildren.set(childId, true);
-        for (const isComplete of presenceChildren.values()) {
-            if (!isComplete)
-                return; // can stop searching when any is incomplete
-        }
-        onExitComplete && onExitComplete();
-    }, [presenceChildren, onExitComplete]);
-    const context = useMemo(() => ({
-        id,
-        initial,
-        isPresent,
-        custom,
-        onExitComplete: memoizedOnExitComplete,
-        register: (childId) => {
-            presenceChildren.set(childId, false);
-            return () => presenceChildren.delete(childId);
-        },
-    }), 
+const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, root }) => {
+  const presenceChildren = useConstant(newChildrenMap);
+  const id = useId();
+  const memoizedOnExitComplete = useCallback(
+    (childId) => {
+      presenceChildren.set(childId, true);
+      for (const isComplete of presenceChildren.values()) {
+        if (!isComplete) return; // can stop searching when any is incomplete
+      }
+      onExitComplete && onExitComplete();
+    },
+    [presenceChildren, onExitComplete]
+  );
+  const context = useMemo(
+    () => ({
+      id,
+      initial,
+      isPresent,
+      custom,
+      onExitComplete: memoizedOnExitComplete,
+      register: (childId) => {
+        presenceChildren.set(childId, false);
+        return () => presenceChildren.delete(childId);
+      },
+    }),
     /**
      * If the presence of a child affects the layout of the components around it,
      * we want to make a new context value to ensure they get re-rendered
      * so they can detect that layout change.
      */
-    presenceAffectsLayout
-        ? [Math.random(), memoizedOnExitComplete]
-        : [isPresent, memoizedOnExitComplete]);
-    useMemo(() => {
-        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
-    }, [isPresent]);
-    /**
-     * If there's no `motion` components to fire exit animations, we want to remove this
-     * component immediately.
-     */
-    React.useEffect(() => {
-        !isPresent &&
-            !presenceChildren.size &&
-            onExitComplete &&
-            onExitComplete();
-    }, [isPresent]);
-    if (mode === "popLayout") {
-        children = jsx(PopChild, { isPresent: isPresent, children: children });
-    }
-    return (jsx(PresenceContext.Provider, { value: context, children: children }));
+    presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]
+  );
+  useMemo(() => {
+    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
+  }, [isPresent]);
+  /**
+   * If there's no `motion` components to fire exit animations, we want to remove this
+   * component immediately.
+   */
+  React.useEffect(() => {
+    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
+  }, [isPresent]);
+  if (mode === 'popLayout') {
+    children = jsx(PopChild, { isPresent: isPresent, children: children, root: root });
+  }
+  return jsx(PresenceContext.Provider, { value: context, children: children });
 };
 function newChildrenMap() {
-    return new Map();
+  return new Map();
 }
 
 export { PresenceChild };
diff --git a/dist/es/framer-motion/dist/es/components/AnimatePresence/index.mjs b/dist/es/framer-motion/dist/es/components/AnimatePresence/index.mjs
index f175d9d2dd32619806d2828dd52235b0bdc44289..96f9f4ca0012eaf5d3b6d4429c83588d673935e0 100644
--- a/dist/es/framer-motion/dist/es/components/AnimatePresence/index.mjs
+++ b/dist/es/framer-motion/dist/es/components/AnimatePresence/index.mjs
@@ -1,4 +1,4 @@
-"use client";
+'use client';
 import { jsx, Fragment } from 'react/jsx-runtime';
 import { useMemo, useRef, useState, useContext } from 'react';
 import { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';
@@ -41,126 +41,131 @@ import { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs
  *
  * @public
  */
-const AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, }) => {
-    const [isParentPresent, safeToRemove] = usePresence(propagate);
+const AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = 'sync', propagate = false, root }) => {
+  const [isParentPresent, safeToRemove] = usePresence(propagate);
+  /**
+   * Filter any children that aren't ReactElements. We can only track components
+   * between renders with a props.key.
+   */
+  const presentChildren = useMemo(() => onlyElements(children), [children]);
+  /**
+   * Track the keys of the currently rendered children. This is used to
+   * determine which children are exiting.
+   */
+  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
+  /**
+   * If `initial={false}` we only want to pass this to components in the first render.
+   */
+  const isInitialRender = useRef(true);
+  /**
+   * A ref containing the currently present children. When all exit animations
+   * are complete, we use this to re-render the component with the latest children
+   * *committed* rather than the latest children *rendered*.
+   */
+  const pendingPresentChildren = useRef(presentChildren);
+  /**
+   * Track which exiting children have finished animating out.
+   */
+  const exitComplete = useConstant(() => new Map());
+  /**
+   * Save children to render as React state. To ensure this component is concurrent-safe,
+   * we check for exiting children via an effect.
+   */
+  const [diffedChildren, setDiffedChildren] = useState(presentChildren);
+  const [renderedChildren, setRenderedChildren] = useState(presentChildren);
+  useIsomorphicLayoutEffect(() => {
+    isInitialRender.current = false;
+    pendingPresentChildren.current = presentChildren;
     /**
-     * Filter any children that aren't ReactElements. We can only track components
-     * between renders with a props.key.
+     * Update complete status of exiting children.
      */
-    const presentChildren = useMemo(() => onlyElements(children), [children]);
-    /**
-     * Track the keys of the currently rendered children. This is used to
-     * determine which children are exiting.
-     */
-    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
-    /**
-     * If `initial={false}` we only want to pass this to components in the first render.
-     */
-    const isInitialRender = useRef(true);
+    for (let i = 0; i < renderedChildren.length; i++) {
+      const key = getChildKey(renderedChildren[i]);
+      if (!presentKeys.includes(key)) {
+        if (exitComplete.get(key) !== true) {
+          exitComplete.set(key, false);
+        }
+      } else {
+        exitComplete.delete(key);
+      }
+    }
+  }, [renderedChildren, presentKeys.length, presentKeys.join('-')]);
+  const exitingChildren = [];
+  if (presentChildren !== diffedChildren) {
+    let nextChildren = [...presentChildren];
     /**
-     * A ref containing the currently present children. When all exit animations
-     * are complete, we use this to re-render the component with the latest children
-     * *committed* rather than the latest children *rendered*.
+     * Loop through all the currently rendered components and decide which
+     * are exiting.
      */
-    const pendingPresentChildren = useRef(presentChildren);
+    for (let i = 0; i < renderedChildren.length; i++) {
+      const child = renderedChildren[i];
+      const key = getChildKey(child);
+      if (!presentKeys.includes(key)) {
+        nextChildren.splice(i, 0, child);
+        exitingChildren.push(child);
+      }
+    }
     /**
-     * Track which exiting children have finished animating out.
+     * If we're in "wait" mode, and we have exiting children, we want to
+     * only render these until they've all exited.
      */
-    const exitComplete = useConstant(() => new Map());
+    if (mode === 'wait' && exitingChildren.length) {
+      nextChildren = exitingChildren;
+    }
+    setRenderedChildren(onlyElements(nextChildren));
+    setDiffedChildren(presentChildren);
     /**
-     * Save children to render as React state. To ensure this component is concurrent-safe,
-     * we check for exiting children via an effect.
+     * Early return to ensure once we've set state with the latest diffed
+     * children, we can immediately re-render.
      */
-    const [diffedChildren, setDiffedChildren] = useState(presentChildren);
-    const [renderedChildren, setRenderedChildren] = useState(presentChildren);
-    useIsomorphicLayoutEffect(() => {
-        isInitialRender.current = false;
-        pendingPresentChildren.current = presentChildren;
-        /**
-         * Update complete status of exiting children.
-         */
-        for (let i = 0; i < renderedChildren.length; i++) {
-            const key = getChildKey(renderedChildren[i]);
-            if (!presentKeys.includes(key)) {
-                if (exitComplete.get(key) !== true) {
-                    exitComplete.set(key, false);
-                }
-            }
-            else {
-                exitComplete.delete(key);
-            }
-        }
-    }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
-    const exitingChildren = [];
-    if (presentChildren !== diffedChildren) {
-        let nextChildren = [...presentChildren];
-        /**
-         * Loop through all the currently rendered components and decide which
-         * are exiting.
-         */
-        for (let i = 0; i < renderedChildren.length; i++) {
-            const child = renderedChildren[i];
-            const key = getChildKey(child);
-            if (!presentKeys.includes(key)) {
-                nextChildren.splice(i, 0, child);
-                exitingChildren.push(child);
-            }
+    return;
+  }
+  if (process.env.NODE_ENV !== 'production' && mode === 'wait' && renderedChildren.length > 1) {
+    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
+  }
+  /**
+   * If we've been provided a forceRender function by the LayoutGroupContext,
+   * we can use it to force a re-render amongst all surrounding components once
+   * all components have finished animating out.
+   */
+  const { forceRender } = useContext(LayoutGroupContext);
+  return jsx(Fragment, {
+    children: renderedChildren.map((child) => {
+      const key = getChildKey(child);
+      const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
+      const onExit = () => {
+        if (exitComplete.has(key)) {
+          exitComplete.set(key, true);
+        } else {
+          return;
         }
-        /**
-         * If we're in "wait" mode, and we have exiting children, we want to
-         * only render these until they've all exited.
-         */
-        if (mode === "wait" && exitingChildren.length) {
-            nextChildren = exitingChildren;
+        let isEveryExitComplete = true;
+        exitComplete.forEach((isExitComplete) => {
+          if (!isExitComplete) isEveryExitComplete = false;
+        });
+        if (isEveryExitComplete) {
+          forceRender === null || forceRender === void 0 ? void 0 : forceRender();
+          setRenderedChildren(pendingPresentChildren.current);
+          propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());
+          onExitComplete && onExitComplete();
         }
-        setRenderedChildren(onlyElements(nextChildren));
-        setDiffedChildren(presentChildren);
-        /**
-         * Early return to ensure once we've set state with the latest diffed
-         * children, we can immediately re-render.
-         */
-        return;
-    }
-    if (process.env.NODE_ENV !== "production" &&
-        mode === "wait" &&
-        renderedChildren.length > 1) {
-        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
-    }
-    /**
-     * If we've been provided a forceRender function by the LayoutGroupContext,
-     * we can use it to force a re-render amongst all surrounding components once
-     * all components have finished animating out.
-     */
-    const { forceRender } = useContext(LayoutGroupContext);
-    return (jsx(Fragment, { children: renderedChildren.map((child) => {
-            const key = getChildKey(child);
-            const isPresent = propagate && !isParentPresent
-                ? false
-                : presentChildren === renderedChildren ||
-                    presentKeys.includes(key);
-            const onExit = () => {
-                if (exitComplete.has(key)) {
-                    exitComplete.set(key, true);
-                }
-                else {
-                    return;
-                }
-                let isEveryExitComplete = true;
-                exitComplete.forEach((isExitComplete) => {
-                    if (!isExitComplete)
-                        isEveryExitComplete = false;
-                });
-                if (isEveryExitComplete) {
-                    forceRender === null || forceRender === void 0 ? void 0 : forceRender();
-                    setRenderedChildren(pendingPresentChildren.current);
-                    propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());
-                    onExitComplete && onExitComplete();
-                }
-            };
-            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial
-                    ? undefined
-                    : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, children: child }, key));
-        }) }));
+      };
+      return jsx(
+        PresenceChild,
+        {
+          isPresent: isPresent,
+          initial: !isInitialRender.current || initial ? undefined : false,
+          custom: isPresent ? undefined : custom,
+          presenceAffectsLayout: presenceAffectsLayout,
+          mode: mode,
+          root: root,
+          onExitComplete: isPresent ? undefined : onExit,
+          children: child,
+        },
+        key
+      );
+    }),
+  });
 };
 
 export { AnimatePresence };
