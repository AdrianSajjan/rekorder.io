diff --git a/dist/cjs/client.js b/dist/cjs/client.js
index dc19279c73550ff6d9f4b30d1ec3e11a0236ae8d..94180a5f29095f17b6a8ac55b63133ceb26b46ed 100644
--- a/dist/cjs/client.js
+++ b/dist/cjs/client.js
@@ -2,8 +2,6 @@
 
 Object.defineProperty(exports, '__esModule', { value: true });
 
-var motionUtils = require('motion-utils');
-var motionDom = require('motion-dom');
 var jsxRuntime = require('react/jsx-runtime');
 var react = require('react');
 
@@ -185,6 +183,8 @@ function getFinalKeyframe(keyframes, { repeat, repeatType = "loop" }, finalKeyfr
         : finalKeyframe;
 }
 
+const noop = (any) => any;
+
 function createRenderStep(runNextFrame) {
     /**
      * We create and reuse two queues, one to queue jobs for the current frame
@@ -250,11 +250,10 @@ function createRenderStep(runNextFrame) {
             }
             isProcessing = true;
             [thisFrame, nextFrame] = [nextFrame, thisFrame];
+            // Clear the next frame queue
+            nextFrame.clear();
             // Execute this frame
             thisFrame.forEach(triggerCallback);
-            // Clear the frame so no callbacks remain. This is to avoid
-            // memory leaks should this render step not run for a while.
-            thisFrame.clear();
             isProcessing = false;
             if (flushNextFrame) {
                 flushNextFrame = false;
@@ -333,7 +332,7 @@ function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
     return { schedule, cancel, state, steps };
 }
 
-const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : motionUtils.noop, true);
+const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);
 
 /*
   Bezier function generator
@@ -377,7 +376,7 @@ function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
 function cubicBezier(mX1, mY1, mX2, mY2) {
     // If this is a linear gradient, return linear easing
     if (mX1 === mY1 && mX2 === mY2)
-        return motionUtils.noop;
+        return noop;
     const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
     // If animation is at start/end, return t without easing
     return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
@@ -418,6 +417,21 @@ function isNone(value) {
     }
 }
 
+let warning = noop;
+let invariant = noop;
+if (process.env.NODE_ENV !== "production") {
+    warning = (check, message) => {
+        if (!check && typeof console !== "undefined") {
+            console.warn(message);
+        }
+    };
+    invariant = (check, message) => {
+        if (!check) {
+            throw new Error(message);
+        }
+    };
+}
+
 /**
  * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
  */
@@ -458,7 +472,7 @@ function parseCSSVariable(current) {
 }
 const maxDepth = 4;
 function getVariableValue(current, element, depth = 1) {
-    motionUtils.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
+    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
     const [token, fallback] = parseCSSVariable(current);
     // No CSS variable detected
     if (!token)
@@ -1346,7 +1360,7 @@ function canAnimate(keyframes, name, type, velocity) {
     const targetKeyframe = keyframes[keyframes.length - 1];
     const isOriginAnimatable = isAnimatable(originKeyframe, name);
     const isTargetAnimatable = isAnimatable(targetKeyframe, name);
-    motionUtils.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
+    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
     // Always skip if any of these are true
     if (!isOriginAnimatable || !isTargetAnimatable) {
         return false;
@@ -1454,10 +1468,6 @@ class BaseAnimation {
     then(resolve, reject) {
         return this.currentFinishedPromise.then(resolve, reject);
     }
-    flatten() {
-        this.options.type = "keyframes";
-        this.options.ease = "linear";
-    }
     updateFinishedPromise() {
         this.currentFinishedPromise = new Promise((resolve) => {
             this.resolveFinishedPromise = resolve;
@@ -1465,34 +1475,6 @@ class BaseAnimation {
     }
 }
 
-/*
-  Progress within given range
-
-  Given a lower limit and an upper limit, we return the progress
-  (expressed as a number 0-1) represented by the given value, and
-  limit that progress to within 0-1.
-
-  @param [number]: Lower limit
-  @param [number]: Upper limit
-  @param [number]: Value to find progress within given range
-  @return [number]: Progress of value within range as expressed 0-1
-*/
-const progress = (from, to, value) => {
-    const toFromDifference = to - from;
-    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
-};
-
-const generateLinearEasing = (easing, duration, // as milliseconds
-resolution = 10 // as milliseconds
-) => {
-    let points = "";
-    const numPoints = Math.max(Math.round(duration / resolution), 2);
-    for (let i = 0; i < numPoints; i++) {
-        points += easing(progress(0, numPoints - 1, i)) + ", ";
-    }
-    return `linear(${points.substring(0, points.length - 2)})`;
-};
-
 /*
   Convert velocity into velocity per second
 
@@ -1509,43 +1491,21 @@ function calcGeneratorVelocity(resolveValue, t, current) {
     return velocityPerSecond(current - resolveValue(prevT), t - prevT);
 }
 
-const springDefaults = {
-    // Default spring physics
-    stiffness: 100,
-    damping: 10,
-    mass: 1.0,
-    velocity: 0.0,
-    // Default duration/bounce-based options
-    duration: 800, // in ms
-    bounce: 0.3,
-    visualDuration: 0.3, // in seconds
-    // Rest thresholds
-    restSpeed: {
-        granular: 0.01,
-        default: 2,
-    },
-    restDelta: {
-        granular: 0.005,
-        default: 0.5,
-    },
-    // Limits
-    minDuration: 0.01, // in seconds
-    maxDuration: 10.0, // in seconds
-    minDamping: 0.05,
-    maxDamping: 1,
-};
-
 const safeMin = 0.001;
-function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {
+const minDuration = 0.01;
+const maxDuration$1 = 10.0;
+const minDamping = 0.05;
+const maxDamping = 1;
+function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {
     let envelope;
     let derivative;
-    motionUtils.warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
+    warning(duration <= secondsToMilliseconds(maxDuration$1), "Spring duration must be 10 seconds or less");
     let dampingRatio = 1 - bounce;
     /**
      * Restrict dampingRatio and duration to within acceptable ranges.
      */
-    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
-    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
+    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
+    duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));
     if (dampingRatio < 1) {
         /**
          * Underdamped spring
@@ -1589,8 +1549,8 @@ function findSpring({ duration = springDefaults.duration, bounce = springDefault
     duration = secondsToMilliseconds(duration);
     if (isNaN(undampedFreq)) {
         return {
-            stiffness: springDefaults.stiffness,
-            damping: springDefaults.damping,
+            stiffness: 100,
+            damping: 10,
             duration,
         };
     }
@@ -1615,22 +1575,6 @@ function calcAngularFreq(undampedFreq, dampingRatio) {
     return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
 }
 
-/**
- * Implement a practical max duration for keyframe generation
- * to prevent infinite loops
- */
-const maxGeneratorDuration = 20000;
-function calcGeneratorDuration(generator) {
-    let duration = 0;
-    const timeStep = 50;
-    let state = generator.next(duration);
-    while (!state.done && duration < maxGeneratorDuration) {
-        duration += timeStep;
-        state = generator.next(duration);
-    }
-    return duration >= maxGeneratorDuration ? Infinity : duration;
-}
-
 const durationKeys = ["duration", "bounce"];
 const physicsKeys = ["stiffness", "damping", "mass"];
 function isSpringType(options, keys) {
@@ -1638,51 +1582,29 @@ function isSpringType(options, keys) {
 }
 function getSpringOptions(options) {
     let springOptions = {
-        velocity: springDefaults.velocity,
-        stiffness: springDefaults.stiffness,
-        damping: springDefaults.damping,
-        mass: springDefaults.mass,
+        velocity: 0.0,
+        stiffness: 100,
+        damping: 10,
+        mass: 1.0,
         isResolvedFromDuration: false,
         ...options,
     };
     // stiffness/damping/mass overrides duration/bounce
     if (!isSpringType(options, physicsKeys) &&
         isSpringType(options, durationKeys)) {
-        if (options.visualDuration) {
-            const visualDuration = options.visualDuration;
-            const root = (2 * Math.PI) / (visualDuration * 1.2);
-            const stiffness = root * root;
-            const damping = 2 * clamp(0.05, 1, 1 - options.bounce) * Math.sqrt(stiffness);
-            springOptions = {
-                ...springOptions,
-                mass: springDefaults.mass,
-                stiffness,
-                damping,
-            };
-        }
-        else {
-            const derived = findSpring(options);
-            springOptions = {
-                ...springOptions,
-                ...derived,
-                mass: springDefaults.mass,
-            };
-            springOptions.isResolvedFromDuration = true;
-        }
+        const derived = findSpring(options);
+        springOptions = {
+            ...springOptions,
+            ...derived,
+            mass: 1.0,
+        };
+        springOptions.isResolvedFromDuration = true;
     }
     return springOptions;
 }
-function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
-    const options = typeof optionsOrVisualDuration !== "object"
-        ? {
-            visualDuration: optionsOrVisualDuration,
-            keyframes: [0, 1],
-            bounce,
-        }
-        : optionsOrVisualDuration;
-    let { restSpeed, restDelta } = options;
-    const origin = options.keyframes[0];
-    const target = options.keyframes[options.keyframes.length - 1];
+function spring({ keyframes, restDelta, restSpeed, ...options }) {
+    const origin = keyframes[0];
+    const target = keyframes[keyframes.length - 1];
     /**
      * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
      * to reduce GC during animation.
@@ -1704,12 +1626,8 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
      * ratio between feeling good and finishing as soon as changes are imperceptible.
      */
     const isGranularScale = Math.abs(initialDelta) < 5;
-    restSpeed || (restSpeed = isGranularScale
-        ? springDefaults.restSpeed.granular
-        : springDefaults.restSpeed.default);
-    restDelta || (restDelta = isGranularScale
-        ? springDefaults.restDelta.granular
-        : springDefaults.restDelta.default);
+    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
+    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);
     let resolveSpring;
     if (dampingRatio < 1) {
         const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
@@ -1750,7 +1668,7 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
                     dampedAngularFreq);
         };
     }
-    const generator = {
+    return {
         calculatedDuration: isResolvedFromDuration ? duration || null : null,
         next: (t) => {
             const current = resolveSpring(t);
@@ -1778,13 +1696,7 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
             state.value = state.done ? target : current;
             return state;
         },
-        toString: () => {
-            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
-            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);
-            return calculatedDuration + "ms " + easing;
-        },
     };
-    return generator;
 }
 
 function inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {
@@ -1881,7 +1793,7 @@ const isEasingArray = (ease) => {
 const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
 
 const easingLookup = {
-    linear: motionUtils.noop,
+    linear: noop,
     easeIn,
     easeInOut,
     easeOut,
@@ -1896,13 +1808,13 @@ const easingLookup = {
 const easingDefinitionToFunction = (definition) => {
     if (isBezierDefinition(definition)) {
         // If cubic bezier definition, create bezier curve
-        motionUtils.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
+        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
         const [x1, y1, x2, y2] = definition;
         return cubicBezier(x1, y1, x2, y2);
     }
     else if (typeof definition === "string") {
         // Else lookup from table
-        motionUtils.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);
+        invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);
         return easingLookup[definition];
     }
     return definition;
@@ -1918,6 +1830,23 @@ const easingDefinitionToFunction = (definition) => {
 const combineFunctions = (a, b) => (v) => b(a(v));
 const pipe = (...transformers) => transformers.reduce(combineFunctions);
 
+/*
+  Progress within given range
+
+  Given a lower limit and an upper limit, we return the progress
+  (expressed as a number 0-1) represented by the given value, and
+  limit that progress to within 0-1.
+
+  @param [number]: Lower limit
+  @param [number]: Upper limit
+  @param [number]: Value to find progress within given range
+  @return [number]: Progress of value within range as expressed 0-1
+*/
+const progress = (from, to, value) => {
+    const toFromDifference = to - from;
+    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
+};
+
 /*
   Value in range from progress
 
@@ -2000,12 +1929,12 @@ const colorTypes = [hex, rgba, hsla];
 const getColorType = (v) => colorTypes.find((type) => type.test(v));
 function asRGBA(color) {
     const type = getColorType(color);
-    motionUtils.warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);
+    warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);
     if (!Boolean(type))
         return false;
     let model = type.parse(color);
     if (type === hsla) {
-        // TODO Remove this cast - needed since Motion's stricter typing
+        // TODO Remove this cast - needed since Framer Motion's stricter typing
         model = hslaToRgba(model);
     }
     return model;
@@ -2119,7 +2048,7 @@ const mixComplex = (origin, target) => {
         return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
     }
     else {
-        motionUtils.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
+        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
         return mixImmediate(origin, target);
     }
 };
@@ -2141,7 +2070,7 @@ function createMixers(output, ease, customMixer) {
     for (let i = 0; i < numMixers; i++) {
         let mixer = mixerFactory(output[i], output[i + 1]);
         if (ease) {
-            const easingFunction = Array.isArray(ease) ? ease[i] || motionUtils.noop : ease;
+            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;
             mixer = pipe(easingFunction, mixer);
         }
         mixers.push(mixer);
@@ -2169,7 +2098,7 @@ function createMixers(output, ease, customMixer) {
  */
 function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
     const inputLength = input.length;
-    motionUtils.invariant(inputLength === output.length, "Both input and output ranges must be the same length");
+    invariant(inputLength === output.length, "Both input and output ranges must be the same length");
     /**
      * If we're only provided a single input, we can just make a function
      * that returns the output.
@@ -2262,6 +2191,22 @@ function keyframes({ duration = 300, keyframes: keyframeValues, times, ease = "e
     };
 }
 
+/**
+ * Implement a practical max duration for keyframe generation
+ * to prevent infinite loops
+ */
+const maxGeneratorDuration = 20000;
+function calcGeneratorDuration(generator) {
+    let duration = 0;
+    const timeStep = 50;
+    let state = generator.next(duration);
+    while (!state.done && duration < maxGeneratorDuration) {
+        duration += timeStep;
+        state = generator.next(duration);
+    }
+    return duration >= maxGeneratorDuration ? Infinity : duration;
+}
+
 const frameloopDriver = (update) => {
     const passTimestamp = ({ timestamp }) => update(timestamp);
     return {
@@ -2337,13 +2282,6 @@ class MainThreadAnimation extends BaseAnimation {
         this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);
         this.resolver.scheduleResolve();
     }
-    flatten() {
-        super.flatten();
-        // If we've already resolved the animation, re-initialise it
-        if (this._resolved) {
-            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
-        }
-    }
     initPlayback(keyframes$1) {
         const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;
         const generatorFactory = isGenerator(type)
@@ -2360,7 +2298,7 @@ class MainThreadAnimation extends BaseAnimation {
         if (generatorFactory !== keyframes &&
             typeof keyframes$1[0] !== "number") {
             if (process.env.NODE_ENV !== "production") {
-                motionUtils.invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
+                invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
             }
             mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
             keyframes$1 = [0, 100];
@@ -2659,6 +2597,18 @@ const acceleratedValues = new Set([
     // "background-color"
 ]);
 
+// Create a linear easing point for every 10 ms
+const resolution = 10;
+const generateLinearEasing = (easing, duration // as milliseconds
+) => {
+    let points = "";
+    const numPoints = Math.max(Math.round(duration / resolution), 2);
+    for (let i = 0; i < numPoints; i++) {
+        points += easing(progress(0, numPoints - 1, i)) + ", ";
+    }
+    return `linear(${points.substring(0, points.length - 2)})`;
+};
+
 function memo(callback) {
     let result;
     return () => {
@@ -2732,7 +2682,7 @@ function mapEasingToNativeEasing(easing, duration) {
     }
 }
 
-function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeInOut", times, } = {}) {
+function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease, times, } = {}) {
     const keyframeOptions = { [valueName]: keyframes };
     if (times)
         keyframeOptions.offset = times;
@@ -2961,11 +2911,11 @@ class AcceleratedAnimation extends BaseAnimation {
         else {
             const { resolved } = this;
             if (!resolved)
-                return motionUtils.noop;
+                return noop;
             const { animation } = resolved;
             attachTimeline(animation, timeline);
         }
-        return motionUtils.noop;
+        return noop;
     }
     play() {
         if (this.isStopped)
@@ -3122,9 +3072,6 @@ class GroupPlaybackControls {
     runAll(methodName) {
         this.animations.forEach((controls) => controls[methodName]());
     }
-    flatten() {
-        this.runAll("flatten");
-    }
     play() {
         this.runAll("play");
     }
@@ -3334,7 +3281,7 @@ class MotionValue {
          * This will be replaced by the build step with the latest version number.
          * When MotionValues are provided to motion components, warn if versions are mixed.
          */
-        this.version = "11.15.0";
+        this.version = "11.11.10";
         /**
          * Tracks whether this value can output a velocity. Currently this is only true
          * if the value is numerical, but we might be able to widen the scope here and support
@@ -4240,16 +4187,33 @@ const animations = {
     },
 };
 
-function extractEventInfo(event) {
+const isPrimaryPointer = (event) => {
+    if (event.pointerType === "mouse") {
+        return typeof event.button !== "number" || event.button <= 0;
+    }
+    else {
+        /**
+         * isPrimary is true for all mice buttons, whereas every touch point
+         * is regarded as its own input. So subsequent concurrent touch points
+         * will be false.
+         *
+         * Specifically match against false here as incomplete versions of
+         * PointerEvents in very old browser might have it set as undefined.
+         */
+        return event.isPrimary !== false;
+    }
+};
+
+function extractEventInfo(event, pointType = "page") {
     return {
         point: {
-            x: event.pageX,
-            y: event.pageY,
+            x: event[`${pointType}X`],
+            y: event[`${pointType}Y`],
         },
     };
 }
 const addPointerInfo = (handler) => {
-    return (event) => motionDom.isPrimaryPointer(event) && handler(event, extractEventInfo(event));
+    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
 };
 
 function addDomEvent(target, eventName, handler, options = { passive: true }) {
@@ -4273,7 +4237,7 @@ function distance2D(a, b) {
  * @internal
  */
 class PanSession {
-    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {
+    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
         /**
          * @internal
          */
@@ -4337,7 +4301,7 @@ class PanSession {
             onSessionEnd && onSessionEnd(event, panInfo);
         };
         // If we have more than one touch, don't start detecting this gesture
-        if (!motionDom.isPrimaryPointer(event))
+        if (!isPrimaryPointer(event))
             return;
         this.dragSnapToOrigin = dragSnapToOrigin;
         this.handlers = handlers;
@@ -4416,6 +4380,58 @@ function getVelocity(history, timeDelta) {
     return currentVelocity;
 }
 
+function createLock(name) {
+    let lock = null;
+    return () => {
+        const openLock = () => {
+            lock = null;
+        };
+        if (lock === null) {
+            lock = name;
+            return openLock;
+        }
+        return false;
+    };
+}
+const globalHorizontalLock = createLock("dragHorizontal");
+const globalVerticalLock = createLock("dragVertical");
+function getGlobalLock(drag) {
+    let lock = false;
+    if (drag === "y") {
+        lock = globalVerticalLock();
+    }
+    else if (drag === "x") {
+        lock = globalHorizontalLock();
+    }
+    else {
+        const openHorizontal = globalHorizontalLock();
+        const openVertical = globalVerticalLock();
+        if (openHorizontal && openVertical) {
+            lock = () => {
+                openHorizontal();
+                openVertical();
+            };
+        }
+        else {
+            // Release the locks because we don't use them
+            if (openHorizontal)
+                openHorizontal();
+            if (openVertical)
+                openVertical();
+        }
+    }
+    return lock;
+}
+function isDragActive() {
+    // Check the gesture lock - if we get it, it means no drag gesture is active
+    // and we can safely fire the tap gesture.
+    const openGestureLock = getGlobalLock(true);
+    if (!openGestureLock)
+        return true;
+    openGestureLock();
+    return false;
+}
+
 function isRefObject(ref) {
     return (ref &&
         typeof ref === "object" &&
@@ -4799,7 +4815,7 @@ function measurePageBox(element, rootProjectionNode, transformPagePoint) {
     return viewportBox;
 }
 
-// Fixes https://github.com/motiondivision/motion/issues/2270
+// Fixes https://github.com/framer/motion/issues/2270
 const getContextWindow = ({ current }) => {
     return current ? current.ownerDocument.defaultView : null;
 };
@@ -4811,7 +4827,10 @@ const elementDragControls = new WeakMap();
 // let latestPointerEvent: PointerEvent
 class VisualElementDragControls {
     constructor(visualElement) {
-        this.openDragLock = null;
+        // This is a reference to the global drag gesture lock, ensuring only one component
+        // can "capture" the drag of one or both axes.
+        // TODO: Look into moving this into pansession?
+        this.openGlobalLock = null;
         this.isDragging = false;
         this.currentDirection = null;
         this.originPoint = { x: 0, y: 0 };
@@ -4839,18 +4858,18 @@ class VisualElementDragControls {
             // the component.
             dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();
             if (snapToCursor) {
-                this.snapToCursor(extractEventInfo(event).point);
+                this.snapToCursor(extractEventInfo(event, "page").point);
             }
         };
         const onStart = (event, info) => {
             // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
             const { drag, dragPropagation, onDragStart } = this.getProps();
             if (drag && !dragPropagation) {
-                if (this.openDragLock)
-                    this.openDragLock();
-                this.openDragLock = motionDom.setDragLock(drag);
+                if (this.openGlobalLock)
+                    this.openGlobalLock();
+                this.openGlobalLock = getGlobalLock(drag);
                 // If we don 't have the lock, don't start dragging
-                if (!this.openDragLock)
+                if (!this.openGlobalLock)
                     return;
             }
             this.isDragging = true;
@@ -4892,7 +4911,7 @@ class VisualElementDragControls {
             // latestPointerEvent = event
             const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();
             // If we didn't successfully receive the gesture lock, early return.
-            if (!dragPropagation && !this.openDragLock)
+            if (!dragPropagation && !this.openGlobalLock)
                 return;
             const { offset } = info;
             // Attempt to detect drag direction if directionLock is true
@@ -4960,9 +4979,9 @@ class VisualElementDragControls {
         this.panSession && this.panSession.end();
         this.panSession = undefined;
         const { dragPropagation } = this.getProps();
-        if (!dragPropagation && this.openDragLock) {
-            this.openDragLock();
-            this.openDragLock = null;
+        if (!dragPropagation && this.openGlobalLock) {
+            this.openGlobalLock();
+            this.openGlobalLock = null;
         }
         animationState && animationState.setActive("whileDrag", false);
     }
@@ -5022,7 +5041,7 @@ class VisualElementDragControls {
         if (!constraints || !isRefObject(constraints))
             return false;
         const constraintsElement = constraints.current;
-        motionUtils.invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
+        invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
         const { projection } = this.visualElement;
         // TODO
         if (!projection || !projection.layout)
@@ -5270,8 +5289,8 @@ function getCurrentDirection(offset, lockThreshold = 10) {
 class DragGesture extends Feature {
     constructor(node) {
         super(node);
-        this.removeGroupControls = motionUtils.noop;
-        this.removeListeners = motionUtils.noop;
+        this.removeGroupControls = noop;
+        this.removeListeners = noop;
         this.controls = new VisualElementDragControls(node);
     }
     mount() {
@@ -5281,7 +5300,7 @@ class DragGesture extends Feature {
         if (dragControls) {
             this.removeGroupControls = dragControls.subscribe(this.controls);
         }
-        this.removeListeners = this.controls.addListeners() || motionUtils.noop;
+        this.removeListeners = this.controls.addListeners() || noop;
     }
     unmount() {
         this.removeGroupControls();
@@ -5297,7 +5316,7 @@ const asyncHandler = (handler) => (event, info) => {
 class PanGesture extends Feature {
     constructor() {
         super(...arguments);
-        this.removePointerDownListener = motionUtils.noop;
+        this.removePointerDownListener = noop;
     }
     onPointerDown(pointerDownEvent) {
         this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
@@ -5405,7 +5424,7 @@ function getRadius(values, radiusName) {
 //     )(p)
 // }
 const easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);
-const easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, motionUtils.noop);
+const easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);
 function compress(min, max, easing) {
     return (p) => {
         // Could replace ifs with clamp
@@ -5841,7 +5860,7 @@ function updateMotionValuesFromProps(element, next, prev) {
              * and warn against mismatches.
              */
             if (process.env.NODE_ENV === "development") {
-                warnOnce(nextValue.version === "11.15.0", `Attempting to mix Motion versions ${nextValue.version} with 11.15.0 may not work as expected.`);
+                warnOnce(nextValue.version === "11.11.10", `Attempting to mix Framer Motion versions ${nextValue.version} with 11.11.10 may not work as expected.`);
             }
         }
         else if (isMotionValue(prevValue)) {
@@ -6392,20 +6411,6 @@ class DOMVisualElement extends VisualElement {
         delete vars[key];
         delete style[key];
     }
-    handleChildMotionValue() {
-        if (this.childSubscription) {
-            this.childSubscription();
-            delete this.childSubscription;
-        }
-        const { children } = this.props;
-        if (isMotionValue(children)) {
-            this.childSubscription = children.on("change", (latest) => {
-                if (this.current) {
-                    this.current.textContent = `${latest}`;
-                }
-            });
-        }
-    }
 }
 
 /**
@@ -6733,6 +6738,19 @@ class HTMLVisualElement extends DOMVisualElement {
     scrapeMotionValuesFromProps(props, prevProps, visualElement) {
         return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
     }
+    handleChildMotionValue() {
+        if (this.childSubscription) {
+            this.childSubscription();
+            delete this.childSubscription;
+        }
+        const { children } = this.props;
+        if (isMotionValue(children)) {
+            this.childSubscription = children.on("change", (latest) => {
+                if (this.current)
+                    this.current.textContent = `${latest}`;
+            });
+        }
+    }
 }
 
 function animateSingleValue(value, keyframes, options) {
@@ -8277,7 +8295,7 @@ const userAgentContains = (string) => typeof navigator !== "undefined" &&
  */
 const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/")
     ? Math.round
-    : motionUtils.noop;
+    : noop;
 function roundAxis(axis) {
     // Round to the nearest .5 pixels to support subpixel layouts
     axis.min = roundPoint(axis.min);
@@ -8577,26 +8595,28 @@ const drag = {
     },
 };
 
-function handleHoverEvent(node, event, lifecycle) {
-    const { props } = node;
-    if (node.animationState && props.whileHover) {
-        node.animationState.setActive("whileHover", lifecycle === "Start");
-    }
-    const eventName = ("onHover" + lifecycle);
-    const callback = props[eventName];
-    if (callback) {
-        frame.postRender(() => callback(event, extractEventInfo(event)));
-    }
+function addHoverEvent(node, isActive) {
+    const eventName = isActive ? "pointerenter" : "pointerleave";
+    const callbackName = isActive ? "onHoverStart" : "onHoverEnd";
+    const handleEvent = (event, info) => {
+        if (event.pointerType === "touch" || isDragActive())
+            return;
+        const props = node.getProps();
+        if (node.animationState && props.whileHover) {
+            node.animationState.setActive("whileHover", isActive);
+        }
+        const callback = props[callbackName];
+        if (callback) {
+            frame.postRender(() => callback(event, info));
+        }
+    };
+    return addPointerEvent(node.current, eventName, handleEvent, {
+        passive: !node.getProps()[callbackName],
+    });
 }
 class HoverGesture extends Feature {
     mount() {
-        const { current } = this.node;
-        if (!current)
-            return;
-        this.unmount = motionDom.hover(current, (startEvent) => {
-            handleHoverEvent(this.node, startEvent, "Start");
-            return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
-        });
+        this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
     }
     unmount() { }
 }
@@ -8637,28 +8657,142 @@ class FocusGesture extends Feature {
     unmount() { }
 }
 
-function handlePressEvent(node, event, lifecycle) {
-    const { props } = node;
-    if (node.animationState && props.whileTap) {
-        node.animationState.setActive("whileTap", lifecycle === "Start");
+/**
+ * Recursively traverse up the tree to check whether the provided child node
+ * is the parent or a descendant of it.
+ *
+ * @param parent - Element to find
+ * @param child - Element to test against parent
+ */
+const isNodeOrChild = (parent, child) => {
+    if (!child) {
+        return false;
+    }
+    else if (parent === child) {
+        return true;
     }
-    const eventName = ("onTap" + (lifecycle === "End" ? "" : lifecycle));
-    const callback = props[eventName];
-    if (callback) {
-        frame.postRender(() => callback(event, extractEventInfo(event)));
+    else {
+        return isNodeOrChild(parent, child.parentElement);
     }
+};
+
+function fireSyntheticPointerEvent(name, handler) {
+    if (!handler)
+        return;
+    const syntheticPointerEvent = new PointerEvent("pointer" + name);
+    handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
 }
 class PressGesture extends Feature {
-    mount() {
-        const { current } = this.node;
-        if (!current)
+    constructor() {
+        super(...arguments);
+        this.removeStartListeners = noop;
+        this.removeEndListeners = noop;
+        this.removeAccessibleListeners = noop;
+        this.startPointerPress = (startEvent, startInfo) => {
+            if (this.isPressing)
+                return;
+            this.removeEndListeners();
+            const props = this.node.getProps();
+            const endPointerPress = (endEvent, endInfo) => {
+                if (!this.checkPressEnd())
+                    return;
+                const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
+                /**
+                 * We only count this as a tap gesture if the event.target is the same
+                 * as, or a child of, this component's element
+                 */
+                const handler = !globalTapTarget &&
+                    !isNodeOrChild(this.node.current, endEvent.target)
+                    ? onTapCancel
+                    : onTap;
+                if (handler) {
+                    frame.update(() => handler(endEvent, endInfo));
+                }
+            };
+            const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, {
+                passive: !(props.onTap || props["onPointerUp"]),
+            });
+            const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), {
+                passive: !(props.onTapCancel ||
+                    props["onPointerCancel"]),
+            });
+            this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
+            this.startPress(startEvent, startInfo);
+        };
+        this.startAccessiblePress = () => {
+            const handleKeydown = (keydownEvent) => {
+                if (keydownEvent.key !== "Enter" || this.isPressing)
+                    return;
+                const handleKeyup = (keyupEvent) => {
+                    if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
+                        return;
+                    fireSyntheticPointerEvent("up", (event, info) => {
+                        const { onTap } = this.node.getProps();
+                        if (onTap) {
+                            frame.postRender(() => onTap(event, info));
+                        }
+                    });
+                };
+                this.removeEndListeners();
+                this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
+                fireSyntheticPointerEvent("down", (event, info) => {
+                    this.startPress(event, info);
+                });
+            };
+            const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
+            const handleBlur = () => {
+                if (!this.isPressing)
+                    return;
+                fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
+            };
+            const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
+            this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
+        };
+    }
+    startPress(event, info) {
+        this.isPressing = true;
+        const { onTapStart, whileTap } = this.node.getProps();
+        /**
+         * Ensure we trigger animations before firing event callback
+         */
+        if (whileTap && this.node.animationState) {
+            this.node.animationState.setActive("whileTap", true);
+        }
+        if (onTapStart) {
+            frame.postRender(() => onTapStart(event, info));
+        }
+    }
+    checkPressEnd() {
+        this.removeEndListeners();
+        this.isPressing = false;
+        const props = this.node.getProps();
+        if (props.whileTap && this.node.animationState) {
+            this.node.animationState.setActive("whileTap", false);
+        }
+        return !isDragActive();
+    }
+    cancelPress(event, info) {
+        if (!this.checkPressEnd())
             return;
-        this.unmount = motionDom.press(current, (startEvent) => {
-            handlePressEvent(this.node, startEvent, "Start");
-            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
-        }, { useGlobalTarget: this.node.props.globalTapTarget });
+        const { onTapCancel } = this.node.getProps();
+        if (onTapCancel) {
+            frame.postRender(() => onTapCancel(event, info));
+        }
+    }
+    mount() {
+        const props = this.node.getProps();
+        const removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
+            passive: !(props.onTapStart ||
+                props["onPointerStart"]),
+        });
+        const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
+        this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
+    }
+    unmount() {
+        this.removeStartListeners();
+        this.removeEndListeners();
+        this.removeAccessibleListeners();
     }
-    unmount() { }
 }
 
 /**
@@ -8820,7 +8954,7 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
     const lazyContext = react.useContext(LazyContext);
     const presenceContext = react.useContext(PresenceContext);
     const reducedMotionConfig = react.useContext(MotionConfigContext).reducedMotion;
-    const visualElementRef = react.useRef(null);
+    const visualElementRef = react.useRef();
     /**
      * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
      */
@@ -8849,15 +8983,8 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
         (visualElement.type === "html" || visualElement.type === "svg")) {
         createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
     }
-    const isMounted = react.useRef(false);
     react.useInsertionEffect(() => {
-        /**
-         * Check the component has already mounted before calling
-         * `update` unnecessarily. This ensures we skip the initial update.
-         */
-        if (visualElement && isMounted.current) {
-            visualElement.update(props, presenceContext);
-        }
+        visualElement && visualElement.update(props, presenceContext);
     });
     /**
      * Cache this value as we want to know whether HandoffAppearAnimations
@@ -8870,7 +8997,6 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
     useIsomorphicLayoutEffect(() => {
         if (!visualElement)
             return;
-        isMounted.current = true;
         window.MotionIsMounted = true;
         visualElement.updateFeatures();
         microtask.render(visualElement.render);
@@ -9064,8 +9190,8 @@ function useStrictMode(configAndProps, preloadedFeatures) {
         isStrict) {
         const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
         configAndProps.ignoreStrict
-            ? motionUtils.warning(false, strictMessage)
-            : motionUtils.invariant(false, strictMessage);
+            ? warning(false, strictMessage)
+            : invariant(false, strictMessage);
     }
 }
 function getProjectionFunctionality(props) {
diff --git a/dist/cjs/dom-mini.js b/dist/cjs/dom-mini.js
index c7aa49af0a9d6aad1b5042bb2bf0eaec9563bb55..009d98bc06d3fbc491ee609a00b20cf9b861a75e 100644
--- a/dist/cjs/dom-mini.js
+++ b/dist/cjs/dom-mini.js
@@ -2,9 +2,6 @@
 
 Object.defineProperty(exports, '__esModule', { value: true });
 
-var motionDom = require('motion-dom');
-var motionUtils = require('motion-utils');
-
 function memo(callback) {
     let result;
     return () => {
@@ -77,9 +74,6 @@ class GroupPlaybackControls {
     runAll(methodName) {
         this.animations.forEach((controls) => controls[methodName]());
     }
-    flatten() {
-        this.runAll("flatten");
-    }
     play() {
         this.runAll("play");
     }
@@ -94,6 +88,42 @@ class GroupPlaybackControls {
     }
 }
 
+const noop = (any) => any;
+
+let invariant = noop;
+if (process.env.NODE_ENV !== "production") {
+    invariant = (check, message) => {
+        if (!check) {
+            throw new Error(message);
+        }
+    };
+}
+
+function resolveElements(elements, scope, selectorCache) {
+    var _a;
+    if (typeof elements === "string") {
+        let root = document;
+        if (scope) {
+            invariant(Boolean(scope.current), "Scope provided, but no element detected.");
+            root = scope.current;
+        }
+        if (selectorCache) {
+            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));
+            elements = selectorCache[elements];
+        }
+        else {
+            elements = root.querySelectorAll(elements);
+        }
+    }
+    else if (elements instanceof Element) {
+        elements = [elements];
+    }
+    /**
+     * Return an empty array
+     */
+    return Array.from(elements || []);
+}
+
 /**
  * Converts seconds to milliseconds
  *
@@ -130,8 +160,9 @@ const progress = (from, to, value) => {
     return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
 };
 
-const generateLinearEasing = (easing, duration, // as milliseconds
-resolution = 10 // as milliseconds
+// Create a linear easing point for every 10 ms
+const resolution = 10;
+const generateLinearEasing = (easing, duration // as milliseconds
 ) => {
     let points = "";
     const numPoints = Math.max(Math.round(duration / resolution), 2);
@@ -197,7 +228,7 @@ function mapEasingToNativeEasing(easing, duration) {
     }
 }
 
-function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeInOut", times, } = {}) {
+function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease, times, } = {}) {
     const keyframeOptions = { [valueName]: keyframes };
     if (times)
         keyframeOptions.offset = times;
@@ -357,7 +388,7 @@ class NativeAnimation {
         this.setValue = isCSSVar ? setCSSVar : setStyle;
         this.options = options;
         this.updateFinishedPromise();
-        motionUtils.invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "framer-motion"?`);
+        invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "framer-motion"?`);
         const existingAnimation = getElementAnimationState(element).get(valueName);
         existingAnimation && existingAnimation.stop();
         const readInitialKeyframe = () => {
@@ -369,7 +400,6 @@ class NativeAnimation {
             valueKeyframes = [valueKeyframes];
         }
         hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe);
-        // TODO: Replace this with toString()?
         if (isGenerator(options.type)) {
             const generatorOptions = createGeneratorEasing(options, 100, options.type);
             options.ease = supportsLinearEasing()
@@ -431,12 +461,6 @@ class NativeAnimation {
     get startTime() {
         return this.animation ? this.animation.startTime : null;
     }
-    flatten() {
-        var _a;
-        if (!this.animation)
-            return;
-        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: "linear" });
-    }
     play() {
         if (this.state === "finished") {
             this.updateFinishedPromise();
@@ -487,14 +511,14 @@ class NativeAnimation {
         else {
             attachTimeline(this.animation, timeline);
         }
-        return motionUtils.noop;
+        return noop;
     }
 }
 
 function animateElements(elementOrSelector, keyframes, options, scope) {
-    const elements = motionDom.resolveElements(elementOrSelector, scope);
+    const elements = resolveElements(elementOrSelector, scope);
     const numElements = elements.length;
-    motionUtils.invariant(Boolean(numElements), "No valid element provided.");
+    invariant(Boolean(numElements), "No valid element provided.");
     const animations = [];
     for (let i = 0; i < numElements; i++) {
         const element = elements[i];
@@ -508,7 +532,7 @@ function animateElements(elementOrSelector, keyframes, options, scope) {
         for (const valueName in keyframes) {
             const valueKeyframes = keyframes[valueName];
             const valueOptions = {
-                ...getValueTransition(elementTransition, valueName),
+                ...getValueTransition(options, valueName),
             };
             valueOptions.duration = valueOptions.duration
                 ? secondsToMilliseconds(valueOptions.duration)
diff --git a/dist/cjs/dom.js b/dist/cjs/dom.js
index 918725edffaff717e2c146c25b429e3458abc0f5..3dcf06e94a679eb32a0b478885981c0279d7995c 100644
--- a/dist/cjs/dom.js
+++ b/dist/cjs/dom.js
@@ -2,8 +2,7 @@
 
 Object.defineProperty(exports, '__esModule', { value: true });
 
-var motionUtils = require('motion-utils');
-var motionDom = require('motion-dom');
+const noop = (any) => any;
 
 const MotionGlobalConfig = {
     skipAnimations: false,
@@ -75,11 +74,10 @@ function createRenderStep(runNextFrame) {
             }
             isProcessing = true;
             [thisFrame, nextFrame] = [nextFrame, thisFrame];
+            // Clear the next frame queue
+            nextFrame.clear();
             // Execute this frame
             thisFrame.forEach(triggerCallback);
-            // Clear the frame so no callbacks remain. This is to avoid
-            // memory leaks should this render step not run for a while.
-            thisFrame.clear();
             isProcessing = false;
             if (flushNextFrame) {
                 flushNextFrame = false;
@@ -158,7 +156,7 @@ function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
     return { schedule, cancel, state, steps };
 }
 
-const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : motionUtils.noop, true);
+const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);
 
 function addUniqueItem(arr, item) {
     if (arr.indexOf(item) === -1)
@@ -281,7 +279,7 @@ class MotionValue {
          * This will be replaced by the build step with the latest version number.
          * When MotionValues are provided to motion components, warn if versions are mixed.
          */
-        this.version = "11.15.0";
+        this.version = "11.11.10";
         /**
          * Tracks whether this value can output a velocity. Currently this is only true
          * if the value is numerical, but we might be able to widen the scope here and support
@@ -632,9 +630,6 @@ class GroupPlaybackControls {
     runAll(methodName) {
         this.animations.forEach((controls) => controls[methodName]());
     }
-    flatten() {
-        this.runAll("flatten");
-    }
     play() {
         this.runAll("play");
     }
@@ -649,34 +644,6 @@ class GroupPlaybackControls {
     }
 }
 
-/*
-  Progress within given range
-
-  Given a lower limit and an upper limit, we return the progress
-  (expressed as a number 0-1) represented by the given value, and
-  limit that progress to within 0-1.
-
-  @param [number]: Lower limit
-  @param [number]: Upper limit
-  @param [number]: Value to find progress within given range
-  @return [number]: Progress of value within range as expressed 0-1
-*/
-const progress = (from, to, value) => {
-    const toFromDifference = to - from;
-    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
-};
-
-const generateLinearEasing = (easing, duration, // as milliseconds
-resolution = 10 // as milliseconds
-) => {
-    let points = "";
-    const numPoints = Math.max(Math.round(duration / resolution), 2);
-    for (let i = 0; i < numPoints; i++) {
-        points += easing(progress(0, numPoints - 1, i)) + ", ";
-    }
-    return `linear(${points.substring(0, points.length - 2)})`;
-};
-
 /**
  * Converts seconds to milliseconds
  *
@@ -692,6 +659,21 @@ function calcGeneratorVelocity(resolveValue, t, current) {
     return velocityPerSecond(current - resolveValue(prevT), t - prevT);
 }
 
+exports.warning = noop;
+exports.invariant = noop;
+if (process.env.NODE_ENV !== "production") {
+    exports.warning = (check, message) => {
+        if (!check && typeof console !== "undefined") {
+            console.warn(message);
+        }
+    };
+    exports.invariant = (check, message) => {
+        if (!check) {
+            throw new Error(message);
+        }
+    };
+}
+
 const clamp = (min, max, v) => {
     if (v > max)
         return max;
@@ -700,43 +682,21 @@ const clamp = (min, max, v) => {
     return v;
 };
 
-const springDefaults = {
-    // Default spring physics
-    stiffness: 100,
-    damping: 10,
-    mass: 1.0,
-    velocity: 0.0,
-    // Default duration/bounce-based options
-    duration: 800, // in ms
-    bounce: 0.3,
-    visualDuration: 0.3, // in seconds
-    // Rest thresholds
-    restSpeed: {
-        granular: 0.01,
-        default: 2,
-    },
-    restDelta: {
-        granular: 0.005,
-        default: 0.5,
-    },
-    // Limits
-    minDuration: 0.01, // in seconds
-    maxDuration: 10.0, // in seconds
-    minDamping: 0.05,
-    maxDamping: 1,
-};
-
 const safeMin = 0.001;
-function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {
+const minDuration = 0.01;
+const maxDuration$1 = 10.0;
+const minDamping = 0.05;
+const maxDamping = 1;
+function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {
     let envelope;
     let derivative;
-    motionUtils.warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
+    exports.warning(duration <= secondsToMilliseconds(maxDuration$1), "Spring duration must be 10 seconds or less");
     let dampingRatio = 1 - bounce;
     /**
      * Restrict dampingRatio and duration to within acceptable ranges.
      */
-    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
-    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
+    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
+    duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));
     if (dampingRatio < 1) {
         /**
          * Underdamped spring
@@ -780,8 +740,8 @@ function findSpring({ duration = springDefaults.duration, bounce = springDefault
     duration = secondsToMilliseconds(duration);
     if (isNaN(undampedFreq)) {
         return {
-            stiffness: springDefaults.stiffness,
-            damping: springDefaults.damping,
+            stiffness: 100,
+            damping: 10,
             duration,
         };
     }
@@ -806,22 +766,6 @@ function calcAngularFreq(undampedFreq, dampingRatio) {
     return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
 }
 
-/**
- * Implement a practical max duration for keyframe generation
- * to prevent infinite loops
- */
-const maxGeneratorDuration = 20000;
-function calcGeneratorDuration(generator) {
-    let duration = 0;
-    const timeStep = 50;
-    let state = generator.next(duration);
-    while (!state.done && duration < maxGeneratorDuration) {
-        duration += timeStep;
-        state = generator.next(duration);
-    }
-    return duration >= maxGeneratorDuration ? Infinity : duration;
-}
-
 const durationKeys = ["duration", "bounce"];
 const physicsKeys = ["stiffness", "damping", "mass"];
 function isSpringType(options, keys) {
@@ -829,51 +773,29 @@ function isSpringType(options, keys) {
 }
 function getSpringOptions(options) {
     let springOptions = {
-        velocity: springDefaults.velocity,
-        stiffness: springDefaults.stiffness,
-        damping: springDefaults.damping,
-        mass: springDefaults.mass,
+        velocity: 0.0,
+        stiffness: 100,
+        damping: 10,
+        mass: 1.0,
         isResolvedFromDuration: false,
         ...options,
     };
     // stiffness/damping/mass overrides duration/bounce
     if (!isSpringType(options, physicsKeys) &&
         isSpringType(options, durationKeys)) {
-        if (options.visualDuration) {
-            const visualDuration = options.visualDuration;
-            const root = (2 * Math.PI) / (visualDuration * 1.2);
-            const stiffness = root * root;
-            const damping = 2 * clamp(0.05, 1, 1 - options.bounce) * Math.sqrt(stiffness);
-            springOptions = {
-                ...springOptions,
-                mass: springDefaults.mass,
-                stiffness,
-                damping,
-            };
-        }
-        else {
-            const derived = findSpring(options);
-            springOptions = {
-                ...springOptions,
-                ...derived,
-                mass: springDefaults.mass,
-            };
-            springOptions.isResolvedFromDuration = true;
-        }
+        const derived = findSpring(options);
+        springOptions = {
+            ...springOptions,
+            ...derived,
+            mass: 1.0,
+        };
+        springOptions.isResolvedFromDuration = true;
     }
     return springOptions;
 }
-function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
-    const options = typeof optionsOrVisualDuration !== "object"
-        ? {
-            visualDuration: optionsOrVisualDuration,
-            keyframes: [0, 1],
-            bounce,
-        }
-        : optionsOrVisualDuration;
-    let { restSpeed, restDelta } = options;
-    const origin = options.keyframes[0];
-    const target = options.keyframes[options.keyframes.length - 1];
+function spring({ keyframes, restDelta, restSpeed, ...options }) {
+    const origin = keyframes[0];
+    const target = keyframes[keyframes.length - 1];
     /**
      * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
      * to reduce GC during animation.
@@ -895,12 +817,8 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
      * ratio between feeling good and finishing as soon as changes are imperceptible.
      */
     const isGranularScale = Math.abs(initialDelta) < 5;
-    restSpeed || (restSpeed = isGranularScale
-        ? springDefaults.restSpeed.granular
-        : springDefaults.restSpeed.default);
-    restDelta || (restDelta = isGranularScale
-        ? springDefaults.restDelta.granular
-        : springDefaults.restDelta.default);
+    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
+    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);
     let resolveSpring;
     if (dampingRatio < 1) {
         const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
@@ -941,7 +859,7 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
                     dampedAngularFreq);
         };
     }
-    const generator = {
+    return {
         calculatedDuration: isResolvedFromDuration ? duration || null : null,
         next: (t) => {
             const current = resolveSpring(t);
@@ -969,13 +887,23 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
             state.value = state.done ? target : current;
             return state;
         },
-        toString: () => {
-            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
-            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);
-            return calculatedDuration + "ms " + easing;
-        },
     };
-    return generator;
+}
+
+/**
+ * Implement a practical max duration for keyframe generation
+ * to prevent infinite loops
+ */
+const maxGeneratorDuration = 20000;
+function calcGeneratorDuration(generator) {
+    let duration = 0;
+    const timeStep = 50;
+    let state = generator.next(duration);
+    while (!state.done && duration < maxGeneratorDuration) {
+        duration += timeStep;
+        state = generator.next(duration);
+    }
+    return duration >= maxGeneratorDuration ? Infinity : duration;
 }
 
 /**
@@ -1016,6 +944,23 @@ const mixNumber$1 = (from, to, progress) => {
     return from + (to - from) * progress;
 };
 
+/*
+  Progress within given range
+
+  Given a lower limit and an upper limit, we return the progress
+  (expressed as a number 0-1) represented by the given value, and
+  limit that progress to within 0-1.
+
+  @param [number]: Lower limit
+  @param [number]: Upper limit
+  @param [number]: Value to find progress within given range
+  @return [number]: Progress of value within range as expressed 0-1
+*/
+const progress = (from, to, value) => {
+    const toFromDifference = to - from;
+    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
+};
+
 function fillOffset(offset, remaining) {
     const min = offset[offset.length - 1];
     for (let i = 1; i <= remaining; i++) {
@@ -1032,13 +977,38 @@ function defaultOffset$1(arr) {
 
 const isMotionValue = (value) => Boolean(value && value.getVelocity);
 
+function resolveElements(elements, scope, selectorCache) {
+    var _a;
+    if (typeof elements === "string") {
+        let root = document;
+        if (scope) {
+            exports.invariant(Boolean(scope.current), "Scope provided, but no element detected.");
+            root = scope.current;
+        }
+        if (selectorCache) {
+            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));
+            elements = selectorCache[elements];
+        }
+        else {
+            elements = root.querySelectorAll(elements);
+        }
+    }
+    else if (elements instanceof Element) {
+        elements = [elements];
+    }
+    /**
+     * Return an empty array
+     */
+    return Array.from(elements || []);
+}
+
 function isDOMKeyframes(keyframes) {
     return typeof keyframes === "object" && !Array.isArray(keyframes);
 }
 
 function resolveSubjects(subject, keyframes, scope, selectorCache) {
     if (typeof subject === "string" && isDOMKeyframes(keyframes)) {
-        return motionDom.resolveElements(subject, scope, selectorCache);
+        return resolveElements(subject, scope, selectorCache);
     }
     else if (subject instanceof NodeList) {
         return Array.from(subject);
@@ -1127,24 +1097,7 @@ function compareByTime(a, b) {
     }
 }
 
-/**
- * Take an array of times that represent repeated keyframes. For instance
- * if we have original times of [0, 0.5, 1] then our repeated times will
- * be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back
- * down to a 0-1 scale.
- */
-function normalizeTimes(times, repeat) {
-    for (let i = 0; i < times.length; i++) {
-        times[i] = times[i] / (repeat + 1);
-    }
-}
-
-function calculateRepeatDuration(duration, repeat, _repeatDelay) {
-    return duration * (repeat + 1);
-}
-
 const defaultSegmentEasing = "easeInOut";
-const MAX_REPEAT = 20;
 function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {
     const defaultDuration = defaultTransition.duration || 0.3;
     const animationDefinitions = new Map();
@@ -1187,7 +1140,7 @@ function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...seq
         let maxDuration = 0;
         const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
             const valueKeyframesAsList = keyframesAsList(valueKeyframes);
-            const { delay = 0, times = defaultOffset$1(valueKeyframesAsList), type = "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;
+            const { delay = 0, times = defaultOffset$1(valueKeyframesAsList), type = "keyframes", ...remainingTransition } = valueTransition;
             let { ease = defaultTransition.ease || "easeOut", duration } = valueTransition;
             /**
              * Resolve stagger() if defined.
@@ -1225,6 +1178,7 @@ function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...seq
             }
             duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);
             const startTime = currentTime + calculatedDelay;
+            const targetTime = startTime + duration;
             /**
              * If there's only one time offset of 0, fill in a second with length 1
              */
@@ -1243,28 +1197,6 @@ function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...seq
              */
             valueKeyframesAsList.length === 1 &&
                 valueKeyframesAsList.unshift(null);
-            /**
-             * Handle repeat options
-             */
-            if (repeat) {
-                motionUtils.invariant(repeat < MAX_REPEAT, "Repeat count too high, must be less than 20");
-                duration = calculateRepeatDuration(duration, repeat);
-                const originalKeyframes = [...valueKeyframesAsList];
-                const originalTimes = [...times];
-                ease = Array.isArray(ease) ? [...ease] : [ease];
-                const originalEase = [...ease];
-                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
-                    valueKeyframesAsList.push(...originalKeyframes);
-                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {
-                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));
-                        ease.push(keyframeIndex === 0
-                            ? "linear"
-                            : getEasingForSegment(originalEase, keyframeIndex - 1));
-                    }
-                }
-                normalizeTimes(times, repeat);
-            }
-            const targetTime = startTime + duration;
             /**
              * Add keyframes, mapping offsets to absolute time.
              */
@@ -1509,7 +1441,7 @@ function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
 function cubicBezier(mX1, mY1, mX2, mY2) {
     // If this is a linear gradient, return linear easing
     if (mX1 === mY1 && mX2 === mY2)
-        return motionUtils.noop;
+        return noop;
     const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
     // If animation is at start/end, return t without easing
     return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
@@ -1590,7 +1522,7 @@ function parseCSSVariable(current) {
 }
 const maxDepth = 4;
 function getVariableValue(current, element, depth = 1) {
-    motionUtils.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
+    exports.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
     const [token, fallback] = parseCSSVariable(current);
     // No CSS variable detected
     if (!token)
@@ -2439,7 +2371,7 @@ function canAnimate(keyframes, name, type, velocity) {
     const targetKeyframe = keyframes[keyframes.length - 1];
     const isOriginAnimatable = isAnimatable(originKeyframe, name);
     const isTargetAnimatable = isAnimatable(targetKeyframe, name);
-    motionUtils.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
+    exports.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
     // Always skip if any of these are true
     if (!isOriginAnimatable || !isTargetAnimatable) {
         return false;
@@ -2547,10 +2479,6 @@ class BaseAnimation {
     then(resolve, reject) {
         return this.currentFinishedPromise.then(resolve, reject);
     }
-    flatten() {
-        this.options.type = "keyframes";
-        this.options.ease = "linear";
-    }
     updateFinishedPromise() {
         this.currentFinishedPromise = new Promise((resolve) => {
             this.resolveFinishedPromise = resolve;
@@ -2648,7 +2576,7 @@ const easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);
 const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
 
 const easingLookup = {
-    linear: motionUtils.noop,
+    linear: noop,
     easeIn,
     easeInOut,
     easeOut,
@@ -2663,13 +2591,13 @@ const easingLookup = {
 const easingDefinitionToFunction = (definition) => {
     if (isBezierDefinition(definition)) {
         // If cubic bezier definition, create bezier curve
-        motionUtils.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
+        exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
         const [x1, y1, x2, y2] = definition;
         return cubicBezier(x1, y1, x2, y2);
     }
     else if (typeof definition === "string") {
         // Else lookup from table
-        motionUtils.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);
+        exports.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);
         return easingLookup[definition];
     }
     return definition;
@@ -2742,12 +2670,12 @@ const colorTypes = [hex, rgba, hsla];
 const getColorType = (v) => colorTypes.find((type) => type.test(v));
 function asRGBA(color) {
     const type = getColorType(color);
-    motionUtils.warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);
+    exports.warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);
     if (!Boolean(type))
         return false;
     let model = type.parse(color);
     if (type === hsla) {
-        // TODO Remove this cast - needed since Motion's stricter typing
+        // TODO Remove this cast - needed since Framer Motion's stricter typing
         model = hslaToRgba(model);
     }
     return model;
@@ -2861,7 +2789,7 @@ const mixComplex = (origin, target) => {
         return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
     }
     else {
-        motionUtils.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
+        exports.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
         return mixImmediate(origin, target);
     }
 };
@@ -2883,7 +2811,7 @@ function createMixers(output, ease, customMixer) {
     for (let i = 0; i < numMixers; i++) {
         let mixer = mixerFactory(output[i], output[i + 1]);
         if (ease) {
-            const easingFunction = Array.isArray(ease) ? ease[i] || motionUtils.noop : ease;
+            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;
             mixer = pipe(easingFunction, mixer);
         }
         mixers.push(mixer);
@@ -2911,7 +2839,7 @@ function createMixers(output, ease, customMixer) {
  */
 function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
     const inputLength = input.length;
-    motionUtils.invariant(inputLength === output.length, "Both input and output ranges must be the same length");
+    exports.invariant(inputLength === output.length, "Both input and output ranges must be the same length");
     /**
      * If we're only provided a single input, we can just make a function
      * that returns the output.
@@ -3065,13 +2993,6 @@ class MainThreadAnimation extends BaseAnimation {
         this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);
         this.resolver.scheduleResolve();
     }
-    flatten() {
-        super.flatten();
-        // If we've already resolved the animation, re-initialise it
-        if (this._resolved) {
-            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
-        }
-    }
     initPlayback(keyframes$1) {
         const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;
         const generatorFactory = isGenerator(type)
@@ -3088,7 +3009,7 @@ class MainThreadAnimation extends BaseAnimation {
         if (generatorFactory !== keyframes &&
             typeof keyframes$1[0] !== "number") {
             if (process.env.NODE_ENV !== "production") {
-                motionUtils.invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
+                exports.invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
             }
             mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
             keyframes$1 = [0, 100];
@@ -3387,6 +3308,18 @@ const acceleratedValues = new Set([
     // "background-color"
 ]);
 
+// Create a linear easing point for every 10 ms
+const resolution = 10;
+const generateLinearEasing = (easing, duration // as milliseconds
+) => {
+    let points = "";
+    const numPoints = Math.max(Math.round(duration / resolution), 2);
+    for (let i = 0; i < numPoints; i++) {
+        points += easing(progress(0, numPoints - 1, i)) + ", ";
+    }
+    return `linear(${points.substring(0, points.length - 2)})`;
+};
+
 /**
  * Add the ability for test suites to manually set support flags
  * to better test more environments.
@@ -3451,7 +3384,7 @@ function mapEasingToNativeEasing(easing, duration) {
     }
 }
 
-function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeInOut", times, } = {}) {
+function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease, times, } = {}) {
     const keyframeOptions = { [valueName]: keyframes };
     if (times)
         keyframeOptions.offset = times;
@@ -3680,11 +3613,11 @@ class AcceleratedAnimation extends BaseAnimation {
         else {
             const { resolved } = this;
             if (!resolved)
-                return motionUtils.noop;
+                return noop;
             const { animation } = resolved;
             attachTimeline(animation, timeline);
         }
-        return motionUtils.noop;
+        return noop;
     }
     play() {
         if (this.isStopped)
@@ -4156,7 +4089,7 @@ function updateMotionValuesFromProps(element, next, prev) {
              * and warn against mismatches.
              */
             if (process.env.NODE_ENV === "development") {
-                warnOnce(nextValue.version === "11.15.0", `Attempting to mix Motion versions ${nextValue.version} with 11.15.0 may not work as expected.`);
+                warnOnce(nextValue.version === "11.11.10", `Attempting to mix Framer Motion versions ${nextValue.version} with 11.11.10 may not work as expected.`);
             }
         }
         else if (isMotionValue(prevValue)) {
@@ -4713,20 +4646,6 @@ class DOMVisualElement extends VisualElement {
         delete vars[key];
         delete style[key];
     }
-    handleChildMotionValue() {
-        if (this.childSubscription) {
-            this.childSubscription();
-            delete this.childSubscription;
-        }
-        const { children } = this.props;
-        if (isMotionValue(children)) {
-            this.childSubscription = children.on("change", (latest) => {
-                if (this.current) {
-                    this.current.textContent = `${latest}`;
-                }
-            });
-        }
-    }
 }
 
 /**
@@ -5087,6 +5006,19 @@ class HTMLVisualElement extends DOMVisualElement {
     scrapeMotionValuesFromProps(props, prevProps, visualElement) {
         return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
     }
+    handleChildMotionValue() {
+        if (this.childSubscription) {
+            this.childSubscription();
+            delete this.childSubscription;
+        }
+        const { children } = this.props;
+        if (isMotionValue(children)) {
+            this.childSubscription = children.on("change", (latest) => {
+                if (this.current)
+                    this.current.textContent = `${latest}`;
+            });
+        }
+    }
 }
 
 function isObjectKey(key, object) {
@@ -5187,7 +5119,7 @@ function animateSubject(subject, keyframes, options, scope) {
     else {
         const subjects = resolveSubjects(subject, keyframes, scope);
         const numSubjects = subjects.length;
-        motionUtils.invariant(Boolean(numSubjects), "No valid elements provided.");
+        exports.invariant(Boolean(numSubjects), "No valid elements provided.");
         for (let i = 0; i < numSubjects; i++) {
             const thisSubject = subjects[i];
             const createVisualElement = thisSubject instanceof Element
@@ -5293,7 +5225,7 @@ class NativeAnimation {
         this.setValue = isCSSVar ? setCSSVar : setStyle;
         this.options = options;
         this.updateFinishedPromise();
-        motionUtils.invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "framer-motion"?`);
+        exports.invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "framer-motion"?`);
         const existingAnimation = getElementAnimationState(element).get(valueName);
         existingAnimation && existingAnimation.stop();
         const readInitialKeyframe = () => {
@@ -5305,7 +5237,6 @@ class NativeAnimation {
             valueKeyframes = [valueKeyframes];
         }
         hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe);
-        // TODO: Replace this with toString()?
         if (isGenerator(options.type)) {
             const generatorOptions = createGeneratorEasing(options, 100, options.type);
             options.ease = supportsLinearEasing()
@@ -5367,12 +5298,6 @@ class NativeAnimation {
     get startTime() {
         return this.animation ? this.animation.startTime : null;
     }
-    flatten() {
-        var _a;
-        if (!this.animation)
-            return;
-        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: "linear" });
-    }
     play() {
         if (this.state === "finished") {
             this.updateFinishedPromise();
@@ -5423,14 +5348,14 @@ class NativeAnimation {
         else {
             attachTimeline(this.animation, timeline);
         }
-        return motionUtils.noop;
+        return noop;
     }
 }
 
 function animateElements(elementOrSelector, keyframes, options, scope) {
-    const elements = motionDom.resolveElements(elementOrSelector, scope);
+    const elements = resolveElements(elementOrSelector, scope);
     const numElements = elements.length;
-    motionUtils.invariant(Boolean(numElements), "No valid element provided.");
+    exports.invariant(Boolean(numElements), "No valid element provided.");
     const animations = [];
     for (let i = 0; i < numElements; i++) {
         const element = elements[i];
@@ -5444,7 +5369,7 @@ function animateElements(elementOrSelector, keyframes, options, scope) {
         for (const valueName in keyframes) {
             const valueKeyframes = keyframes[valueName];
             const valueOptions = {
-                ...getValueTransition(elementTransition, valueName),
+                ...getValueTransition(options, valueName),
             };
             valueOptions.duration = valueOptions.duration
                 ? secondsToMilliseconds(valueOptions.duration)
@@ -5504,7 +5429,7 @@ function createResizeObserver() {
 function resizeElement(target, handler) {
     if (!observer)
         createResizeObserver();
-    const elements = motionDom.resolveElements(target);
+    const elements = resolveElements(target);
     elements.forEach((element) => {
         let elementHandlers = resizeHandlers.get(element);
         if (!elementHandlers) {
@@ -5989,7 +5914,6 @@ function scrollFunction(onScroll, options) {
     }
 }
 function scrollAnimation(animation, options) {
-    animation.flatten();
     if (needsElementTracking(options)) {
         animation.pause();
         return scrollInfo((info) => {
@@ -5998,17 +5922,12 @@ function scrollAnimation(animation, options) {
     }
     else {
         const timeline = getTimeline(options);
-        if (animation.attachTimeline) {
-            return animation.attachTimeline(timeline, (valueAnimation) => {
-                valueAnimation.pause();
-                return observeTimeline((progress) => {
-                    valueAnimation.time = valueAnimation.duration * progress;
-                }, timeline);
-            });
-        }
-        else {
-            return motionUtils.noop;
-        }
+        return animation.attachTimeline(timeline, (valueAnimation) => {
+            valueAnimation.pause();
+            return observeTimeline((progress) => {
+                valueAnimation.time = valueAnimation.duration * progress;
+            }, timeline);
+        });
     }
 }
 function scroll(onScroll, { axis = "y", ...options } = {}) {
@@ -6023,7 +5942,7 @@ const thresholds = {
     all: 1,
 };
 function inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = "some" } = {}) {
-    const elements = motionDom.resolveElements(elementOrSelector);
+    const elements = resolveElements(elementOrSelector);
     const activeIntersections = new WeakMap();
     const onIntersectionChange = (entries) => {
         entries.forEach((entry) => {
@@ -6154,18 +6073,6 @@ const cancelSync = stepsOrder.reduce((acc, key) => {
     return acc;
 }, {});
 
-Object.defineProperty(exports, "invariant", {
-    enumerable: true,
-    get: function () { return motionUtils.invariant; }
-});
-Object.defineProperty(exports, "noop", {
-    enumerable: true,
-    get: function () { return motionUtils.noop; }
-});
-Object.defineProperty(exports, "isDragActive", {
-    enumerable: true,
-    get: function () { return motionDom.isDragActive; }
-});
 exports.MotionValue = MotionValue;
 exports.animate = animate;
 exports.animateMini = animateMini;
@@ -6206,6 +6113,5 @@ exports.spring = spring;
 exports.stagger = stagger;
 exports.steps = steps;
 exports.sync = sync;
-exports.time = time;
 exports.transform = transform;
 exports.wrap = wrap;
diff --git a/dist/cjs/index.js b/dist/cjs/index.js
index e3a4c9e614bec7f2c4385eafdfb3e4bcbbb8f96a..3e5eb28eff904723bcdb960a3e568f1ad8ad0055 100644
--- a/dist/cjs/index.js
+++ b/dist/cjs/index.js
@@ -2,8 +2,6 @@
 
 Object.defineProperty(exports, '__esModule', { value: true });
 
-var motionUtils = require('motion-utils');
-var motionDom = require('motion-dom');
 var jsxRuntime = require('react/jsx-runtime');
 var React = require('react');
 
@@ -253,6 +251,8 @@ function getFinalKeyframe(keyframes, { repeat, repeatType = "loop" }, finalKeyfr
         : finalKeyframe;
 }
 
+const noop = (any) => any;
+
 function createRenderStep(runNextFrame) {
     /**
      * We create and reuse two queues, one to queue jobs for the current frame
@@ -318,11 +318,10 @@ function createRenderStep(runNextFrame) {
             }
             isProcessing = true;
             [thisFrame, nextFrame] = [nextFrame, thisFrame];
+            // Clear the next frame queue
+            nextFrame.clear();
             // Execute this frame
             thisFrame.forEach(triggerCallback);
-            // Clear the frame so no callbacks remain. This is to avoid
-            // memory leaks should this render step not run for a while.
-            thisFrame.clear();
             isProcessing = false;
             if (flushNextFrame) {
                 flushNextFrame = false;
@@ -403,7 +402,7 @@ function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
     return { schedule, cancel, state, steps };
 }
 
-const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : motionUtils.noop, true);
+const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);
 
 /*
   Bezier function generator
@@ -447,7 +446,7 @@ function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
 function cubicBezier(mX1, mY1, mX2, mY2) {
     // If this is a linear gradient, return linear easing
     if (mX1 === mY1 && mX2 === mY2)
-        return motionUtils.noop;
+        return noop;
     const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
     // If animation is at start/end, return t without easing
     return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
@@ -488,6 +487,21 @@ function isNone(value) {
     }
 }
 
+exports.warning = noop;
+exports.invariant = noop;
+if (process.env.NODE_ENV !== "production") {
+    exports.warning = (check, message) => {
+        if (!check && typeof console !== "undefined") {
+            console.warn(message);
+        }
+    };
+    exports.invariant = (check, message) => {
+        if (!check) {
+            throw new Error(message);
+        }
+    };
+}
+
 /**
  * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
  */
@@ -528,7 +542,7 @@ function parseCSSVariable(current) {
 }
 const maxDepth = 4;
 function getVariableValue(current, element, depth = 1) {
-    motionUtils.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
+    exports.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
     const [token, fallback] = parseCSSVariable(current);
     // No CSS variable detected
     if (!token)
@@ -1416,7 +1430,7 @@ function canAnimate(keyframes, name, type, velocity) {
     const targetKeyframe = keyframes[keyframes.length - 1];
     const isOriginAnimatable = isAnimatable(originKeyframe, name);
     const isTargetAnimatable = isAnimatable(targetKeyframe, name);
-    motionUtils.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
+    exports.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
     // Always skip if any of these are true
     if (!isOriginAnimatable || !isTargetAnimatable) {
         return false;
@@ -1524,10 +1538,6 @@ class BaseAnimation {
     then(resolve, reject) {
         return this.currentFinishedPromise.then(resolve, reject);
     }
-    flatten() {
-        this.options.type = "keyframes";
-        this.options.ease = "linear";
-    }
     updateFinishedPromise() {
         this.currentFinishedPromise = new Promise((resolve) => {
             this.resolveFinishedPromise = resolve;
@@ -1535,34 +1545,6 @@ class BaseAnimation {
     }
 }
 
-/*
-  Progress within given range
-
-  Given a lower limit and an upper limit, we return the progress
-  (expressed as a number 0-1) represented by the given value, and
-  limit that progress to within 0-1.
-
-  @param [number]: Lower limit
-  @param [number]: Upper limit
-  @param [number]: Value to find progress within given range
-  @return [number]: Progress of value within range as expressed 0-1
-*/
-const progress = (from, to, value) => {
-    const toFromDifference = to - from;
-    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
-};
-
-const generateLinearEasing = (easing, duration, // as milliseconds
-resolution = 10 // as milliseconds
-) => {
-    let points = "";
-    const numPoints = Math.max(Math.round(duration / resolution), 2);
-    for (let i = 0; i < numPoints; i++) {
-        points += easing(progress(0, numPoints - 1, i)) + ", ";
-    }
-    return `linear(${points.substring(0, points.length - 2)})`;
-};
-
 /*
   Convert velocity into velocity per second
 
@@ -1579,43 +1561,21 @@ function calcGeneratorVelocity(resolveValue, t, current) {
     return velocityPerSecond(current - resolveValue(prevT), t - prevT);
 }
 
-const springDefaults = {
-    // Default spring physics
-    stiffness: 100,
-    damping: 10,
-    mass: 1.0,
-    velocity: 0.0,
-    // Default duration/bounce-based options
-    duration: 800, // in ms
-    bounce: 0.3,
-    visualDuration: 0.3, // in seconds
-    // Rest thresholds
-    restSpeed: {
-        granular: 0.01,
-        default: 2,
-    },
-    restDelta: {
-        granular: 0.005,
-        default: 0.5,
-    },
-    // Limits
-    minDuration: 0.01, // in seconds
-    maxDuration: 10.0, // in seconds
-    minDamping: 0.05,
-    maxDamping: 1,
-};
-
 const safeMin = 0.001;
-function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {
+const minDuration = 0.01;
+const maxDuration$1 = 10.0;
+const minDamping = 0.05;
+const maxDamping = 1;
+function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {
     let envelope;
     let derivative;
-    motionUtils.warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
+    exports.warning(duration <= secondsToMilliseconds(maxDuration$1), "Spring duration must be 10 seconds or less");
     let dampingRatio = 1 - bounce;
     /**
      * Restrict dampingRatio and duration to within acceptable ranges.
      */
-    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
-    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
+    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
+    duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));
     if (dampingRatio < 1) {
         /**
          * Underdamped spring
@@ -1659,8 +1619,8 @@ function findSpring({ duration = springDefaults.duration, bounce = springDefault
     duration = secondsToMilliseconds(duration);
     if (isNaN(undampedFreq)) {
         return {
-            stiffness: springDefaults.stiffness,
-            damping: springDefaults.damping,
+            stiffness: 100,
+            damping: 10,
             duration,
         };
     }
@@ -1685,22 +1645,6 @@ function calcAngularFreq(undampedFreq, dampingRatio) {
     return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
 }
 
-/**
- * Implement a practical max duration for keyframe generation
- * to prevent infinite loops
- */
-const maxGeneratorDuration = 20000;
-function calcGeneratorDuration(generator) {
-    let duration = 0;
-    const timeStep = 50;
-    let state = generator.next(duration);
-    while (!state.done && duration < maxGeneratorDuration) {
-        duration += timeStep;
-        state = generator.next(duration);
-    }
-    return duration >= maxGeneratorDuration ? Infinity : duration;
-}
-
 const durationKeys = ["duration", "bounce"];
 const physicsKeys = ["stiffness", "damping", "mass"];
 function isSpringType(options, keys) {
@@ -1708,51 +1652,29 @@ function isSpringType(options, keys) {
 }
 function getSpringOptions(options) {
     let springOptions = {
-        velocity: springDefaults.velocity,
-        stiffness: springDefaults.stiffness,
-        damping: springDefaults.damping,
-        mass: springDefaults.mass,
+        velocity: 0.0,
+        stiffness: 100,
+        damping: 10,
+        mass: 1.0,
         isResolvedFromDuration: false,
         ...options,
     };
     // stiffness/damping/mass overrides duration/bounce
     if (!isSpringType(options, physicsKeys) &&
         isSpringType(options, durationKeys)) {
-        if (options.visualDuration) {
-            const visualDuration = options.visualDuration;
-            const root = (2 * Math.PI) / (visualDuration * 1.2);
-            const stiffness = root * root;
-            const damping = 2 * clamp(0.05, 1, 1 - options.bounce) * Math.sqrt(stiffness);
-            springOptions = {
-                ...springOptions,
-                mass: springDefaults.mass,
-                stiffness,
-                damping,
-            };
-        }
-        else {
-            const derived = findSpring(options);
-            springOptions = {
-                ...springOptions,
-                ...derived,
-                mass: springDefaults.mass,
-            };
-            springOptions.isResolvedFromDuration = true;
-        }
+        const derived = findSpring(options);
+        springOptions = {
+            ...springOptions,
+            ...derived,
+            mass: 1.0,
+        };
+        springOptions.isResolvedFromDuration = true;
     }
     return springOptions;
 }
-function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
-    const options = typeof optionsOrVisualDuration !== "object"
-        ? {
-            visualDuration: optionsOrVisualDuration,
-            keyframes: [0, 1],
-            bounce,
-        }
-        : optionsOrVisualDuration;
-    let { restSpeed, restDelta } = options;
-    const origin = options.keyframes[0];
-    const target = options.keyframes[options.keyframes.length - 1];
+function spring({ keyframes, restDelta, restSpeed, ...options }) {
+    const origin = keyframes[0];
+    const target = keyframes[keyframes.length - 1];
     /**
      * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
      * to reduce GC during animation.
@@ -1774,12 +1696,8 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
      * ratio between feeling good and finishing as soon as changes are imperceptible.
      */
     const isGranularScale = Math.abs(initialDelta) < 5;
-    restSpeed || (restSpeed = isGranularScale
-        ? springDefaults.restSpeed.granular
-        : springDefaults.restSpeed.default);
-    restDelta || (restDelta = isGranularScale
-        ? springDefaults.restDelta.granular
-        : springDefaults.restDelta.default);
+    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
+    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);
     let resolveSpring;
     if (dampingRatio < 1) {
         const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
@@ -1820,7 +1738,7 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
                     dampedAngularFreq);
         };
     }
-    const generator = {
+    return {
         calculatedDuration: isResolvedFromDuration ? duration || null : null,
         next: (t) => {
             const current = resolveSpring(t);
@@ -1848,13 +1766,7 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
             state.value = state.done ? target : current;
             return state;
         },
-        toString: () => {
-            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
-            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);
-            return calculatedDuration + "ms " + easing;
-        },
     };
-    return generator;
 }
 
 function inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {
@@ -1951,7 +1863,7 @@ const isEasingArray = (ease) => {
 const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
 
 const easingLookup = {
-    linear: motionUtils.noop,
+    linear: noop,
     easeIn,
     easeInOut,
     easeOut,
@@ -1966,13 +1878,13 @@ const easingLookup = {
 const easingDefinitionToFunction = (definition) => {
     if (isBezierDefinition(definition)) {
         // If cubic bezier definition, create bezier curve
-        motionUtils.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
+        exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
         const [x1, y1, x2, y2] = definition;
         return cubicBezier(x1, y1, x2, y2);
     }
     else if (typeof definition === "string") {
         // Else lookup from table
-        motionUtils.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);
+        exports.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);
         return easingLookup[definition];
     }
     return definition;
@@ -1988,6 +1900,23 @@ const easingDefinitionToFunction = (definition) => {
 const combineFunctions = (a, b) => (v) => b(a(v));
 const pipe = (...transformers) => transformers.reduce(combineFunctions);
 
+/*
+  Progress within given range
+
+  Given a lower limit and an upper limit, we return the progress
+  (expressed as a number 0-1) represented by the given value, and
+  limit that progress to within 0-1.
+
+  @param [number]: Lower limit
+  @param [number]: Upper limit
+  @param [number]: Value to find progress within given range
+  @return [number]: Progress of value within range as expressed 0-1
+*/
+const progress = (from, to, value) => {
+    const toFromDifference = to - from;
+    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
+};
+
 /*
   Value in range from progress
 
@@ -2070,12 +1999,12 @@ const colorTypes = [hex, rgba, hsla];
 const getColorType = (v) => colorTypes.find((type) => type.test(v));
 function asRGBA(color) {
     const type = getColorType(color);
-    motionUtils.warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);
+    exports.warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);
     if (!Boolean(type))
         return false;
     let model = type.parse(color);
     if (type === hsla) {
-        // TODO Remove this cast - needed since Motion's stricter typing
+        // TODO Remove this cast - needed since Framer Motion's stricter typing
         model = hslaToRgba(model);
     }
     return model;
@@ -2189,7 +2118,7 @@ const mixComplex = (origin, target) => {
         return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
     }
     else {
-        motionUtils.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
+        exports.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
         return mixImmediate(origin, target);
     }
 };
@@ -2211,7 +2140,7 @@ function createMixers(output, ease, customMixer) {
     for (let i = 0; i < numMixers; i++) {
         let mixer = mixerFactory(output[i], output[i + 1]);
         if (ease) {
-            const easingFunction = Array.isArray(ease) ? ease[i] || motionUtils.noop : ease;
+            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;
             mixer = pipe(easingFunction, mixer);
         }
         mixers.push(mixer);
@@ -2239,7 +2168,7 @@ function createMixers(output, ease, customMixer) {
  */
 function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
     const inputLength = input.length;
-    motionUtils.invariant(inputLength === output.length, "Both input and output ranges must be the same length");
+    exports.invariant(inputLength === output.length, "Both input and output ranges must be the same length");
     /**
      * If we're only provided a single input, we can just make a function
      * that returns the output.
@@ -2332,6 +2261,22 @@ function keyframes({ duration = 300, keyframes: keyframeValues, times, ease = "e
     };
 }
 
+/**
+ * Implement a practical max duration for keyframe generation
+ * to prevent infinite loops
+ */
+const maxGeneratorDuration = 20000;
+function calcGeneratorDuration(generator) {
+    let duration = 0;
+    const timeStep = 50;
+    let state = generator.next(duration);
+    while (!state.done && duration < maxGeneratorDuration) {
+        duration += timeStep;
+        state = generator.next(duration);
+    }
+    return duration >= maxGeneratorDuration ? Infinity : duration;
+}
+
 const frameloopDriver = (update) => {
     const passTimestamp = ({ timestamp }) => update(timestamp);
     return {
@@ -2407,13 +2352,6 @@ class MainThreadAnimation extends BaseAnimation {
         this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);
         this.resolver.scheduleResolve();
     }
-    flatten() {
-        super.flatten();
-        // If we've already resolved the animation, re-initialise it
-        if (this._resolved) {
-            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
-        }
-    }
     initPlayback(keyframes$1) {
         const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;
         const generatorFactory = isGenerator(type)
@@ -2430,7 +2368,7 @@ class MainThreadAnimation extends BaseAnimation {
         if (generatorFactory !== keyframes &&
             typeof keyframes$1[0] !== "number") {
             if (process.env.NODE_ENV !== "production") {
-                motionUtils.invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
+                exports.invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
             }
             mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
             keyframes$1 = [0, 100];
@@ -2733,6 +2671,18 @@ const acceleratedValues = new Set([
     // "background-color"
 ]);
 
+// Create a linear easing point for every 10 ms
+const resolution = 10;
+const generateLinearEasing = (easing, duration // as milliseconds
+) => {
+    let points = "";
+    const numPoints = Math.max(Math.round(duration / resolution), 2);
+    for (let i = 0; i < numPoints; i++) {
+        points += easing(progress(0, numPoints - 1, i)) + ", ";
+    }
+    return `linear(${points.substring(0, points.length - 2)})`;
+};
+
 function memo(callback) {
     let result;
     return () => {
@@ -2806,7 +2756,7 @@ function mapEasingToNativeEasing(easing, duration) {
     }
 }
 
-function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeInOut", times, } = {}) {
+function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease, times, } = {}) {
     const keyframeOptions = { [valueName]: keyframes };
     if (times)
         keyframeOptions.offset = times;
@@ -3035,11 +2985,11 @@ class AcceleratedAnimation extends BaseAnimation {
         else {
             const { resolved } = this;
             if (!resolved)
-                return motionUtils.noop;
+                return noop;
             const { animation } = resolved;
             attachTimeline(animation, timeline);
         }
-        return motionUtils.noop;
+        return noop;
     }
     play() {
         if (this.isStopped)
@@ -3196,9 +3146,6 @@ class GroupPlaybackControls {
     runAll(methodName) {
         this.animations.forEach((controls) => controls[methodName]());
     }
-    flatten() {
-        this.runAll("flatten");
-    }
     play() {
         this.runAll("play");
     }
@@ -3417,7 +3364,7 @@ class MotionValue {
          * This will be replaced by the build step with the latest version number.
          * When MotionValues are provided to motion components, warn if versions are mixed.
          */
-        this.version = "11.15.0";
+        this.version = "11.11.10";
         /**
          * Tracks whether this value can output a velocity. Currently this is only true
          * if the value is numerical, but we might be able to widen the scope here and support
@@ -4326,16 +4273,33 @@ const animations = {
     },
 };
 
-function extractEventInfo(event) {
+const isPrimaryPointer = (event) => {
+    if (event.pointerType === "mouse") {
+        return typeof event.button !== "number" || event.button <= 0;
+    }
+    else {
+        /**
+         * isPrimary is true for all mice buttons, whereas every touch point
+         * is regarded as its own input. So subsequent concurrent touch points
+         * will be false.
+         *
+         * Specifically match against false here as incomplete versions of
+         * PointerEvents in very old browser might have it set as undefined.
+         */
+        return event.isPrimary !== false;
+    }
+};
+
+function extractEventInfo(event, pointType = "page") {
     return {
         point: {
-            x: event.pageX,
-            y: event.pageY,
+            x: event[`${pointType}X`],
+            y: event[`${pointType}Y`],
         },
     };
 }
 const addPointerInfo = (handler) => {
-    return (event) => motionDom.isPrimaryPointer(event) && handler(event, extractEventInfo(event));
+    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
 };
 
 function addDomEvent(target, eventName, handler, options = { passive: true }) {
@@ -4359,7 +4323,7 @@ function distance2D(a, b) {
  * @internal
  */
 class PanSession {
-    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {
+    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
         /**
          * @internal
          */
@@ -4423,7 +4387,7 @@ class PanSession {
             onSessionEnd && onSessionEnd(event, panInfo);
         };
         // If we have more than one touch, don't start detecting this gesture
-        if (!motionDom.isPrimaryPointer(event))
+        if (!isPrimaryPointer(event))
             return;
         this.dragSnapToOrigin = dragSnapToOrigin;
         this.handlers = handlers;
@@ -4502,6 +4466,58 @@ function getVelocity(history, timeDelta) {
     return currentVelocity;
 }
 
+function createLock(name) {
+    let lock = null;
+    return () => {
+        const openLock = () => {
+            lock = null;
+        };
+        if (lock === null) {
+            lock = name;
+            return openLock;
+        }
+        return false;
+    };
+}
+const globalHorizontalLock = createLock("dragHorizontal");
+const globalVerticalLock = createLock("dragVertical");
+function getGlobalLock(drag) {
+    let lock = false;
+    if (drag === "y") {
+        lock = globalVerticalLock();
+    }
+    else if (drag === "x") {
+        lock = globalHorizontalLock();
+    }
+    else {
+        const openHorizontal = globalHorizontalLock();
+        const openVertical = globalVerticalLock();
+        if (openHorizontal && openVertical) {
+            lock = () => {
+                openHorizontal();
+                openVertical();
+            };
+        }
+        else {
+            // Release the locks because we don't use them
+            if (openHorizontal)
+                openHorizontal();
+            if (openVertical)
+                openVertical();
+        }
+    }
+    return lock;
+}
+function isDragActive() {
+    // Check the gesture lock - if we get it, it means no drag gesture is active
+    // and we can safely fire the tap gesture.
+    const openGestureLock = getGlobalLock(true);
+    if (!openGestureLock)
+        return true;
+    openGestureLock();
+    return false;
+}
+
 function isRefObject(ref) {
     return (ref &&
         typeof ref === "object" &&
@@ -4885,7 +4901,7 @@ function measurePageBox(element, rootProjectionNode, transformPagePoint) {
     return viewportBox;
 }
 
-// Fixes https://github.com/motiondivision/motion/issues/2270
+// Fixes https://github.com/framer/motion/issues/2270
 const getContextWindow = ({ current }) => {
     return current ? current.ownerDocument.defaultView : null;
 };
@@ -4897,7 +4913,10 @@ const elementDragControls = new WeakMap();
 // let latestPointerEvent: PointerEvent
 class VisualElementDragControls {
     constructor(visualElement) {
-        this.openDragLock = null;
+        // This is a reference to the global drag gesture lock, ensuring only one component
+        // can "capture" the drag of one or both axes.
+        // TODO: Look into moving this into pansession?
+        this.openGlobalLock = null;
         this.isDragging = false;
         this.currentDirection = null;
         this.originPoint = { x: 0, y: 0 };
@@ -4925,18 +4944,18 @@ class VisualElementDragControls {
             // the component.
             dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();
             if (snapToCursor) {
-                this.snapToCursor(extractEventInfo(event).point);
+                this.snapToCursor(extractEventInfo(event, "page").point);
             }
         };
         const onStart = (event, info) => {
             // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
             const { drag, dragPropagation, onDragStart } = this.getProps();
             if (drag && !dragPropagation) {
-                if (this.openDragLock)
-                    this.openDragLock();
-                this.openDragLock = motionDom.setDragLock(drag);
+                if (this.openGlobalLock)
+                    this.openGlobalLock();
+                this.openGlobalLock = getGlobalLock(drag);
                 // If we don 't have the lock, don't start dragging
-                if (!this.openDragLock)
+                if (!this.openGlobalLock)
                     return;
             }
             this.isDragging = true;
@@ -4978,7 +4997,7 @@ class VisualElementDragControls {
             // latestPointerEvent = event
             const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();
             // If we didn't successfully receive the gesture lock, early return.
-            if (!dragPropagation && !this.openDragLock)
+            if (!dragPropagation && !this.openGlobalLock)
                 return;
             const { offset } = info;
             // Attempt to detect drag direction if directionLock is true
@@ -5046,9 +5065,9 @@ class VisualElementDragControls {
         this.panSession && this.panSession.end();
         this.panSession = undefined;
         const { dragPropagation } = this.getProps();
-        if (!dragPropagation && this.openDragLock) {
-            this.openDragLock();
-            this.openDragLock = null;
+        if (!dragPropagation && this.openGlobalLock) {
+            this.openGlobalLock();
+            this.openGlobalLock = null;
         }
         animationState && animationState.setActive("whileDrag", false);
     }
@@ -5108,7 +5127,7 @@ class VisualElementDragControls {
         if (!constraints || !isRefObject(constraints))
             return false;
         const constraintsElement = constraints.current;
-        motionUtils.invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
+        exports.invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
         const { projection } = this.visualElement;
         // TODO
         if (!projection || !projection.layout)
@@ -5356,8 +5375,8 @@ function getCurrentDirection(offset, lockThreshold = 10) {
 class DragGesture extends Feature {
     constructor(node) {
         super(node);
-        this.removeGroupControls = motionUtils.noop;
-        this.removeListeners = motionUtils.noop;
+        this.removeGroupControls = noop;
+        this.removeListeners = noop;
         this.controls = new VisualElementDragControls(node);
     }
     mount() {
@@ -5367,7 +5386,7 @@ class DragGesture extends Feature {
         if (dragControls) {
             this.removeGroupControls = dragControls.subscribe(this.controls);
         }
-        this.removeListeners = this.controls.addListeners() || motionUtils.noop;
+        this.removeListeners = this.controls.addListeners() || noop;
     }
     unmount() {
         this.removeGroupControls();
@@ -5383,7 +5402,7 @@ const asyncHandler = (handler) => (event, info) => {
 class PanGesture extends Feature {
     constructor() {
         super(...arguments);
-        this.removePointerDownListener = motionUtils.noop;
+        this.removePointerDownListener = noop;
     }
     onPointerDown(pointerDownEvent) {
         this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
@@ -5491,7 +5510,7 @@ function getRadius(values, radiusName) {
 //     )(p)
 // }
 const easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);
-const easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, motionUtils.noop);
+const easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);
 function compress(min, max, easing) {
     return (p) => {
         // Could replace ifs with clamp
@@ -5853,13 +5872,38 @@ function createGeneratorEasing(options, scale = 100, createGenerator) {
     };
 }
 
+function resolveElements(elements, scope, selectorCache) {
+    var _a;
+    if (typeof elements === "string") {
+        let root = document;
+        if (scope) {
+            exports.invariant(Boolean(scope.current), "Scope provided, but no element detected.");
+            root = scope.current;
+        }
+        if (selectorCache) {
+            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));
+            elements = selectorCache[elements];
+        }
+        else {
+            elements = root.querySelectorAll(elements);
+        }
+    }
+    else if (elements instanceof Element) {
+        elements = [elements];
+    }
+    /**
+     * Return an empty array
+     */
+    return Array.from(elements || []);
+}
+
 function isDOMKeyframes(keyframes) {
     return typeof keyframes === "object" && !Array.isArray(keyframes);
 }
 
 function resolveSubjects(subject, keyframes, scope, selectorCache) {
     if (typeof subject === "string" && isDOMKeyframes(keyframes)) {
-        return motionDom.resolveElements(subject, scope, selectorCache);
+        return resolveElements(subject, scope, selectorCache);
     }
     else if (subject instanceof NodeList) {
         return Array.from(subject);
@@ -5940,24 +5984,7 @@ function compareByTime(a, b) {
     }
 }
 
-/**
- * Take an array of times that represent repeated keyframes. For instance
- * if we have original times of [0, 0.5, 1] then our repeated times will
- * be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back
- * down to a 0-1 scale.
- */
-function normalizeTimes(times, repeat) {
-    for (let i = 0; i < times.length; i++) {
-        times[i] = times[i] / (repeat + 1);
-    }
-}
-
-function calculateRepeatDuration(duration, repeat, _repeatDelay) {
-    return duration * (repeat + 1);
-}
-
 const defaultSegmentEasing = "easeInOut";
-const MAX_REPEAT = 20;
 function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {
     const defaultDuration = defaultTransition.duration || 0.3;
     const animationDefinitions = new Map();
@@ -6000,7 +6027,7 @@ function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...seq
         let maxDuration = 0;
         const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
             const valueKeyframesAsList = keyframesAsList(valueKeyframes);
-            const { delay = 0, times = defaultOffset$1(valueKeyframesAsList), type = "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;
+            const { delay = 0, times = defaultOffset$1(valueKeyframesAsList), type = "keyframes", ...remainingTransition } = valueTransition;
             let { ease = defaultTransition.ease || "easeOut", duration } = valueTransition;
             /**
              * Resolve stagger() if defined.
@@ -6038,6 +6065,7 @@ function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...seq
             }
             duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);
             const startTime = currentTime + calculatedDelay;
+            const targetTime = startTime + duration;
             /**
              * If there's only one time offset of 0, fill in a second with length 1
              */
@@ -6056,28 +6084,6 @@ function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...seq
              */
             valueKeyframesAsList.length === 1 &&
                 valueKeyframesAsList.unshift(null);
-            /**
-             * Handle repeat options
-             */
-            if (repeat) {
-                motionUtils.invariant(repeat < MAX_REPEAT, "Repeat count too high, must be less than 20");
-                duration = calculateRepeatDuration(duration, repeat);
-                const originalKeyframes = [...valueKeyframesAsList];
-                const originalTimes = [...times];
-                ease = Array.isArray(ease) ? [...ease] : [ease];
-                const originalEase = [...ease];
-                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
-                    valueKeyframesAsList.push(...originalKeyframes);
-                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {
-                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));
-                        ease.push(keyframeIndex === 0
-                            ? "linear"
-                            : getEasingForSegment(originalEase, keyframeIndex - 1));
-                    }
-                }
-                normalizeTimes(times, repeat);
-            }
-            const targetTime = startTime + duration;
             /**
              * Add keyframes, mapping offsets to absolute time.
              */
@@ -6282,7 +6288,7 @@ function updateMotionValuesFromProps(element, next, prev) {
              * and warn against mismatches.
              */
             if (process.env.NODE_ENV === "development") {
-                warnOnce(nextValue.version === "11.15.0", `Attempting to mix Motion versions ${nextValue.version} with 11.15.0 may not work as expected.`);
+                warnOnce(nextValue.version === "11.11.10", `Attempting to mix Framer Motion versions ${nextValue.version} with 11.11.10 may not work as expected.`);
             }
         }
         else if (isMotionValue(prevValue)) {
@@ -6833,20 +6839,6 @@ class DOMVisualElement extends VisualElement {
         delete vars[key];
         delete style[key];
     }
-    handleChildMotionValue() {
-        if (this.childSubscription) {
-            this.childSubscription();
-            delete this.childSubscription;
-        }
-        const { children } = this.props;
-        if (isMotionValue(children)) {
-            this.childSubscription = children.on("change", (latest) => {
-                if (this.current) {
-                    this.current.textContent = `${latest}`;
-                }
-            });
-        }
-    }
 }
 
 /**
@@ -7174,6 +7166,19 @@ class HTMLVisualElement extends DOMVisualElement {
     scrapeMotionValuesFromProps(props, prevProps, visualElement) {
         return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
     }
+    handleChildMotionValue() {
+        if (this.childSubscription) {
+            this.childSubscription();
+            delete this.childSubscription;
+        }
+        const { children } = this.props;
+        if (isMotionValue(children)) {
+            this.childSubscription = children.on("change", (latest) => {
+                if (this.current)
+                    this.current.textContent = `${latest}`;
+            });
+        }
+    }
 }
 
 function isObjectKey(key, object) {
@@ -7274,7 +7279,7 @@ function animateSubject(subject, keyframes, options, scope) {
     else {
         const subjects = resolveSubjects(subject, keyframes, scope);
         const numSubjects = subjects.length;
-        motionUtils.invariant(Boolean(numSubjects), "No valid elements provided.");
+        exports.invariant(Boolean(numSubjects), "No valid elements provided.");
         for (let i = 0; i < numSubjects; i++) {
             const thisSubject = subjects[i];
             const createVisualElement = thisSubject instanceof Element
@@ -7380,7 +7385,7 @@ class NativeAnimation {
         this.setValue = isCSSVar ? setCSSVar : setStyle;
         this.options = options;
         this.updateFinishedPromise();
-        motionUtils.invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "framer-motion"?`);
+        exports.invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "framer-motion"?`);
         const existingAnimation = getElementAnimationState(element).get(valueName);
         existingAnimation && existingAnimation.stop();
         const readInitialKeyframe = () => {
@@ -7392,7 +7397,6 @@ class NativeAnimation {
             valueKeyframes = [valueKeyframes];
         }
         hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe);
-        // TODO: Replace this with toString()?
         if (isGenerator(options.type)) {
             const generatorOptions = createGeneratorEasing(options, 100, options.type);
             options.ease = supportsLinearEasing()
@@ -7454,12 +7458,6 @@ class NativeAnimation {
     get startTime() {
         return this.animation ? this.animation.startTime : null;
     }
-    flatten() {
-        var _a;
-        if (!this.animation)
-            return;
-        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: "linear" });
-    }
     play() {
         if (this.state === "finished") {
             this.updateFinishedPromise();
@@ -7510,14 +7508,14 @@ class NativeAnimation {
         else {
             attachTimeline(this.animation, timeline);
         }
-        return motionUtils.noop;
+        return noop;
     }
 }
 
 function animateElements(elementOrSelector, keyframes, options, scope) {
-    const elements = motionDom.resolveElements(elementOrSelector, scope);
+    const elements = resolveElements(elementOrSelector, scope);
     const numElements = elements.length;
-    motionUtils.invariant(Boolean(numElements), "No valid element provided.");
+    exports.invariant(Boolean(numElements), "No valid element provided.");
     const animations = [];
     for (let i = 0; i < numElements; i++) {
         const element = elements[i];
@@ -7531,7 +7529,7 @@ function animateElements(elementOrSelector, keyframes, options, scope) {
         for (const valueName in keyframes) {
             const valueKeyframes = keyframes[valueName];
             const valueOptions = {
-                ...getValueTransition$1(elementTransition, valueName),
+                ...getValueTransition$1(options, valueName),
             };
             valueOptions.duration = valueOptions.duration
                 ? secondsToMilliseconds(valueOptions.duration)
@@ -7591,7 +7589,7 @@ function createResizeObserver() {
 function resizeElement(target, handler) {
     if (!observer)
         createResizeObserver();
-    const elements = motionDom.resolveElements(target);
+    const elements = resolveElements(target);
     elements.forEach((element) => {
         let elementHandlers = resizeHandlers.get(element);
         if (!elementHandlers) {
@@ -8076,7 +8074,6 @@ function scrollFunction(onScroll, options) {
     }
 }
 function scrollAnimation(animation, options) {
-    animation.flatten();
     if (needsElementTracking(options)) {
         animation.pause();
         return scrollInfo((info) => {
@@ -8085,17 +8082,12 @@ function scrollAnimation(animation, options) {
     }
     else {
         const timeline = getTimeline(options);
-        if (animation.attachTimeline) {
-            return animation.attachTimeline(timeline, (valueAnimation) => {
-                valueAnimation.pause();
-                return observeTimeline((progress) => {
-                    valueAnimation.time = valueAnimation.duration * progress;
-                }, timeline);
-            });
-        }
-        else {
-            return motionUtils.noop;
-        }
+        return animation.attachTimeline(timeline, (valueAnimation) => {
+            valueAnimation.pause();
+            return observeTimeline((progress) => {
+                valueAnimation.time = valueAnimation.duration * progress;
+            }, timeline);
+        });
     }
 }
 function scroll(onScroll, { axis = "y", ...options } = {}) {
@@ -8110,7 +8102,7 @@ const thresholds = {
     all: 1,
 };
 function inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = "some" } = {}) {
-    const elements = motionDom.resolveElements(elementOrSelector);
+    const elements = resolveElements(elementOrSelector);
     const activeIntersections = new WeakMap();
     const onIntersectionChange = (entries) => {
         entries.forEach((entry) => {
@@ -9750,7 +9742,7 @@ const userAgentContains = (string) => typeof navigator !== "undefined" &&
  */
 const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/")
     ? Math.round
-    : motionUtils.noop;
+    : noop;
 function roundAxis(axis) {
     // Round to the nearest .5 pixels to support subpixel layouts
     axis.min = roundPoint(axis.min);
@@ -10099,26 +10091,28 @@ const drag = {
     },
 };
 
-function handleHoverEvent(node, event, lifecycle) {
-    const { props } = node;
-    if (node.animationState && props.whileHover) {
-        node.animationState.setActive("whileHover", lifecycle === "Start");
-    }
-    const eventName = ("onHover" + lifecycle);
-    const callback = props[eventName];
-    if (callback) {
-        frame.postRender(() => callback(event, extractEventInfo(event)));
-    }
+function addHoverEvent(node, isActive) {
+    const eventName = isActive ? "pointerenter" : "pointerleave";
+    const callbackName = isActive ? "onHoverStart" : "onHoverEnd";
+    const handleEvent = (event, info) => {
+        if (event.pointerType === "touch" || isDragActive())
+            return;
+        const props = node.getProps();
+        if (node.animationState && props.whileHover) {
+            node.animationState.setActive("whileHover", isActive);
+        }
+        const callback = props[callbackName];
+        if (callback) {
+            frame.postRender(() => callback(event, info));
+        }
+    };
+    return addPointerEvent(node.current, eventName, handleEvent, {
+        passive: !node.getProps()[callbackName],
+    });
 }
 class HoverGesture extends Feature {
     mount() {
-        const { current } = this.node;
-        if (!current)
-            return;
-        this.unmount = motionDom.hover(current, (startEvent) => {
-            handleHoverEvent(this.node, startEvent, "Start");
-            return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
-        });
+        this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
     }
     unmount() { }
 }
@@ -10159,28 +10153,142 @@ class FocusGesture extends Feature {
     unmount() { }
 }
 
-function handlePressEvent(node, event, lifecycle) {
-    const { props } = node;
-    if (node.animationState && props.whileTap) {
-        node.animationState.setActive("whileTap", lifecycle === "Start");
+/**
+ * Recursively traverse up the tree to check whether the provided child node
+ * is the parent or a descendant of it.
+ *
+ * @param parent - Element to find
+ * @param child - Element to test against parent
+ */
+const isNodeOrChild = (parent, child) => {
+    if (!child) {
+        return false;
+    }
+    else if (parent === child) {
+        return true;
     }
-    const eventName = ("onTap" + (lifecycle === "End" ? "" : lifecycle));
-    const callback = props[eventName];
-    if (callback) {
-        frame.postRender(() => callback(event, extractEventInfo(event)));
+    else {
+        return isNodeOrChild(parent, child.parentElement);
     }
+};
+
+function fireSyntheticPointerEvent(name, handler) {
+    if (!handler)
+        return;
+    const syntheticPointerEvent = new PointerEvent("pointer" + name);
+    handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
 }
 class PressGesture extends Feature {
-    mount() {
-        const { current } = this.node;
-        if (!current)
+    constructor() {
+        super(...arguments);
+        this.removeStartListeners = noop;
+        this.removeEndListeners = noop;
+        this.removeAccessibleListeners = noop;
+        this.startPointerPress = (startEvent, startInfo) => {
+            if (this.isPressing)
+                return;
+            this.removeEndListeners();
+            const props = this.node.getProps();
+            const endPointerPress = (endEvent, endInfo) => {
+                if (!this.checkPressEnd())
+                    return;
+                const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
+                /**
+                 * We only count this as a tap gesture if the event.target is the same
+                 * as, or a child of, this component's element
+                 */
+                const handler = !globalTapTarget &&
+                    !isNodeOrChild(this.node.current, endEvent.target)
+                    ? onTapCancel
+                    : onTap;
+                if (handler) {
+                    frame.update(() => handler(endEvent, endInfo));
+                }
+            };
+            const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, {
+                passive: !(props.onTap || props["onPointerUp"]),
+            });
+            const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), {
+                passive: !(props.onTapCancel ||
+                    props["onPointerCancel"]),
+            });
+            this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
+            this.startPress(startEvent, startInfo);
+        };
+        this.startAccessiblePress = () => {
+            const handleKeydown = (keydownEvent) => {
+                if (keydownEvent.key !== "Enter" || this.isPressing)
+                    return;
+                const handleKeyup = (keyupEvent) => {
+                    if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
+                        return;
+                    fireSyntheticPointerEvent("up", (event, info) => {
+                        const { onTap } = this.node.getProps();
+                        if (onTap) {
+                            frame.postRender(() => onTap(event, info));
+                        }
+                    });
+                };
+                this.removeEndListeners();
+                this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
+                fireSyntheticPointerEvent("down", (event, info) => {
+                    this.startPress(event, info);
+                });
+            };
+            const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
+            const handleBlur = () => {
+                if (!this.isPressing)
+                    return;
+                fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
+            };
+            const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
+            this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
+        };
+    }
+    startPress(event, info) {
+        this.isPressing = true;
+        const { onTapStart, whileTap } = this.node.getProps();
+        /**
+         * Ensure we trigger animations before firing event callback
+         */
+        if (whileTap && this.node.animationState) {
+            this.node.animationState.setActive("whileTap", true);
+        }
+        if (onTapStart) {
+            frame.postRender(() => onTapStart(event, info));
+        }
+    }
+    checkPressEnd() {
+        this.removeEndListeners();
+        this.isPressing = false;
+        const props = this.node.getProps();
+        if (props.whileTap && this.node.animationState) {
+            this.node.animationState.setActive("whileTap", false);
+        }
+        return !isDragActive();
+    }
+    cancelPress(event, info) {
+        if (!this.checkPressEnd())
             return;
-        this.unmount = motionDom.press(current, (startEvent) => {
-            handlePressEvent(this.node, startEvent, "Start");
-            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
-        }, { useGlobalTarget: this.node.props.globalTapTarget });
+        const { onTapCancel } = this.node.getProps();
+        if (onTapCancel) {
+            frame.postRender(() => onTapCancel(event, info));
+        }
+    }
+    mount() {
+        const props = this.node.getProps();
+        const removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
+            passive: !(props.onTapStart ||
+                props["onPointerStart"]),
+        });
+        const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
+        this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
+    }
+    unmount() {
+        this.removeStartListeners();
+        this.removeEndListeners();
+        this.removeAccessibleListeners();
     }
-    unmount() { }
 }
 
 /**
@@ -10342,7 +10450,7 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
     const lazyContext = React.useContext(LazyContext);
     const presenceContext = React.useContext(PresenceContext);
     const reducedMotionConfig = React.useContext(MotionConfigContext).reducedMotion;
-    const visualElementRef = React.useRef(null);
+    const visualElementRef = React.useRef();
     /**
      * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
      */
@@ -10371,15 +10479,8 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
         (visualElement.type === "html" || visualElement.type === "svg")) {
         createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
     }
-    const isMounted = React.useRef(false);
     React.useInsertionEffect(() => {
-        /**
-         * Check the component has already mounted before calling
-         * `update` unnecessarily. This ensures we skip the initial update.
-         */
-        if (visualElement && isMounted.current) {
-            visualElement.update(props, presenceContext);
-        }
+        visualElement && visualElement.update(props, presenceContext);
     });
     /**
      * Cache this value as we want to know whether HandoffAppearAnimations
@@ -10392,7 +10493,6 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
     useIsomorphicLayoutEffect(() => {
         if (!visualElement)
             return;
-        isMounted.current = true;
         window.MotionIsMounted = true;
         visualElement.updateFeatures();
         microtask.render(visualElement.render);
@@ -10586,8 +10686,8 @@ function useStrictMode(configAndProps, preloadedFeatures) {
         isStrict) {
         const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
         configAndProps.ignoreStrict
-            ? motionUtils.warning(false, strictMessage)
-            : motionUtils.invariant(false, strictMessage);
+            ? exports.warning(false, strictMessage)
+            : exports.invariant(false, strictMessage);
     }
 }
 function getProjectionFunctionality(props) {
@@ -11065,7 +11165,7 @@ class PopChildMeasure extends React__namespace.Component {
         return this.props.children;
     }
 }
-function PopChild({ children, isPresent }) {
+function PopChild({ children, isPresent, parentDom }) {
     const id = React.useId();
     const ref = React.useRef(null);
     const size = React.useRef({
@@ -11092,7 +11192,8 @@ function PopChild({ children, isPresent }) {
         const style = document.createElement("style");
         if (nonce)
             style.nonce = nonce;
-        document.head.appendChild(style);
+        const parent = parentDom !== null && parentDom !== void 0 ? parentDom : document.head;
+        parent.appendChild(style);
         if (style.sheet) {
             style.sheet.insertRule(`
           [data-motion-pop-id="${id}"] {
@@ -11105,13 +11206,13 @@ function PopChild({ children, isPresent }) {
         `);
         }
         return () => {
-            document.head.removeChild(style);
+            parent.removeChild(style);
         };
     }, [isPresent]);
     return (jsxRuntime.jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React__namespace.cloneElement(children, { ref }) }));
 }
 
-const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, }) => {
+const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, parentDom }) => {
     const presenceChildren = useConstant(newChildrenMap);
     const id = React.useId();
     const memoizedOnExitComplete = React.useCallback((childId) => {
@@ -11155,7 +11256,7 @@ const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, p
             onExitComplete();
     }, [isPresent]);
     if (mode === "popLayout") {
-        children = jsxRuntime.jsx(PopChild, { isPresent: isPresent, children: children });
+        children = jsxRuntime.jsx(PopChild, { isPresent: isPresent, parentDom: parentDom, children: children });
     }
     return (jsxRuntime.jsx(PresenceContext.Provider, { value: context, children: children }));
 };
@@ -11236,8 +11337,8 @@ function onlyElements(children) {
  *
  * @public
  */
-const AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", }) => {
-    motionUtils.invariant(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
+const AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", parentDom, }) => {
+    exports.invariant(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
     /**
      * Filter any children that aren't ReactElements. We can only track components
      * between renders with a props.key.
@@ -11351,7 +11452,7 @@ const AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, on
             };
             return (jsxRuntime.jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial
                     ? undefined
-                    : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, children: child }, key));
+                    : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, parentDom: parentDom, onExitComplete: isPresent ? undefined : onExit, children: child }, key));
         }) }));
 };
 
@@ -11512,7 +11613,7 @@ function ReorderGroupComponent({ children, as = "ul", axis = "y", onReorder, val
     const Component = useConstant(() => motion[as]);
     const order = [];
     const isReordering = React.useRef(false);
-    motionUtils.invariant(Boolean(values), "Reorder.Group must be provided a values prop");
+    exports.invariant(Boolean(values), "Reorder.Group must be provided a values prop");
     const context = {
         axis,
         registerItem: (value, layout) => {
@@ -11664,7 +11765,7 @@ function ReorderItemComponent({ children, style = {}, value, as = "li", onDrag,
         y: useDefaultMotionValue(style.y),
     };
     const zIndex = useTransform([point.x, point.y], ([latestX, latestY]) => latestX || latestY ? 1 : "unset");
-    motionUtils.invariant(Boolean(context), "Reorder.Item must be a child of Reorder.Group");
+    exports.invariant(Boolean(context), "Reorder.Item must be a child of Reorder.Group");
     const { axis, registerItem, updateOrder } = context;
     return (jsxRuntime.jsx(Component, { drag: axis, ...props, dragSnapToOrigin: true, style: { ...style, x: point.x, y: point.y, zIndex }, layout: layout, onDrag: (event, gesturePoint) => {
             const { velocity } = gesturePoint;
@@ -11865,7 +11966,7 @@ function useVelocity(value) {
 }
 
 function refWarning(name, ref) {
-    motionUtils.warning(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`);
+    exports.warning(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`);
 }
 const createScrollMotionValues = () => ({
     scrollX: motionValue(0),
@@ -12066,7 +12167,7 @@ function animationControls() {
             return () => void subscribers.delete(visualElement);
         },
         start(definition, transitionOverride) {
-            motionUtils.invariant(hasMounted, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
+            exports.invariant(hasMounted, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
             const animations = [];
             subscribers.forEach((visualElement) => {
                 animations.push(animateVisualElement(visualElement, definition, {
@@ -12076,7 +12177,7 @@ function animationControls() {
             return Promise.all(animations);
         },
         set(definition) {
-            motionUtils.invariant(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
+            exports.invariant(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
             return subscribers.forEach((visualElement) => {
                 setValues(visualElement, definition);
             });
@@ -12370,7 +12471,7 @@ function startTransition(callback) {
 function useInstantTransition() {
     const [forceUpdate, forcedRenderCount] = useForceUpdate();
     const startInstantLayoutTransition = useInstantLayoutTransition();
-    const unlockOnFrameRef = React.useRef(-1);
+    const unlockOnFrameRef = React.useRef();
     React.useEffect(() => {
         /**
          * Unblock after two animation frames, otherwise this will unblock too soon.
@@ -12612,7 +12713,7 @@ function startOptimizedAppearAnimation(element, name, keyframes, options, onRead
     };
     appearComplete.set(id, false);
     if (readyAnimation.ready) {
-        readyAnimation.ready.then(startAnimation).catch(motionUtils.noop);
+        readyAnimation.ready.then(startAnimation).catch(noop);
     }
     else {
         startAnimation();
@@ -12704,8 +12805,8 @@ function useInvertedScale(scale) {
     let parentScaleX = useMotionValue(1);
     let parentScaleY = useMotionValue(1);
     const { visualElement } = React.useContext(MotionContext);
-    motionUtils.invariant(!!(scale || visualElement), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
-    motionUtils.warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
+    exports.invariant(!!(scale || visualElement), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
+    exports.warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
     hasWarned = true;
     if (scale) {
         parentScaleX = scale.scaleX || parentScaleX;
@@ -12723,23 +12824,11 @@ function useInvertedScale(scale) {
 let id = 0;
 const AnimateSharedLayout = ({ children }) => {
     React__namespace.useEffect(() => {
-        motionUtils.invariant(false, "AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations");
+        exports.invariant(false, "AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations");
     }, []);
     return (jsxRuntime.jsx(LayoutGroup, { id: useConstant(() => `asl-${id++}`), children: children }));
 };
 
-Object.defineProperty(exports, "invariant", {
-    enumerable: true,
-    get: function () { return motionUtils.invariant; }
-});
-Object.defineProperty(exports, "noop", {
-    enumerable: true,
-    get: function () { return motionUtils.noop; }
-});
-Object.defineProperty(exports, "isDragActive", {
-    enumerable: true,
-    get: function () { return motionDom.isDragActive; }
-});
 exports.AcceleratedAnimation = AcceleratedAnimation;
 exports.AnimatePresence = AnimatePresence;
 exports.AnimateSharedLayout = AnimateSharedLayout;
@@ -12804,6 +12893,7 @@ exports.inView = inView;
 exports.inertia = inertia;
 exports.interpolate = interpolate;
 exports.isBrowser = isBrowser;
+exports.isDragActive = isDragActive;
 exports.isMotionComponent = isMotionComponent;
 exports.isMotionValue = isMotionValue;
 exports.isValidMotionProp = isValidMotionProp;
@@ -12827,7 +12917,6 @@ exports.stagger = stagger;
 exports.startOptimizedAppearAnimation = startOptimizedAppearAnimation;
 exports.steps = steps;
 exports.sync = sync;
-exports.time = time;
 exports.transform = transform;
 exports.unwrapMotionComponent = unwrapMotionComponent;
 exports.useAnimate = useAnimate;
diff --git a/dist/cjs/m.js b/dist/cjs/m.js
index cb9c34b5a4ec03d86e17ee84b262b86829e59cf7..82f24b2508c7dc81ce157f7174f27dcb62c914ce 100644
--- a/dist/cjs/m.js
+++ b/dist/cjs/m.js
@@ -4,7 +4,6 @@ Object.defineProperty(exports, '__esModule', { value: true });
 
 var jsxRuntime = require('react/jsx-runtime');
 var react = require('react');
-var motionUtils = require('motion-utils');
 
 /**
  * @public
@@ -101,11 +100,10 @@ function createRenderStep(runNextFrame) {
             }
             isProcessing = true;
             [thisFrame, nextFrame] = [nextFrame, thisFrame];
+            // Clear the next frame queue
+            nextFrame.clear();
             // Execute this frame
             thisFrame.forEach(triggerCallback);
-            // Clear the frame so no callbacks remain. This is to avoid
-            // memory leaks should this render step not run for a while.
-            thisFrame.clear();
             isProcessing = false;
             if (flushNextFrame) {
                 flushNextFrame = false;
@@ -203,7 +201,7 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
     const lazyContext = react.useContext(LazyContext);
     const presenceContext = react.useContext(PresenceContext);
     const reducedMotionConfig = react.useContext(MotionConfigContext).reducedMotion;
-    const visualElementRef = react.useRef(null);
+    const visualElementRef = react.useRef();
     /**
      * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
      */
@@ -232,15 +230,8 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
         (visualElement.type === "html" || visualElement.type === "svg")) {
         createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
     }
-    const isMounted = react.useRef(false);
     react.useInsertionEffect(() => {
-        /**
-         * Check the component has already mounted before calling
-         * `update` unnecessarily. This ensures we skip the initial update.
-         */
-        if (visualElement && isMounted.current) {
-            visualElement.update(props, presenceContext);
-        }
+        visualElement && visualElement.update(props, presenceContext);
     });
     /**
      * Cache this value as we want to know whether HandoffAppearAnimations
@@ -253,7 +244,6 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
     useIsomorphicLayoutEffect(() => {
         if (!visualElement)
             return;
-        isMounted.current = true;
         window.MotionIsMounted = true;
         visualElement.updateFeatures();
         microtask.render(visualElement.render);
@@ -444,6 +434,23 @@ const LayoutGroupContext = react.createContext({});
 
 const motionComponentSymbol = Symbol.for("motionComponentSymbol");
 
+const noop = (any) => any;
+
+let warning = noop;
+let invariant = noop;
+if (process.env.NODE_ENV !== "production") {
+    warning = (check, message) => {
+        if (!check && typeof console !== "undefined") {
+            console.warn(message);
+        }
+    };
+    invariant = (check, message) => {
+        if (!check) {
+            throw new Error(message);
+        }
+    };
+}
+
 /**
  * Create a `motion` component.
  *
@@ -508,8 +515,8 @@ function useStrictMode(configAndProps, preloadedFeatures) {
         isStrict) {
         const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
         configAndProps.ignoreStrict
-            ? motionUtils.warning(false, strictMessage)
-            : motionUtils.invariant(false, strictMessage);
+            ? warning(false, strictMessage)
+            : invariant(false, strictMessage);
     }
 }
 function getProjectionFunctionality(props) {
@@ -1184,7 +1191,7 @@ function buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathL
 
 const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
 
-const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : motionUtils.noop, true);
+const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);
 
 const svgMotionConfig = {
     useVisualState: makeUseVisualState({
diff --git a/dist/cjs/mini.js b/dist/cjs/mini.js
index 287e48afe8b796c1f1824a65bdc60f3b15e9522d..b6e611831bcc46838a3673dbdfdd38c589e91bf1 100644
--- a/dist/cjs/mini.js
+++ b/dist/cjs/mini.js
@@ -3,8 +3,6 @@
 Object.defineProperty(exports, '__esModule', { value: true });
 
 var react = require('react');
-var motionDom = require('motion-dom');
-var motionUtils = require('motion-utils');
 
 /**
  * Creates a constant value over the lifecycle of a component.
@@ -97,9 +95,6 @@ class GroupPlaybackControls {
     runAll(methodName) {
         this.animations.forEach((controls) => controls[methodName]());
     }
-    flatten() {
-        this.runAll("flatten");
-    }
     play() {
         this.runAll("play");
     }
@@ -114,6 +109,42 @@ class GroupPlaybackControls {
     }
 }
 
+const noop = (any) => any;
+
+let invariant = noop;
+if (process.env.NODE_ENV !== "production") {
+    invariant = (check, message) => {
+        if (!check) {
+            throw new Error(message);
+        }
+    };
+}
+
+function resolveElements(elements, scope, selectorCache) {
+    var _a;
+    if (typeof elements === "string") {
+        let root = document;
+        if (scope) {
+            invariant(Boolean(scope.current), "Scope provided, but no element detected.");
+            root = scope.current;
+        }
+        if (selectorCache) {
+            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));
+            elements = selectorCache[elements];
+        }
+        else {
+            elements = root.querySelectorAll(elements);
+        }
+    }
+    else if (elements instanceof Element) {
+        elements = [elements];
+    }
+    /**
+     * Return an empty array
+     */
+    return Array.from(elements || []);
+}
+
 /**
  * Converts seconds to milliseconds
  *
@@ -150,8 +181,9 @@ const progress = (from, to, value) => {
     return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
 };
 
-const generateLinearEasing = (easing, duration, // as milliseconds
-resolution = 10 // as milliseconds
+// Create a linear easing point for every 10 ms
+const resolution = 10;
+const generateLinearEasing = (easing, duration // as milliseconds
 ) => {
     let points = "";
     const numPoints = Math.max(Math.round(duration / resolution), 2);
@@ -217,7 +249,7 @@ function mapEasingToNativeEasing(easing, duration) {
     }
 }
 
-function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeInOut", times, } = {}) {
+function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease, times, } = {}) {
     const keyframeOptions = { [valueName]: keyframes };
     if (times)
         keyframeOptions.offset = times;
@@ -377,7 +409,7 @@ class NativeAnimation {
         this.setValue = isCSSVar ? setCSSVar : setStyle;
         this.options = options;
         this.updateFinishedPromise();
-        motionUtils.invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "framer-motion"?`);
+        invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "framer-motion"?`);
         const existingAnimation = getElementAnimationState(element).get(valueName);
         existingAnimation && existingAnimation.stop();
         const readInitialKeyframe = () => {
@@ -389,7 +421,6 @@ class NativeAnimation {
             valueKeyframes = [valueKeyframes];
         }
         hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe);
-        // TODO: Replace this with toString()?
         if (isGenerator(options.type)) {
             const generatorOptions = createGeneratorEasing(options, 100, options.type);
             options.ease = supportsLinearEasing()
@@ -451,12 +482,6 @@ class NativeAnimation {
     get startTime() {
         return this.animation ? this.animation.startTime : null;
     }
-    flatten() {
-        var _a;
-        if (!this.animation)
-            return;
-        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: "linear" });
-    }
     play() {
         if (this.state === "finished") {
             this.updateFinishedPromise();
@@ -507,14 +532,14 @@ class NativeAnimation {
         else {
             attachTimeline(this.animation, timeline);
         }
-        return motionUtils.noop;
+        return noop;
     }
 }
 
 function animateElements(elementOrSelector, keyframes, options, scope) {
-    const elements = motionDom.resolveElements(elementOrSelector, scope);
+    const elements = resolveElements(elementOrSelector, scope);
     const numElements = elements.length;
-    motionUtils.invariant(Boolean(numElements), "No valid element provided.");
+    invariant(Boolean(numElements), "No valid element provided.");
     const animations = [];
     for (let i = 0; i < numElements; i++) {
         const element = elements[i];
@@ -528,7 +553,7 @@ function animateElements(elementOrSelector, keyframes, options, scope) {
         for (const valueName in keyframes) {
             const valueKeyframes = keyframes[valueName];
             const valueOptions = {
-                ...getValueTransition(elementTransition, valueName),
+                ...getValueTransition(options, valueName),
             };
             valueOptions.duration = valueOptions.duration
                 ? secondsToMilliseconds(valueOptions.duration)
diff --git a/dist/client.d.ts b/dist/client.d.ts
index aa90a1e8c3e542165ce1d4066166ea1ba68bb81b..9ca33a66739ebda30c06951488c34763b935514e 100644
--- a/dist/client.d.ts
+++ b/dist/client.d.ts
@@ -1,6 +1,6 @@
 /// <reference types="react" />
 import * as React$1 from 'react';
-import { SVGAttributes, CSSProperties, PropsWithoutRef, RefAttributes, JSX } from 'react';
+import { SVGAttributes, CSSProperties, PropsWithoutRef, RefAttributes, ReactHTML, DetailedHTMLFactory, HTMLAttributes } from 'react';
 
 type EasingFunction = (v: number) => number;
 type BezierDefinition = readonly [number, number, number, number];
@@ -426,25 +426,6 @@ interface Spring extends Repeat {
      * @public
      */
     duration?: number;
-    /**
-     * If visualDuration is set, this will override duration.
-     *
-     * The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.
-     *
-     * In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.
-     *
-     * This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.
-     *
-     * ```jsx
-     * <motion.div
-     *   animate={{ x: 100 }}
-     *   transition={{ type: "spring", visualDuration: 0.5 }}
-     * />
-     * ```
-     *
-     * @public
-     */
-    visualDuration?: number;
     /**
      * `bounce` determines the "bounciness" of a spring animation.
      *
@@ -982,7 +963,6 @@ interface AnimationState<V> {
 interface KeyframeGenerator<V> {
     calculatedDuration: null | number;
     next: (t: number) => AnimationState<V>;
-    toString: () => string;
 }
 
 interface AnimationPlaybackLifecycles<V> {
@@ -1027,7 +1007,6 @@ interface AnimationPlaybackControls {
     cancel: () => void;
     then: (onResolve: VoidFunction, onReject?: VoidFunction) => Promise<void>;
     attachTimeline?: (timeline: ProgressTimeline, fallback?: (animation: AnimationPlaybackControls) => VoidFunction) => VoidFunction;
-    flatten: () => void;
 }
 type ValueKeyframe = string | number;
 type UnresolvedValueKeyframe = ValueKeyframe | null;
@@ -1048,7 +1027,6 @@ interface AnimationPlaybackOptions {
 }
 interface DurationSpringOptions {
     duration?: number;
-    visualDuration?: number;
     bounce?: number;
 }
 interface SpringOptions extends DurationSpringOptions, VelocityOptions {
@@ -1163,7 +1141,7 @@ declare class MotionValue<V = any> {
      */
     version: string;
     /**
-     * If a MotionValue has an owner, it was created internally within Motion
+     * If a MotionValue has an owner, it was created internally within Framer Motion
      * and therefore has no external listeners. It is therefore safe to animate via WAAPI.
      */
     owner?: Owner;
@@ -1182,11 +1160,11 @@ declare class MotionValue<V = any> {
     /**
      * The last time the `MotionValue` was updated.
      */
-    updatedAt: number;
+    private updatedAt;
     /**
      * The time `prevFrameValue` was updated.
      */
-    prevUpdatedAt: number | undefined;
+    private prevUpdatedAt;
     private stopPassiveEffect?;
     /**
      * A reference to the currently-controlling animation.
@@ -1584,7 +1562,7 @@ interface DraggableProps extends DragHandlers {
      * }
      * ```
      */
-    dragConstraints?: false | Partial<BoundingBox> | RefObject<Element | null>;
+    dragConstraints?: false | Partial<BoundingBox> | RefObject<Element>;
     /**
      * The degree of movement allowed outside constraints. 0 = no movement, 1 =
      * full movement.
@@ -2034,7 +2012,7 @@ interface HoverHandlers {
 
 type ViewportEventHandler = (entry: IntersectionObserverEntry | null) => void;
 interface ViewportOptions {
-    root?: RefObject<Element | null>;
+    root?: RefObject<Element>;
     once?: boolean;
     margin?: string;
     amount?: "some" | "all" | number;
@@ -2268,7 +2246,7 @@ interface MotionProps extends AnimationProps, EventProps, PanHandlers, TapHandle
      */
     style?: MotionStyle$1;
     /**
-     * By default, Motion generates a `transform` property with a sensible transform order. `transformTemplate`
+     * By default, Framer Motion generates a `transform` property with a sensible transform order. `transformTemplate`
      * can be used to create a different order, or to append/preprend the automatically generated `transform` property.
      *
      * ```jsx
@@ -2281,7 +2259,7 @@ interface MotionProps extends AnimationProps, EventProps, PanHandlers, TapHandle
      * ```
      *
      * @param transform - The latest animated transform props.
-     * @param generatedTransform - The transform string as automatically generated by Motion
+     * @param generatedTransform - The transform string as automatically generated by Framer Motion
      *
      * @public
      */
@@ -2294,131 +2272,13 @@ type MotionComponentProps<Props> = {
     [K in Exclude<keyof Props, keyof MotionProps>]?: Props[K];
 } & MotionProps;
 
-type UnionStringArray<T extends Readonly<string[]>> = T[number];
+type UnionStringArray$1<T extends Readonly<string[]>> = T[number];
 declare const svgElements: readonly ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "svg", "switch", "symbol", "text", "tspan", "use", "view", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "linearGradient", "radialGradient", "textPath"];
-type SVGElements = UnionStringArray<typeof svgElements>;
+type SVGElements = UnionStringArray$1<typeof svgElements>;
 
-interface HTMLElements {
-    a: HTMLAnchorElement;
-    abbr: HTMLElement;
-    address: HTMLElement;
-    area: HTMLAreaElement;
-    article: HTMLElement;
-    aside: HTMLElement;
-    audio: HTMLAudioElement;
-    b: HTMLElement;
-    base: HTMLBaseElement;
-    bdi: HTMLElement;
-    bdo: HTMLElement;
-    big: HTMLElement;
-    blockquote: HTMLQuoteElement;
-    body: HTMLBodyElement;
-    br: HTMLBRElement;
-    button: HTMLButtonElement;
-    canvas: HTMLCanvasElement;
-    caption: HTMLElement;
-    center: HTMLElement;
-    cite: HTMLElement;
-    code: HTMLElement;
-    col: HTMLTableColElement;
-    colgroup: HTMLTableColElement;
-    data: HTMLDataElement;
-    datalist: HTMLDataListElement;
-    dd: HTMLElement;
-    del: HTMLModElement;
-    details: HTMLDetailsElement;
-    dfn: HTMLElement;
-    dialog: HTMLDialogElement;
-    div: HTMLDivElement;
-    dl: HTMLDListElement;
-    dt: HTMLElement;
-    em: HTMLElement;
-    embed: HTMLEmbedElement;
-    fieldset: HTMLFieldSetElement;
-    figcaption: HTMLElement;
-    figure: HTMLElement;
-    footer: HTMLElement;
-    form: HTMLFormElement;
-    h1: HTMLHeadingElement;
-    h2: HTMLHeadingElement;
-    h3: HTMLHeadingElement;
-    h4: HTMLHeadingElement;
-    h5: HTMLHeadingElement;
-    h6: HTMLHeadingElement;
-    head: HTMLHeadElement;
-    header: HTMLElement;
-    hgroup: HTMLElement;
-    hr: HTMLHRElement;
-    html: HTMLHtmlElement;
-    i: HTMLElement;
-    iframe: HTMLIFrameElement;
-    img: HTMLImageElement;
-    input: HTMLInputElement;
-    ins: HTMLModElement;
-    kbd: HTMLElement;
-    keygen: HTMLElement;
-    label: HTMLLabelElement;
-    legend: HTMLLegendElement;
-    li: HTMLLIElement;
-    link: HTMLLinkElement;
-    main: HTMLElement;
-    map: HTMLMapElement;
-    mark: HTMLElement;
-    menu: HTMLElement;
-    menuitem: HTMLElement;
-    meta: HTMLMetaElement;
-    meter: HTMLMeterElement;
-    nav: HTMLElement;
-    noindex: HTMLElement;
-    noscript: HTMLElement;
-    object: HTMLObjectElement;
-    ol: HTMLOListElement;
-    optgroup: HTMLOptGroupElement;
-    option: HTMLOptionElement;
-    output: HTMLOutputElement;
-    p: HTMLParagraphElement;
-    param: HTMLParamElement;
-    picture: HTMLElement;
-    pre: HTMLPreElement;
-    progress: HTMLProgressElement;
-    q: HTMLQuoteElement;
-    rp: HTMLElement;
-    rt: HTMLElement;
-    ruby: HTMLElement;
-    s: HTMLElement;
-    samp: HTMLElement;
-    search: HTMLElement;
-    slot: HTMLSlotElement;
-    script: HTMLScriptElement;
-    section: HTMLElement;
-    select: HTMLSelectElement;
-    small: HTMLElement;
-    source: HTMLSourceElement;
-    span: HTMLSpanElement;
-    strong: HTMLElement;
-    style: HTMLStyleElement;
-    sub: HTMLElement;
-    summary: HTMLElement;
-    sup: HTMLElement;
-    table: HTMLTableElement;
-    template: HTMLTemplateElement;
-    tbody: HTMLTableSectionElement;
-    td: HTMLTableDataCellElement;
-    textarea: HTMLTextAreaElement;
-    tfoot: HTMLTableSectionElement;
-    th: HTMLTableHeaderCellElement;
-    thead: HTMLTableSectionElement;
-    time: HTMLTimeElement;
-    title: HTMLTitleElement;
-    tr: HTMLTableRowElement;
-    track: HTMLTrackElement;
-    u: HTMLElement;
-    ul: HTMLUListElement;
-    var: HTMLElement;
-    video: HTMLVideoElement;
-    wbr: HTMLElement;
-    webview: HTMLWebViewElement;
-}
+type UnionStringArray<T extends Readonly<string[]>> = T[number];
+declare const htmlElements: readonly ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "webview"];
+type HTMLElements = UnionStringArray<typeof htmlElements>;
 
 /**
  * @public
@@ -2426,20 +2286,25 @@ interface HTMLElements {
 type ForwardRefComponent<T, P> = {
     readonly $$typeof: symbol;
 } & ((props: PropsWithoutRef<P> & RefAttributes<T>) => JSX.Element);
-type AttributesWithoutMotionProps<Attributes> = {
+/**
+ * Support for React component props
+ */
+type UnwrapFactoryAttributes<F> = F extends DetailedHTMLFactory<infer P, any> ? P : never;
+type UnwrapFactoryElement<F> = F extends DetailedHTMLFactory<any, infer P> ? P : never;
+type HTMLAttributesWithoutMotionProps<Attributes extends HTMLAttributes<Element>, Element extends HTMLElement> = {
     [K in Exclude<keyof Attributes, keyof MotionProps>]?: Attributes[K];
 };
 /**
  * @public
  */
-type HTMLMotionProps<Tag extends keyof HTMLElements> = AttributesWithoutMotionProps<JSX.IntrinsicElements[Tag]> & MotionProps;
+type HTMLMotionProps<TagName extends keyof ReactHTML> = HTMLAttributesWithoutMotionProps<UnwrapFactoryAttributes<ReactHTML[TagName]>, UnwrapFactoryElement<ReactHTML[TagName]>> & MotionProps;
 /**
  * Motion-optimised versions of React's HTML components.
  *
  * @public
  */
 type HTMLMotionComponents = {
-    [K in keyof HTMLElements]: ForwardRefComponent<HTMLElements[K], HTMLMotionProps<K>>;
+    [K in HTMLElements]: ForwardRefComponent<UnwrapFactoryElement<ReactHTML[K]>, HTMLMotionProps<K>>;
 };
 
 interface SVGAttributesWithoutMotionProps<T> extends Pick<SVGAttributes<T>, Exclude<keyof SVGAttributes<T>, keyof MotionProps>> {
@@ -2522,7 +2387,7 @@ interface WithAppearProps {
 type HandoffFunction = (storeId: string, valueName: string, frame: Batcher) => number | null;
 /**
  * The window global object acts as a bridge between our inline script
- * triggering the optimized appear animations, and Motion.
+ * triggering the optimized appear animations, and Framer Motion.
  */
 declare global {
     interface Window {
@@ -2538,9 +2403,9 @@ declare global {
 
 type DOMMotionComponents = HTMLMotionComponents & SVGMotionComponents;
 
-declare const createMotionComponent: <Props, TagName extends string = "div">(Component: string | TagName | React$1.ComponentType<Props>, { forwardMotionProps }?: {
+declare const createMotionComponent: <Props, TagName extends string = "div">(Component: string | TagName | React$1.ForwardRefExoticComponent<Props>, { forwardMotionProps }?: {
     forwardMotionProps: boolean;
-}) => TagName extends "symbol" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "animate" | "text" | "path" | "image" | "circle" | "switch" | "svg" | keyof HTMLElements | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "textPath" | "tspan" | "use" | "view" ? DOMMotionComponents[TagName] : React$1.ComponentType<MotionComponentProps<React$1.PropsWithChildren<Props>>>;
+}) => TagName extends "symbol" | "object" | "map" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "a" | "b" | "var" | "style" | "animate" | "progress" | "text" | "ruby" | "table" | "small" | "embed" | "sub" | "path" | "image" | "button" | "meter" | "textarea" | "circle" | "pre" | "caption" | "menu" | "menuitem" | "article" | "dialog" | "figure" | "form" | "img" | "link" | "main" | "option" | "switch" | "time" | "div" | "abbr" | "address" | "area" | "aside" | "audio" | "base" | "bdi" | "bdo" | "blockquote" | "body" | "br" | "canvas" | "cite" | "code" | "col" | "colgroup" | "data" | "datalist" | "dd" | "del" | "details" | "dfn" | "dl" | "dt" | "em" | "fieldset" | "figcaption" | "footer" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "head" | "header" | "hgroup" | "hr" | "html" | "i" | "iframe" | "input" | "ins" | "kbd" | "label" | "legend" | "li" | "mark" | "meta" | "nav" | "noscript" | "ol" | "optgroup" | "output" | "p" | "picture" | "q" | "rp" | "rt" | "s" | "samp" | "script" | "section" | "select" | "source" | "span" | "strong" | "summary" | "sup" | "tbody" | "td" | "tfoot" | "th" | "thead" | "title" | "tr" | "track" | "u" | "ul" | "video" | "wbr" | "big" | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "svg" | "textPath" | "tspan" | "use" | "view" | "keygen" | "param" | "webview" ? DOMMotionComponents[TagName] : React$1.ForwardRefExoticComponent<MotionComponentProps<React$1.PropsWithChildren<Props>>>;
 
 /**
  * HTML components
diff --git a/dist/dom-mini.d.ts b/dist/dom-mini.d.ts
index 4fa69a481b3e559cefaf1bd71abcdcb149c94ea1..2de1323bf06718e700804f7885cfacdb504b351e 100644
--- a/dist/dom-mini.d.ts
+++ b/dist/dom-mini.d.ts
@@ -1,5 +1,3 @@
-import { ElementOrSelector } from 'motion-dom';
-
 type EasingFunction = (v: number) => number;
 type BezierDefinition = readonly [number, number, number, number];
 type EasingDefinition = BezierDefinition | "linear" | "easeIn" | "easeOut" | "easeInOut" | "circIn" | "circOut" | "circInOut" | "backIn" | "backOut" | "backInOut" | "anticipate";
@@ -297,7 +295,6 @@ interface AnimationState<V> {
 interface KeyframeGenerator<V> {
     calculatedDuration: null | number;
     next: (t: number) => AnimationState<V>;
-    toString: () => string;
 }
 
 interface AnimationPlaybackLifecycles<V> {
@@ -342,6 +339,7 @@ type AnimationOptionsWithValueOverrides<V = any> = StyleTransitions & SVGPathTra
 interface DynamicAnimationOptions extends Omit<AnimationOptionsWithValueOverrides, "delay"> {
     delay?: number | DynamicOption<number>;
 }
+type ElementOrSelector = Element | Element[] | NodeListOf<Element> | string;
 /**
  * @public
  */
@@ -358,7 +356,6 @@ interface AnimationPlaybackControls {
     cancel: () => void;
     then: (onResolve: VoidFunction, onReject?: VoidFunction) => Promise<void>;
     attachTimeline?: (timeline: ProgressTimeline, fallback?: (animation: AnimationPlaybackControls) => VoidFunction) => VoidFunction;
-    flatten: () => void;
 }
 type DynamicOption<T> = (i: number, total: number) => T;
 interface CSSStyleDeclarationWithTransform extends Omit<CSSStyleDeclaration, "direction" | "transition" | "x" | "y" | "z"> {
@@ -403,7 +400,6 @@ interface AnimationPlaybackOptions {
 }
 interface DurationSpringOptions {
     duration?: number;
-    visualDuration?: number;
     bounce?: number;
 }
 interface SpringOptions extends DurationSpringOptions, VelocityOptions {
@@ -428,6 +424,30 @@ interface KeyframeOptions {
     times?: number[];
 }
 
-declare const animateMini: (elementOrSelector: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions) => AnimationPlaybackControls;
+declare class GroupPlaybackControls implements AnimationPlaybackControls {
+    animations: AnimationPlaybackControls[];
+    constructor(animations: Array<AnimationPlaybackControls | undefined>);
+    then(onResolve: VoidFunction, onReject?: VoidFunction): Promise<void>;
+    /**
+     * TODO: Filter out cancelled or stopped animations before returning
+     */
+    private getAll;
+    private setAll;
+    attachTimeline(timeline: any, fallback: (animation: AnimationPlaybackControls) => VoidFunction): () => void;
+    get time(): number;
+    set time(time: number);
+    get speed(): number;
+    set speed(speed: number);
+    get startTime(): any;
+    get duration(): number;
+    private runAll;
+    play(): void;
+    pause(): void;
+    stop: () => void;
+    cancel(): void;
+    complete(): void;
+}
+
+declare const animateMini: (elementOrSelector: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions) => GroupPlaybackControls;
 
 export { animateMini as animate };
diff --git a/dist/dom-mini.js b/dist/dom-mini.js
index de5e284b77ab5a5a4af537088450d3ef6981ac8e..0623a4ed91482eaa744e6bc14ed497d439e0fd03 100644
--- a/dist/dom-mini.js
+++ b/dist/dom-mini.js
@@ -1 +1 @@
-!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Motion={})}(this,(function(t){"use strict";function e(t){let e;return()=>(void 0===e&&(e=t()),e)}const i=e(()=>void 0!==window.ScrollTimeline);class n{constructor(t){this.stop=()=>this.runAll("stop"),this.animations=t.filter(Boolean)}then(t,e){return Promise.all(this.animations).then(t).catch(e)}getAll(t){return this.animations[0][t]}setAll(t,e){for(let i=0;i<this.animations.length;i++)this.animations[i][t]=e}attachTimeline(t,e){const n=this.animations.map(n=>i()&&n.attachTimeline?n.attachTimeline(t):e(n));return()=>{n.forEach((t,e)=>{t&&t(),this.animations[e].stop()})}}get time(){return this.getAll("time")}set time(t){this.setAll("time",t)}get speed(){return this.getAll("speed")}set speed(t){this.setAll("speed",t)}get startTime(){return this.getAll("startTime")}get duration(){let t=0;for(let e=0;e<this.animations.length;e++)t=Math.max(t,this.animations[e].duration);return t}runAll(t){this.animations.forEach(e=>e[t]())}flatten(){this.runAll("flatten")}play(){this.runAll("play")}pause(){this.runAll("pause")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}const a=t=>t;let s=a;const o=t=>1e3*t,r=t=>t/1e3;const l=(t,e,i)=>{const n=e-t;return 0===n?1:(i-t)/n},u={linearEasing:void 0};function h(t,i){const n=e(t);return()=>{var t;return null!==(t=u[i])&&void 0!==t?t:n()}}const m=h(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch(t){return!1}return!0},"linearEasing"),c=([t,e,i,n])=>`cubic-bezier(${t}, ${e}, ${i}, ${n})`,d={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:c([0,.65,.55,1]),circOut:c([.55,0,1,.45]),backIn:c([.31,.01,.66,-.59]),backOut:c([.33,1.53,.69,.99])};function p(t,e){return t?"function"==typeof t&&m()?((t,e,i=10)=>{let n="";const a=Math.max(Math.round(e/i),2);for(let e=0;e<a;e++)n+=t(l(0,a-1,e))+", ";return`linear(${n.substring(0,n.length-2)})`})(t,e):(t=>Array.isArray(t)&&"number"==typeof t[0])(t)?c(t):Array.isArray(t)?t.map(t=>p(t,e)||d.easeOut):d[t]:void 0}const f=(t=>({test:e=>"string"==typeof e&&e.endsWith(t)&&1===e.split(" ").length,parse:parseFloat,transform:e=>`${e}${t}`}))("px"),y={borderWidth:f,borderTopWidth:f,borderRightWidth:f,borderBottomWidth:f,borderLeftWidth:f,borderRadius:f,radius:f,borderTopLeftRadius:f,borderTopRightRadius:f,borderBottomRightRadius:f,borderBottomLeftRadius:f,width:f,maxWidth:f,height:f,maxHeight:f,top:f,right:f,bottom:f,left:f,padding:f,paddingTop:f,paddingRight:f,paddingBottom:f,paddingLeft:f,margin:f,marginTop:f,marginRight:f,marginBottom:f,marginLeft:f,backgroundPositionX:f,backgroundPositionY:f};function g(t,e){t.timeline=e,t.onfinish=null}const A=t=>null!==t;function v(t,e,i){t.style.setProperty("--"+e,i)}function b(t,e,i){t.style[e]=i}const T=e(()=>{try{document.createElement("div").animate({opacity:[1]})}catch(t){return!1}return!0}),P=e(()=>Object.hasOwnProperty.call(Element.prototype,"animate")),R=new WeakMap;function w(t){const e=R.get(t)||new Map;return R.set(t,e),R.get(t)}class x{constructor(t,e,i,n){const a=e.startsWith("--");this.setValue=a?v:b,this.options=n,this.updateFinishedPromise(),s("string"!=typeof n.type);const l=w(t).get(e);l&&l.stop();if(Array.isArray(i)||(i=[i]),function(t,e,i){for(let n=0;n<e.length;n++)null===e[n]&&(e[n]=0===n?i():e[n-1]),"number"==typeof e[n]&&y[t]&&(e[n]=y[t].transform(e[n]));!T()&&e.length<2&&e.unshift(i())}(e,i,()=>e.startsWith("--")?t.style.getPropertyValue(e):window.getComputedStyle(t)[e]),"function"==typeof n.type){const t=function(t,e=100,i){const n=i({...t,keyframes:[0,e]}),a=Math.min(function(t){let e=0,i=t.next(e);for(;!i.done&&e<2e4;)e+=50,i=t.next(e);return e>=2e4?1/0:e}(n),2e4);return{type:"keyframes",ease:t=>n.next(a*t).value/e,duration:r(a)}}(n,100,n.type);n.ease=m()?t.ease:"easeOut",n.duration=o(t.duration),n.type="keyframes"}else n.ease=n.ease||"easeOut";this.removeAnimation=()=>{var i;return null===(i=R.get(t))||void 0===i?void 0:i.delete(e)};const u=()=>{this.setValue(t,e,function(t,{repeat:e,repeatType:i="loop"},n){const a=t.filter(A),s=e&&"loop"!==i&&e%2==1?0:a.length-1;return s&&void 0!==n?n:a[s]}(i,this.options)),this.cancel(),this.resolveFinishedPromise()};P()?(this.animation=function(t,e,i,{delay:n=0,duration:a=300,repeat:s=0,repeatType:o="loop",ease:r="easeInOut",times:l}={}){const u={[e]:i};l&&(u.offset=l);const h=p(r,a);return Array.isArray(h)&&(u.easing=h),t.animate(u,{delay:n,duration:a,easing:Array.isArray(h)?"linear":h,fill:"both",iterations:s+1,direction:"reverse"===o?"alternate":"normal"})}(t,e,i,n),!1===n.autoplay&&this.animation.pause(),this.animation.onfinish=u,this.pendingTimeline&&g(this.animation,this.pendingTimeline),w(t).set(e,this)):u()}get duration(){return r(this.options.duration||300)}get time(){var t;return this.animation?r((null===(t=this.animation)||void 0===t?void 0:t.currentTime)||0):0}set time(t){this.animation&&(this.animation.currentTime=o(t))}get speed(){return this.animation?this.animation.playbackRate:1}set speed(t){this.animation&&(this.animation.playbackRate=t)}get state(){return this.animation?this.animation.playState:"finished"}get startTime(){return this.animation?this.animation.startTime:null}flatten(){var t;this.animation&&(null===(t=this.animation.effect)||void 0===t||t.updateTiming({easing:"linear"}))}play(){"finished"===this.state&&this.updateFinishedPromise(),this.animation&&this.animation.play()}pause(){this.animation&&this.animation.pause()}stop(){this.animation&&"idle"!==this.state&&"finished"!==this.state&&(this.animation.commitStyles&&this.animation.commitStyles(),this.cancel())}complete(){this.animation&&this.animation.finish()}cancel(){this.removeAnimation();try{this.animation&&this.animation.cancel()}catch(t){}}then(t,e){return this.currentFinishedPromise.then(t,e)}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}attachTimeline(t){return this.animation?g(this.animation,t):this.pendingTimeline=t,a}}function k(t,e,i,n){const a=function(t,e,i){var n;if(t instanceof Element)return[t];if("string"==typeof t){let a=document;e&&(a=e.current);const s=null!==(n=null==i?void 0:i[t])&&void 0!==n?n:a.querySelectorAll(t);return s?Array.from(s):[]}return Array.from(t)}(t,n),s=a.length,r=[];for(let t=0;t<s;t++){const n=a[t],h={...i};"function"==typeof h.delay&&(h.delay=h.delay(t,s));for(const t in e){const i=e[t],a={...(l=h,u=t,l?l[u]||l.default||l:void 0)};a.duration=a.duration?o(a.duration):a.duration,a.delay=o(a.delay||0),r.push(new x(n,t,i,a))}}var l,u;return r}const O=(t=>function(e,i,a){return new n(k(e,i,a,t))})();t.animate=O}));
+!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Motion={})}(this,(function(t){"use strict";function e(t){let e;return()=>(void 0===e&&(e=t()),e)}const i=e(()=>void 0!==window.ScrollTimeline);class n{constructor(t){this.stop=()=>this.runAll("stop"),this.animations=t.filter(Boolean)}then(t,e){return Promise.all(this.animations).then(t).catch(e)}getAll(t){return this.animations[0][t]}setAll(t,e){for(let i=0;i<this.animations.length;i++)this.animations[i][t]=e}attachTimeline(t,e){const n=this.animations.map(n=>i()&&n.attachTimeline?n.attachTimeline(t):e(n));return()=>{n.forEach((t,e)=>{t&&t(),this.animations[e].stop()})}}get time(){return this.getAll("time")}set time(t){this.setAll("time",t)}get speed(){return this.getAll("speed")}set speed(t){this.setAll("speed",t)}get startTime(){return this.getAll("startTime")}get duration(){let t=0;for(let e=0;e<this.animations.length;e++)t=Math.max(t,this.animations[e].duration);return t}runAll(t){this.animations.forEach(e=>e[t]())}play(){this.runAll("play")}pause(){this.runAll("pause")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}const a=t=>t;let s=a;const o=t=>1e3*t,r=t=>t/1e3;const l=(t,e,i)=>{const n=e-t;return 0===n?1:(i-t)/n},h={linearEasing:void 0};function u(t,i){const n=e(t);return()=>{var t;return null!==(t=h[i])&&void 0!==t?t:n()}}const m=u(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch(t){return!1}return!0},"linearEasing"),c=([t,e,i,n])=>`cubic-bezier(${t}, ${e}, ${i}, ${n})`,d={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:c([0,.65,.55,1]),circOut:c([.55,0,1,.45]),backIn:c([.31,.01,.66,-.59]),backOut:c([.33,1.53,.69,.99])};function p(t,e){return t?"function"==typeof t&&m()?((t,e)=>{let i="";const n=Math.max(Math.round(e/10),2);for(let e=0;e<n;e++)i+=t(l(0,n-1,e))+", ";return`linear(${i.substring(0,i.length-2)})`})(t,e):(t=>Array.isArray(t)&&"number"==typeof t[0])(t)?c(t):Array.isArray(t)?t.map(t=>p(t,e)||d.easeOut):d[t]:void 0}const f=(t=>({test:e=>"string"==typeof e&&e.endsWith(t)&&1===e.split(" ").length,parse:parseFloat,transform:e=>`${e}${t}`}))("px"),y={borderWidth:f,borderTopWidth:f,borderRightWidth:f,borderBottomWidth:f,borderLeftWidth:f,borderRadius:f,radius:f,borderTopLeftRadius:f,borderTopRightRadius:f,borderBottomRightRadius:f,borderBottomLeftRadius:f,width:f,maxWidth:f,height:f,maxHeight:f,top:f,right:f,bottom:f,left:f,padding:f,paddingTop:f,paddingRight:f,paddingBottom:f,paddingLeft:f,margin:f,marginTop:f,marginRight:f,marginBottom:f,marginLeft:f,backgroundPositionX:f,backgroundPositionY:f};function g(t,e){t.timeline=e,t.onfinish=null}const A=t=>null!==t;function b(t,e,i){t.style.setProperty("--"+e,i)}function v(t,e,i){t.style[e]=i}const T=e(()=>{try{document.createElement("div").animate({opacity:[1]})}catch(t){return!1}return!0}),P=e(()=>Object.hasOwnProperty.call(Element.prototype,"animate")),R=new WeakMap;function w(t){const e=R.get(t)||new Map;return R.set(t,e),R.get(t)}class x{constructor(t,e,i,n){const a=e.startsWith("--");this.setValue=a?b:v,this.options=n,this.updateFinishedPromise(),s("string"!=typeof n.type);const l=w(t).get(e);l&&l.stop();if(Array.isArray(i)||(i=[i]),function(t,e,i){for(let n=0;n<e.length;n++)null===e[n]&&(e[n]=0===n?i():e[n-1]),"number"==typeof e[n]&&y[t]&&(e[n]=y[t].transform(e[n]));!T()&&e.length<2&&e.unshift(i())}(e,i,()=>e.startsWith("--")?t.style.getPropertyValue(e):window.getComputedStyle(t)[e]),"function"==typeof n.type){const t=function(t,e=100,i){const n=i({...t,keyframes:[0,e]}),a=Math.min(function(t){let e=0,i=t.next(e);for(;!i.done&&e<2e4;)e+=50,i=t.next(e);return e>=2e4?1/0:e}(n),2e4);return{type:"keyframes",ease:t=>n.next(a*t).value/e,duration:r(a)}}(n,100,n.type);n.ease=m()?t.ease:"easeOut",n.duration=o(t.duration),n.type="keyframes"}else n.ease=n.ease||"easeOut";this.removeAnimation=()=>{var i;return null===(i=R.get(t))||void 0===i?void 0:i.delete(e)};const h=()=>{this.setValue(t,e,function(t,{repeat:e,repeatType:i="loop"},n){const a=t.filter(A),s=e&&"loop"!==i&&e%2==1?0:a.length-1;return s&&void 0!==n?n:a[s]}(i,this.options)),this.cancel(),this.resolveFinishedPromise()};P()?(this.animation=function(t,e,i,{delay:n=0,duration:a=300,repeat:s=0,repeatType:o="loop",ease:r,times:l}={}){const h={[e]:i};l&&(h.offset=l);const u=p(r,a);return Array.isArray(u)&&(h.easing=u),t.animate(h,{delay:n,duration:a,easing:Array.isArray(u)?"linear":u,fill:"both",iterations:s+1,direction:"reverse"===o?"alternate":"normal"})}(t,e,i,n),!1===n.autoplay&&this.animation.pause(),this.animation.onfinish=h,this.pendingTimeline&&g(this.animation,this.pendingTimeline),w(t).set(e,this)):h()}get duration(){return r(this.options.duration||300)}get time(){var t;return this.animation?r((null===(t=this.animation)||void 0===t?void 0:t.currentTime)||0):0}set time(t){this.animation&&(this.animation.currentTime=o(t))}get speed(){return this.animation?this.animation.playbackRate:1}set speed(t){this.animation&&(this.animation.playbackRate=t)}get state(){return this.animation?this.animation.playState:"finished"}get startTime(){return this.animation?this.animation.startTime:null}play(){"finished"===this.state&&this.updateFinishedPromise(),this.animation&&this.animation.play()}pause(){this.animation&&this.animation.pause()}stop(){this.animation&&"idle"!==this.state&&"finished"!==this.state&&(this.animation.commitStyles&&this.animation.commitStyles(),this.cancel())}complete(){this.animation&&this.animation.finish()}cancel(){this.removeAnimation();try{this.animation&&this.animation.cancel()}catch(t){}}then(t,e){return this.currentFinishedPromise.then(t,e)}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}attachTimeline(t){return this.animation?g(this.animation,t):this.pendingTimeline=t,a}}function k(t,e,i,n){const a=function(t,e,i){var n;if("string"==typeof t){let a=document;e&&(s(Boolean(e.current)),a=e.current),i?(null!==(n=i[t])&&void 0!==n||(i[t]=a.querySelectorAll(t)),t=i[t]):t=a.querySelectorAll(t)}else t instanceof Element&&(t=[t]);return Array.from(t||[])}(t,n),r=a.length,l=[];for(let t=0;t<r;t++){const n=a[t],s={...i};"function"==typeof s.delay&&(s.delay=s.delay(t,r));for(const t in e){const a=e[t],s={...(h=i,u=t,h?h[u]||h.default||h:void 0)};s.duration=s.duration?o(s.duration):s.duration,s.delay=o(s.delay||0),l.push(new x(n,t,a,s))}}var h,u;return l}const W=(t=>function(e,i,a){return new n(k(e,i,a,t))})();t.animate=W}));
diff --git a/dist/dom.d.ts b/dist/dom.d.ts
index 48acdf69c8f22e510d1c41e604fcb0812bd224ea..efac30219d9ecf520b6f1893f1d1fe4fe064e8a0 100644
--- a/dist/dom.d.ts
+++ b/dist/dom.d.ts
@@ -1,7 +1,3 @@
-export { invariant, noop } from 'motion-utils';
-import { ElementOrSelector, AnimationScope } from 'motion-dom';
-export { isDragActive } from 'motion-dom';
-
 type EasingFunction = (v: number) => number;
 type EasingModifier = (easing: EasingFunction) => EasingFunction;
 type BezierDefinition = readonly [number, number, number, number];
@@ -307,7 +303,6 @@ interface AnimationState<V> {
 interface KeyframeGenerator<V> {
     calculatedDuration: null | number;
     next: (t: number) => AnimationState<V>;
-    toString: () => string;
 }
 
 interface AnimationPlaybackLifecycles<V> {
@@ -336,6 +331,10 @@ interface ValueAnimationOptions<V extends string | number = number> extends Valu
     from?: V;
     isGenerator?: boolean;
 }
+interface AnimationScope<T = any> {
+    readonly current: T;
+    animations: AnimationPlaybackControls[];
+}
 type StyleTransitions = {
     [K in keyof CSSStyleDeclarationWithTransform]?: Transition;
 };
@@ -352,6 +351,7 @@ type AnimationOptionsWithValueOverrides<V = any> = StyleTransitions & SVGPathTra
 interface DynamicAnimationOptions extends Omit<AnimationOptionsWithValueOverrides, "delay"> {
     delay?: number | DynamicOption<number>;
 }
+type ElementOrSelector = Element | Element[] | NodeListOf<Element> | string;
 /**
  * @public
  */
@@ -368,7 +368,6 @@ interface AnimationPlaybackControls {
     cancel: () => void;
     then: (onResolve: VoidFunction, onReject?: VoidFunction) => Promise<void>;
     attachTimeline?: (timeline: ProgressTimeline, fallback?: (animation: AnimationPlaybackControls) => VoidFunction) => VoidFunction;
-    flatten: () => void;
 }
 type DynamicOption<T> = (i: number, total: number) => T;
 interface CSSStyleDeclarationWithTransform extends Omit<CSSStyleDeclaration, "direction" | "transition" | "x" | "y" | "z"> {
@@ -413,7 +412,6 @@ interface AnimationPlaybackOptions {
 }
 interface DurationSpringOptions {
     duration?: number;
-    visualDuration?: number;
     bounce?: number;
 }
 interface SpringOptions extends DurationSpringOptions, VelocityOptions {
@@ -477,7 +475,7 @@ declare class MotionValue<V = any> {
      */
     version: string;
     /**
-     * If a MotionValue has an owner, it was created internally within Motion
+     * If a MotionValue has an owner, it was created internally within Framer Motion
      * and therefore has no external listeners. It is therefore safe to animate via WAAPI.
      */
     owner?: Owner;
@@ -496,11 +494,11 @@ declare class MotionValue<V = any> {
     /**
      * The last time the `MotionValue` was updated.
      */
-    updatedAt: number;
+    private updatedAt;
     /**
      * The time `prevFrameValue` was updated.
      */
-    prevUpdatedAt: number | undefined;
+    private prevUpdatedAt;
     private stopPassiveEffect?;
     /**
      * A reference to the currently-controlling animation.
@@ -665,24 +663,6 @@ interface SequenceOptions extends AnimationPlaybackOptions {
     duration?: number;
     defaultTransition?: Transition;
 }
-interface AbsoluteKeyframe {
-    value: string | number | null;
-    at: number;
-    easing?: Easing;
-}
-type ValueSequence = AbsoluteKeyframe[];
-interface SequenceMap {
-    [key: string]: ValueSequence;
-}
-type ResolvedAnimationDefinition = {
-    keyframes: {
-        [key: string]: UnresolvedValueKeyframe[];
-    };
-    transition: {
-        [key: string]: Transition;
-    };
-};
-type ResolvedAnimationDefinitions = Map<Element | MotionValue, ResolvedAnimationDefinition>;
 
 /**
  * Creates an animation function that is optionally scoped
@@ -705,7 +685,31 @@ declare const animate: {
     <O extends {}>(object: O | O[], keyframes: ObjectTarget<O>, options?: DynamicAnimationOptions): AnimationPlaybackControls;
 };
 
-declare const animateMini: (elementOrSelector: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions) => AnimationPlaybackControls;
+declare class GroupPlaybackControls implements AnimationPlaybackControls {
+    animations: AnimationPlaybackControls[];
+    constructor(animations: Array<AnimationPlaybackControls | undefined>);
+    then(onResolve: VoidFunction, onReject?: VoidFunction): Promise<void>;
+    /**
+     * TODO: Filter out cancelled or stopped animations before returning
+     */
+    private getAll;
+    private setAll;
+    attachTimeline(timeline: any, fallback: (animation: AnimationPlaybackControls) => VoidFunction): () => void;
+    get time(): number;
+    set time(time: number);
+    get speed(): number;
+    set speed(speed: number);
+    get startTime(): any;
+    get duration(): number;
+    private runAll;
+    play(): void;
+    pause(): void;
+    stop: () => void;
+    cancel(): void;
+    complete(): void;
+}
+
+declare const animateMini: (elementOrSelector: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions) => GroupPlaybackControls;
 
 interface ScrollOptions {
     source?: HTMLElement;
@@ -762,12 +766,12 @@ declare global {
         ScrollTimeline: ScrollTimeline;
     }
 }
-declare function scroll(onScroll: OnScroll | AnimationPlaybackControls, { axis, ...options }?: ScrollOptions): VoidFunction;
+declare function scroll(onScroll: OnScroll | GroupPlaybackControls, { axis, ...options }?: ScrollOptions): VoidFunction;
 
 declare function scrollInfo(onScroll: OnScrollInfo, { container, ...options }?: ScrollInfoOptions): () => void;
 
 type ViewChangeHandler = (entry: IntersectionObserverEntry) => void;
-type MarginValue = `${number}${"px" | "%"}`;
+type MarginValue = `${number}${'px' | '%'}`;
 type MarginType = MarginValue | `${MarginValue} ${MarginValue}` | `${MarginValue} ${MarginValue} ${MarginValue}` | `${MarginValue} ${MarginValue} ${MarginValue} ${MarginValue}`;
 interface InViewOptions {
     root?: Element | Document;
@@ -908,7 +912,7 @@ interface WithAppearProps {
 type HandoffFunction = (storeId: string, valueName: string, frame: Batcher) => number | null;
 /**
  * The window global object acts as a bridge between our inline script
- * triggering the optimized appear animations, and Motion.
+ * triggering the optimized appear animations, and Framer Motion.
  */
 declare global {
     interface Window {
@@ -922,7 +926,7 @@ declare global {
     }
 }
 
-declare function spring(optionsOrVisualDuration?: ValueAnimationOptions<number> | number, bounce?: number): KeyframeGenerator<number>;
+declare function spring({ keyframes, restDelta, restSpeed, ...options }: ValueAnimationOptions<number>): KeyframeGenerator<number>;
 
 type DelayedFunction = (overshoot: number) => void;
 declare function delayInSeconds(callback: DelayedFunction, timeout: number): () => void;
@@ -965,6 +969,10 @@ declare const clamp: (min: number, max: number, v: number) => number;
 declare const distance: (a: number, b: number) => number;
 declare function distance2D(a: Point, b: Point): number;
 
+type DevMessage = (check: boolean, message: string) => void;
+declare let warning: DevMessage;
+declare let invariant: DevMessage;
+
 type Mix<T> = (v: number) => T;
 type MixerFactory<T> = (from: T, to: T) => Mix<T>;
 interface InterpolateOptions<T> {
@@ -1009,19 +1017,6 @@ declare const cancelFrame: (process: Process) => void;
 declare const frameData: FrameData;
 declare const frameSteps: Steps;
 
-/**
- * An eventloop-synchronous alternative to performance.now().
- *
- * Ensures that time measurements remain consistent within a synchronous context.
- * Usually calling performance.now() twice within the same synchronous context
- * will return different values which isn't useful for animations when we're usually
- * trying to sync animations to the same frame.
- */
-declare const time: {
-    now: () => number;
-    set: (newTime: number) => void;
-};
-
 /**
  * @deprecated
  *
@@ -1035,4 +1030,4 @@ declare const sync: Batcher;
  */
 declare const cancelSync: Record<string, (process: Process) => void>;
 
-export { type AbsoluteKeyframe, type AnimationSequence, type At, type BezierDefinition, type DOMKeyframesDefinition, type DOMSegment, type DOMSegmentWithTransition, type DelayedFunction, type Direction, type DynamicAnimationOptions, type Easing, type EasingDefinition, type EasingFunction, type EasingModifier, type InterpolateOptions, type MixerFactory, MotionValue, type MotionValueSegment, type MotionValueSegmentWithTransition, type ObjectSegment, type ObjectSegmentWithTransition, type ObjectTarget, type PassiveEffect, type ResolvedAnimationDefinition, type ResolvedAnimationDefinitions, type Segment, type SequenceLabel, type SequenceLabelWithTime, type SequenceMap, type SequenceOptions, type SequenceTime, type Subscriber, type ValueSequence, animate, animateMini, anticipate, backIn, backInOut, backOut, cancelFrame, cancelSync, circIn, circInOut, circOut, clamp, createScopedAnimate, cubicBezier, delayInSeconds as delay, distance, distance2D, easeIn, easeInOut, easeOut, frame, frameData, frameSteps, inView, inertia, interpolate, keyframes, mirrorEasing, mix, motionValue, pipe, progress, reverseEasing, scroll, scrollInfo, spring, stagger, steps, sync, time, transform, wrap };
+export { type DelayedFunction, type DevMessage, type Direction, type InterpolateOptions, type MixerFactory, MotionValue, type PassiveEffect, type Subscriber, animate, animateMini, anticipate, backIn, backInOut, backOut, cancelFrame, cancelSync, circIn, circInOut, circOut, clamp, createScopedAnimate, cubicBezier, delayInSeconds as delay, distance, distance2D, easeIn, easeInOut, easeOut, frame, frameData, frameSteps, inView, inertia, interpolate, invariant, keyframes, mirrorEasing, mix, motionValue, pipe, progress, reverseEasing, scroll, scrollInfo, spring, stagger, steps, sync, transform, warning, wrap };
diff --git a/dist/dom.js b/dist/dom.js
index 2c0e33101703ceeb98baec51c65ddd9f48e359e2..b7d5f0ebd930e974d13ec1a9d3f893cfe6f2cb50 100644
--- a/dist/dom.js
+++ b/dist/dom.js
@@ -1 +1 @@
-!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Motion={})}(this,(function(t){"use strict";const e=t=>t;let n=e;const s=!1;function i(t,e,n){var s;if(t instanceof Element)return[t];if("string"==typeof t){let i=document;e&&(i=e.current);const r=null!==(s=null==n?void 0:n[t])&&void 0!==s?s:i.querySelectorAll(t);return r?Array.from(r):[]}return Array.from(t)}const r=!1;const o=["read","resolveKeyframes","update","preRender","render","postRender"];const{schedule:a,cancel:l,state:u,steps:c}=function(t,e){let n=!1,s=!0;const i={delta:0,timestamp:0,isProcessing:!1},r=()=>n=!0,a=o.reduce((t,e)=>(t[e]=function(t){let e=new Set,n=new Set,s=!1,i=!1;const r=new WeakSet;let o={delta:0,timestamp:0,isProcessing:!1};function a(e){r.has(e)&&(l.schedule(e),t()),e(o)}const l={schedule:(t,i=!1,o=!1)=>{const a=o&&s?e:n;return i&&r.add(t),a.has(t)||a.add(t),t},cancel:t=>{n.delete(t),r.delete(t)},process:t=>{o=t,s?i=!0:(s=!0,[e,n]=[n,e],e.forEach(a),e.clear(),s=!1,i&&(i=!1,l.process(t)))}};return l}(r),t),{}),{read:l,resolveKeyframes:u,update:c,preRender:h,render:d,postRender:p}=a,f=()=>{const r=performance.now();n=!1,i.delta=s?1e3/60:Math.max(Math.min(r-i.timestamp,40),1),i.timestamp=r,i.isProcessing=!0,l.process(i),u.process(i),c.process(i),h.process(i),d.process(i),p.process(i),i.isProcessing=!1,n&&e&&(s=!1,t(f))};return{schedule:o.reduce((e,r)=>{const o=a[r];return e[r]=(e,r=!1,a=!1)=>(n||(n=!0,s=!0,i.isProcessing||t(f)),o.schedule(e,r,a)),e},{}),cancel:t=>{for(let e=0;e<o.length;e++)a[o[e]].cancel(t)},state:i,steps:a}}("undefined"!=typeof requestAnimationFrame?requestAnimationFrame:e,!0);function h(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class d{constructor(){this.subscriptions=[]}add(t){var e,n;return e=this.subscriptions,n=t,-1===e.indexOf(n)&&e.push(n),()=>h(this.subscriptions,t)}notify(t,e,n){const s=this.subscriptions.length;if(s)if(1===s)this.subscriptions[0](t,e,n);else for(let i=0;i<s;i++){const s=this.subscriptions[i];s&&s(t,e,n)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}function p(t,e){return e?t*(1e3/e):0}let f;function m(){f=void 0}const g={now:()=>(void 0===f&&g.set(u.isProcessing||r?u.timestamp:performance.now()),f),set:t=>{f=t,queueMicrotask(m)}};class y{constructor(t,e={}){this.version="11.15.0",this.canTrackVelocity=null,this.events={},this.updateAndNotify=(t,e=!0)=>{const n=g.now();this.updatedAt!==n&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(t),this.current!==this.prev&&this.events.change&&this.events.change.notify(this.current),e&&this.events.renderRequest&&this.events.renderRequest.notify(this.current)},this.hasAnimated=!1,this.setCurrent(t),this.owner=e.owner}setCurrent(t){var e;this.current=t,this.updatedAt=g.now(),null===this.canTrackVelocity&&void 0!==t&&(this.canTrackVelocity=(e=this.current,!isNaN(parseFloat(e))))}setPrevFrameValue(t=this.current){this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt}onChange(t){return this.on("change",t)}on(t,e){this.events[t]||(this.events[t]=new d);const n=this.events[t].add(e);return"change"===t?()=>{n(),a.read(()=>{this.events.change.getSize()||this.stop()})}:n}clearListeners(){for(const t in this.events)this.events[t].clear()}attach(t,e){this.passiveEffect=t,this.stopPassiveEffect=e}set(t,e=!0){e&&this.passiveEffect?this.passiveEffect(t,this.updateAndNotify):this.updateAndNotify(t,e)}setWithVelocity(t,e,n){this.set(e),this.prev=void 0,this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt-n}jump(t,e=!0){this.updateAndNotify(t),this.prev=t,this.prevUpdatedAt=this.prevFrameValue=void 0,e&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const t=g.now();if(!this.canTrackVelocity||void 0===this.prevFrameValue||t-this.updatedAt>30)return 0;const e=Math.min(this.updatedAt-this.prevUpdatedAt,30);return p(parseFloat(this.current)-parseFloat(this.prevFrameValue),e)}start(t){return this.stop(),new Promise(e=>{this.hasAnimated=!0,this.animation=t(e),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function v(t,e){return new y(t,e)}function w(t){let e;return()=>(void 0===e&&(e=t()),e)}const b=w(()=>void 0!==window.ScrollTimeline);class T{constructor(t){this.stop=()=>this.runAll("stop"),this.animations=t.filter(Boolean)}then(t,e){return Promise.all(this.animations).then(t).catch(e)}getAll(t){return this.animations[0][t]}setAll(t,e){for(let n=0;n<this.animations.length;n++)this.animations[n][t]=e}attachTimeline(t,e){const n=this.animations.map(n=>b()&&n.attachTimeline?n.attachTimeline(t):e(n));return()=>{n.forEach((t,e)=>{t&&t(),this.animations[e].stop()})}}get time(){return this.getAll("time")}set time(t){this.setAll("time",t)}get speed(){return this.getAll("speed")}set speed(t){this.setAll("speed",t)}get startTime(){return this.getAll("startTime")}get duration(){let t=0;for(let e=0;e<this.animations.length;e++)t=Math.max(t,this.animations[e].duration);return t}runAll(t){this.animations.forEach(e=>e[t]())}flatten(){this.runAll("flatten")}play(){this.runAll("play")}pause(){this.runAll("pause")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}const x=(t,e,n)=>{const s=e-t;return 0===s?1:(n-t)/s},S=(t,e,n=10)=>{let s="";const i=Math.max(Math.round(e/n),2);for(let e=0;e<i;e++)s+=t(x(0,i-1,e))+", ";return`linear(${s.substring(0,s.length-2)})`},V=t=>1e3*t,A=t=>t/1e3;function M(t,e,n){const s=Math.max(e-5,0);return p(n-t(s),e-s)}const P=(t,e,n)=>n>e?e:n<t?t:n,k=100,F=10,C=1,E=0,O=800,I=.3,R=.3,B={granular:.01,default:2},D={granular:.005,default:.5},L=.01,W=10,N=.05,K=1;function j({duration:t=O,bounce:e=I,velocity:n=E,mass:s=C}){let i,r,o=1-e;o=P(N,K,o),t=P(L,W,A(t)),o<1?(i=e=>{const s=e*o,i=s*t;return.001-(s-n)/z(e,o)*Math.exp(-i)},r=e=>{const s=e*o*t,r=s*n+n,a=Math.pow(o,2)*Math.pow(e,2)*t,l=Math.exp(-s),u=z(Math.pow(e,2),o);return(.001-i(e)>0?-1:1)*((r-a)*l)/u}):(i=e=>Math.exp(-e*t)*((e-n)*t+1)-.001,r=e=>Math.exp(-e*t)*(t*t*(n-e)));const a=function(t,e,n){let s=n;for(let n=1;n<12;n++)s-=t(s)/e(s);return s}(i,r,5/t);if(t=V(t),isNaN(a))return{stiffness:k,damping:F,duration:t};{const e=Math.pow(a,2)*s;return{stiffness:e,damping:2*o*Math.sqrt(s*e),duration:t}}}function z(t,e){return t*Math.sqrt(1-e*e)}function $(t){let e=0;let n=t.next(e);for(;!n.done&&e<2e4;)e+=50,n=t.next(e);return e>=2e4?1/0:e}const H=["duration","bounce"],U=["stiffness","damping","mass"];function Y(t,e){return e.some(e=>void 0!==t[e])}function q(t=R,e=I){const n="object"!=typeof t?{visualDuration:t,keyframes:[0,1],bounce:e}:t;let{restSpeed:s,restDelta:i}=n;const r=n.keyframes[0],o=n.keyframes[n.keyframes.length-1],a={done:!1,value:r},{stiffness:l,damping:u,mass:c,duration:h,velocity:d,isResolvedFromDuration:p}=function(t){let e={velocity:E,stiffness:k,damping:F,mass:C,isResolvedFromDuration:!1,...t};if(!Y(t,U)&&Y(t,H))if(t.visualDuration){const n=t.visualDuration,s=2*Math.PI/(1.2*n),i=s*s,r=2*P(.05,1,1-t.bounce)*Math.sqrt(i);e={...e,mass:C,stiffness:i,damping:r}}else{const n=j(t);e={...e,...n,mass:C},e.isResolvedFromDuration=!0}return e}({...n,velocity:-A(n.velocity||0)}),f=d||0,m=u/(2*Math.sqrt(l*c)),g=o-r,y=A(Math.sqrt(l/c)),v=Math.abs(g)<5;let w;if(s||(s=v?B.granular:B.default),i||(i=v?D.granular:D.default),m<1){const t=z(y,m);w=e=>{const n=Math.exp(-m*y*e);return o-n*((f+m*y*g)/t*Math.sin(t*e)+g*Math.cos(t*e))}}else if(1===m)w=t=>o-Math.exp(-y*t)*(g+(f+y*g)*t);else{const t=y*Math.sqrt(m*m-1);w=e=>{const n=Math.exp(-m*y*e),s=Math.min(t*e,300);return o-n*((f+m*y*g)*Math.sinh(s)+t*g*Math.cosh(s))/t}}const b={calculatedDuration:p&&h||null,next:t=>{const e=w(t);if(p)a.done=t>=h;else{let n=0;m<1&&(n=0===t?V(f):M(w,t,e));const r=Math.abs(n)<=s,l=Math.abs(o-e)<=i;a.done=r&&l}return a.value=a.done?o:e,a},toString:()=>{const t=Math.min($(b),2e4),e=S(e=>b.next(t*e).value,t,30);return t+"ms "+e}};return b}function X(t,e=100,n){const s=n({...t,keyframes:[0,e]}),i=Math.min($(s),2e4);return{type:"keyframes",ease:t=>s.next(i*t).value/e,duration:A(i)}}const G=(t,e,n)=>t+(e-t)*n;function Z(t,e){const n=t[t.length-1];for(let s=1;s<=e;s++){const i=x(0,e,s);t.push(G(n,1,i))}}function _(t){const e=[0];return Z(e,t.length-1),e}const J=t=>Boolean(t&&t.getVelocity);function Q(t){return"object"==typeof t&&!Array.isArray(t)}function tt(t,e,n,s){return"string"==typeof t&&Q(e)?i(t,n,s):t instanceof NodeList?Array.from(t):Array.isArray(t)?t:[t]}function et(t){return"function"==typeof t}function nt(t,e,n,s){var i;return"number"==typeof e?e:e.startsWith("-")||e.startsWith("+")?Math.max(0,t+parseFloat(e)):"<"===e?n:null!==(i=s.get(e))&&void 0!==i?i:t}const st=(t,e,n)=>{const s=e-t;return((n-t)%s+s)%s+t},it=t=>Array.isArray(t)&&"number"!=typeof t[0];function rt(t,e){return it(t)?t[st(0,t.length,e)]:t}function ot(t,e,n,s,i,r){!function(t,e,n){for(let s=0;s<t.length;s++){const i=t[s];i.at>e&&i.at<n&&(h(t,i),s--)}}(t,i,r);for(let o=0;o<e.length;o++)t.push({value:e[o],at:G(i,r,s[o]),easing:rt(n,o)})}function at(t,e){return t.at===e.at?null===t.value?1:null===e.value?-1:0:t.at-e.at}function lt(t,e){for(let n=0;n<t.length;n++)t[n]=t[n]/(e+1)}function ut(t,e,n){return t*(e+1)}function ct(t,e){return!e.has(t)&&e.set(t,{}),e.get(t)}function ht(t,e){return e[t]||(e[t]=[]),e[t]}function dt(t){return Array.isArray(t)?t:[t]}function pt(t,e){return t&&t[e]?{...t,...t[e]}:{...t}}const ft=t=>"number"==typeof t,mt=t=>t.every(ft),gt=new WeakMap,yt=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],vt=new Set(yt),wt={type:"spring",stiffness:500,damping:25,restSpeed:10},bt={type:"keyframes",duration:.8},Tt={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},xt=(t,{keyframes:e})=>e.length>2?bt:vt.has(t)?t.startsWith("scale")?{type:"spring",stiffness:550,damping:0===e[1]?2*Math.sqrt(550):30,restSpeed:10}:wt:Tt;function St(t,e){return t?t[e]||t.default||t:void 0}const Vt=t=>null!==t;function At(t,{repeat:e,repeatType:n="loop"},s){const i=t.filter(Vt),r=e&&"loop"!==n&&e%2==1?0:i.length-1;return r&&void 0!==s?s:i[r]}const Mt=(t,e,n)=>(((1-3*n+3*e)*t+(3*n-6*e))*t+3*e)*t;function Pt(t,n,s,i){if(t===n&&s===i)return e;const r=e=>function(t,e,n,s,i){let r,o,a=0;do{o=e+(n-e)/2,r=Mt(o,s,i)-t,r>0?n=o:e=o}while(Math.abs(r)>1e-7&&++a<12);return o}(e,0,1,t,s);return t=>0===t||1===t?t:Mt(r(t),n,i)}const kt=t=>e=>e<=.5?t(2*e)/2:(2-t(2*(1-e)))/2,Ft=t=>e=>1-t(1-e),Ct=Pt(.33,1.53,.69,.99),Et=Ft(Ct),Ot=kt(Et),It=t=>(t*=2)<1?.5*Et(t):.5*(2-Math.pow(2,-10*(t-1))),Rt=t=>1-Math.sin(Math.acos(t)),Bt=Ft(Rt),Dt=kt(Rt),Lt=t=>/^0[^.\s]+$/u.test(t);const Wt=t=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),Nt=t=>e=>"string"==typeof e&&e.startsWith(t),Kt=Nt("--"),jt=Nt("var(--"),zt=t=>!!jt(t)&&$t.test(t.split("/*")[0].trim()),$t=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,Ht=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function Ut(t,e,n=1){const[s,i]=function(t){const e=Ht.exec(t);if(!e)return[,];const[,n,s,i]=e;return["--"+(null!=n?n:s),i]}(t);if(!s)return;const r=window.getComputedStyle(e).getPropertyValue(s);if(r){const t=r.trim();return Wt(t)?parseFloat(t):t}return zt(i)?Ut(i,e,n+1):i}const Yt={test:t=>"number"==typeof t,parse:parseFloat,transform:t=>t},qt={...Yt,transform:t=>P(0,1,t)},Xt={...Yt,default:1},Gt=t=>({test:e=>"string"==typeof e&&e.endsWith(t)&&1===e.split(" ").length,parse:parseFloat,transform:e=>`${e}${t}`}),Zt=Gt("deg"),_t=Gt("%"),Jt=Gt("px"),Qt=Gt("vh"),te=Gt("vw"),ee={..._t,parse:t=>_t.parse(t)/100,transform:t=>_t.transform(100*t)},ne=new Set(["width","height","top","left","right","bottom","x","y","translateX","translateY"]),se=t=>t===Yt||t===Jt,ie=(t,e)=>parseFloat(t.split(", ")[e]),re=(t,e)=>(n,{transform:s})=>{if("none"===s||!s)return 0;const i=s.match(/^matrix3d\((.+)\)$/u);if(i)return ie(i[1],e);{const e=s.match(/^matrix\((.+)\)$/u);return e?ie(e[1],t):0}},oe=new Set(["x","y","z"]),ae=yt.filter(t=>!oe.has(t));const le={width:({x:t},{paddingLeft:e="0",paddingRight:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),height:({y:t},{paddingTop:e="0",paddingBottom:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),top:(t,{top:e})=>parseFloat(e),left:(t,{left:e})=>parseFloat(e),bottom:({y:t},{top:e})=>parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=>parseFloat(e)+(t.max-t.min),x:re(4,13),y:re(5,14)};le.translateX=le.x,le.translateY=le.y;const ue=t=>e=>e.test(t),ce=[Yt,Jt,_t,Zt,te,Qt,{test:t=>"auto"===t,parse:t=>t}],he=t=>ce.find(ue(t)),de=new Set;let pe=!1,fe=!1;function me(){if(fe){const t=Array.from(de).filter(t=>t.needsMeasurement),e=new Set(t.map(t=>t.element)),n=new Map;e.forEach(t=>{const e=function(t){const e=[];return ae.forEach(n=>{const s=t.getValue(n);void 0!==s&&(e.push([n,s.get()]),s.set(n.startsWith("scale")?1:0))}),e}(t);e.length&&(n.set(t,e),t.render())}),t.forEach(t=>t.measureInitialState()),e.forEach(t=>{t.render();const e=n.get(t);e&&e.forEach(([e,n])=>{var s;null===(s=t.getValue(e))||void 0===s||s.set(n)})}),t.forEach(t=>t.measureEndState()),t.forEach(t=>{void 0!==t.suspendedScrollY&&window.scrollTo(0,t.suspendedScrollY)})}fe=!1,pe=!1,de.forEach(t=>t.complete()),de.clear()}function ge(){de.forEach(t=>{t.readKeyframes(),t.needsMeasurement&&(fe=!0)})}class ye{constructor(t,e,n,s,i,r=!1){this.isComplete=!1,this.isAsync=!1,this.needsMeasurement=!1,this.isScheduled=!1,this.unresolvedKeyframes=[...t],this.onComplete=e,this.name=n,this.motionValue=s,this.element=i,this.isAsync=r}scheduleResolve(){this.isScheduled=!0,this.isAsync?(de.add(this),pe||(pe=!0,a.read(ge),a.resolveKeyframes(me))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:t,name:e,element:n,motionValue:s}=this;for(let i=0;i<t.length;i++)if(null===t[i])if(0===i){const i=null==s?void 0:s.get(),r=t[t.length-1];if(void 0!==i)t[0]=i;else if(n&&e){const s=n.readValue(e,r);null!=s&&(t[0]=s)}void 0===t[0]&&(t[0]=r),s&&void 0===i&&s.set(t[0])}else t[i]=t[i-1]}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(){this.isComplete=!0,this.onComplete(this.unresolvedKeyframes,this.finalKeyframe),de.delete(this)}cancel(){this.isComplete||(this.isScheduled=!1,de.delete(this))}resume(){this.isComplete||this.scheduleResolve()}}const ve=t=>Math.round(1e5*t)/1e5,we=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;const be=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,Te=(t,e)=>n=>Boolean("string"==typeof n&&be.test(n)&&n.startsWith(t)||e&&!function(t){return null==t}(n)&&Object.prototype.hasOwnProperty.call(n,e)),xe=(t,e,n)=>s=>{if("string"!=typeof s)return s;const[i,r,o,a]=s.match(we);return{[t]:parseFloat(i),[e]:parseFloat(r),[n]:parseFloat(o),alpha:void 0!==a?parseFloat(a):1}},Se={...Yt,transform:t=>Math.round((t=>P(0,255,t))(t))},Ve={test:Te("rgb","red"),parse:xe("red","green","blue"),transform:({red:t,green:e,blue:n,alpha:s=1})=>"rgba("+Se.transform(t)+", "+Se.transform(e)+", "+Se.transform(n)+", "+ve(qt.transform(s))+")"};const Ae={test:Te("#"),parse:function(t){let e="",n="",s="",i="";return t.length>5?(e=t.substring(1,3),n=t.substring(3,5),s=t.substring(5,7),i=t.substring(7,9)):(e=t.substring(1,2),n=t.substring(2,3),s=t.substring(3,4),i=t.substring(4,5),e+=e,n+=n,s+=s,i+=i),{red:parseInt(e,16),green:parseInt(n,16),blue:parseInt(s,16),alpha:i?parseInt(i,16)/255:1}},transform:Ve.transform},Me={test:Te("hsl","hue"),parse:xe("hue","saturation","lightness"),transform:({hue:t,saturation:e,lightness:n,alpha:s=1})=>"hsla("+Math.round(t)+", "+_t.transform(ve(e))+", "+_t.transform(ve(n))+", "+ve(qt.transform(s))+")"},Pe={test:t=>Ve.test(t)||Ae.test(t)||Me.test(t),parse:t=>Ve.test(t)?Ve.parse(t):Me.test(t)?Me.parse(t):Ae.parse(t),transform:t=>"string"==typeof t?t:t.hasOwnProperty("red")?Ve.transform(t):Me.transform(t)},ke=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;const Fe=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function Ce(t){const e=t.toString(),n=[],s={color:[],number:[],var:[]},i=[];let r=0;const o=e.replace(Fe,t=>(Pe.test(t)?(s.color.push(r),i.push("color"),n.push(Pe.parse(t))):t.startsWith("var(")?(s.var.push(r),i.push("var"),n.push(t)):(s.number.push(r),i.push("number"),n.push(parseFloat(t))),++r,"${}")).split("${}");return{values:n,split:o,indexes:s,types:i}}function Ee(t){return Ce(t).values}function Oe(t){const{split:e,types:n}=Ce(t),s=e.length;return t=>{let i="";for(let r=0;r<s;r++)if(i+=e[r],void 0!==t[r]){const e=n[r];i+="number"===e?ve(t[r]):"color"===e?Pe.transform(t[r]):t[r]}return i}}const Ie=t=>"number"==typeof t?0:t;const Re={test:function(t){var e,n;return isNaN(t)&&"string"==typeof t&&((null===(e=t.match(we))||void 0===e?void 0:e.length)||0)+((null===(n=t.match(ke))||void 0===n?void 0:n.length)||0)>0},parse:Ee,createTransformer:Oe,getAnimatableNone:function(t){const e=Ee(t);return Oe(t)(e.map(Ie))}},Be=new Set(["brightness","contrast","saturate","opacity"]);function De(t){const[e,n]=t.slice(0,-1).split("(");if("drop-shadow"===e)return t;const[s]=n.match(we)||[];if(!s)return t;const i=n.replace(s,"");let r=Be.has(e)?1:0;return s!==n&&(r*=100),e+"("+r+i+")"}const Le=/\b([a-z-]*)\(.*?\)/gu,We={...Re,getAnimatableNone:t=>{const e=t.match(Le);return e?e.map(De).join(" "):t}},Ne={borderWidth:Jt,borderTopWidth:Jt,borderRightWidth:Jt,borderBottomWidth:Jt,borderLeftWidth:Jt,borderRadius:Jt,radius:Jt,borderTopLeftRadius:Jt,borderTopRightRadius:Jt,borderBottomRightRadius:Jt,borderBottomLeftRadius:Jt,width:Jt,maxWidth:Jt,height:Jt,maxHeight:Jt,top:Jt,right:Jt,bottom:Jt,left:Jt,padding:Jt,paddingTop:Jt,paddingRight:Jt,paddingBottom:Jt,paddingLeft:Jt,margin:Jt,marginTop:Jt,marginRight:Jt,marginBottom:Jt,marginLeft:Jt,backgroundPositionX:Jt,backgroundPositionY:Jt},Ke={rotate:Zt,rotateX:Zt,rotateY:Zt,rotateZ:Zt,scale:Xt,scaleX:Xt,scaleY:Xt,scaleZ:Xt,skew:Zt,skewX:Zt,skewY:Zt,distance:Jt,translateX:Jt,translateY:Jt,translateZ:Jt,x:Jt,y:Jt,z:Jt,perspective:Jt,transformPerspective:Jt,opacity:qt,originX:ee,originY:ee,originZ:Jt},je={...Yt,transform:Math.round},ze={...Ne,...Ke,zIndex:je,size:Jt,fillOpacity:qt,strokeOpacity:qt,numOctaves:je},$e={...ze,color:Pe,backgroundColor:Pe,outlineColor:Pe,fill:Pe,stroke:Pe,borderColor:Pe,borderTopColor:Pe,borderRightColor:Pe,borderBottomColor:Pe,borderLeftColor:Pe,filter:We,WebkitFilter:We},He=t=>$e[t];function Ue(t,e){let n=He(t);return n!==We&&(n=Re),n.getAnimatableNone?n.getAnimatableNone(e):void 0}const Ye=new Set(["auto","none","0"]);class qe extends ye{constructor(t,e,n,s,i){super(t,e,n,s,i,!0)}readKeyframes(){const{unresolvedKeyframes:t,element:e,name:n}=this;if(!e||!e.current)return;super.readKeyframes();for(let n=0;n<t.length;n++){let s=t[n];if("string"==typeof s&&(s=s.trim(),zt(s))){const i=Ut(s,e.current);void 0!==i&&(t[n]=i),n===t.length-1&&(this.finalKeyframe=s)}}if(this.resolveNoneKeyframes(),!ne.has(n)||2!==t.length)return;const[s,i]=t,r=he(s),o=he(i);if(r!==o)if(se(r)&&se(o))for(let e=0;e<t.length;e++){const n=t[e];"string"==typeof n&&(t[e]=parseFloat(n))}else this.needsMeasurement=!0}resolveNoneKeyframes(){const{unresolvedKeyframes:t,name:e}=this,n=[];for(let e=0;e<t.length;e++)("number"==typeof(s=t[e])?0===s:null===s||"none"===s||"0"===s||Lt(s))&&n.push(e);var s;n.length&&function(t,e,n){let s=0,i=void 0;for(;s<t.length&&!i;){const e=t[s];"string"==typeof e&&!Ye.has(e)&&Ce(e).values.length&&(i=t[s]),s++}if(i&&n)for(const s of e)t[s]=Ue(n,i)}(t,n,e)}measureInitialState(){const{element:t,unresolvedKeyframes:e,name:n}=this;if(!t||!t.current)return;"height"===n&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=le[n](t.measureViewportBox(),window.getComputedStyle(t.current)),e[0]=this.measuredOrigin;const s=e[e.length-1];void 0!==s&&t.getValue(n,s).jump(s,!1)}measureEndState(){var t;const{element:e,name:n,unresolvedKeyframes:s}=this;if(!e||!e.current)return;const i=e.getValue(n);i&&i.jump(this.measuredOrigin,!1);const r=s.length-1,o=s[r];s[r]=le[n](e.measureViewportBox(),window.getComputedStyle(e.current)),null!==o&&void 0===this.finalKeyframe&&(this.finalKeyframe=o),(null===(t=this.removedTransforms)||void 0===t?void 0:t.length)&&this.removedTransforms.forEach(([t,n])=>{e.getValue(t).set(n)}),this.resolveNoneKeyframes()}}const Xe=(t,e)=>"zIndex"!==e&&(!("number"!=typeof t&&!Array.isArray(t))||!("string"!=typeof t||!Re.test(t)&&"0"!==t||t.startsWith("url(")));function Ge(t,e,n,s){const i=t[0];if(null===i)return!1;if("display"===e||"visibility"===e)return!0;const r=t[t.length-1],o=Xe(i,e),a=Xe(r,e);return!(!o||!a)&&(function(t){const e=t[0];if(1===t.length)return!0;for(let n=0;n<t.length;n++)if(t[n]!==e)return!0}(t)||("spring"===n||et(n))&&s)}class Ze{constructor({autoplay:t=!0,delay:e=0,type:n="keyframes",repeat:s=0,repeatDelay:i=0,repeatType:r="loop",...o}){this.isStopped=!1,this.hasAttemptedResolve=!1,this.createdAt=g.now(),this.options={autoplay:t,delay:e,type:n,repeat:s,repeatDelay:i,repeatType:r,...o},this.updateFinishedPromise()}calcStartTime(){return this.resolvedAt&&this.resolvedAt-this.createdAt>40?this.resolvedAt:this.createdAt}get resolved(){return this._resolved||this.hasAttemptedResolve||(ge(),me()),this._resolved}onKeyframesResolved(t,e){this.resolvedAt=g.now(),this.hasAttemptedResolve=!0;const{name:n,type:s,velocity:i,delay:r,onComplete:o,onUpdate:a,isGenerator:l}=this.options;if(!l&&!Ge(t,n,s,i)){if(!r)return null==a||a(At(t,this.options,e)),null==o||o(),void this.resolveFinishedPromise();this.options.duration=0}const u=this.initPlayback(t,e);!1!==u&&(this._resolved={keyframes:t,finalKeyframe:e,...u},this.onPostResolved())}onPostResolved(){}then(t,e){return this.currentFinishedPromise.then(t,e)}flatten(){this.options.type="keyframes",this.options.ease="linear"}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}}function _e({keyframes:t,velocity:e=0,power:n=.8,timeConstant:s=325,bounceDamping:i=10,bounceStiffness:r=500,modifyTarget:o,min:a,max:l,restDelta:u=.5,restSpeed:c}){const h=t[0],d={done:!1,value:h},p=t=>void 0===a?l:void 0===l||Math.abs(a-t)<Math.abs(l-t)?a:l;let f=n*e;const m=h+f,g=void 0===o?m:o(m);g!==m&&(f=g-h);const y=t=>-f*Math.exp(-t/s),v=t=>g+y(t),w=t=>{const e=y(t),n=v(t);d.done=Math.abs(e)<=u,d.value=d.done?g:n};let b,T;const x=t=>{var e;(e=d.value,void 0!==a&&e<a||void 0!==l&&e>l)&&(b=t,T=q({keyframes:[d.value,p(d.value)],velocity:M(v,t,d.value),damping:i,stiffness:r,restDelta:u,restSpeed:c}))};return x(0),{calculatedDuration:null,next:t=>{let e=!1;return T||void 0!==b||(e=!0,w(t),x(t)),void 0!==b&&t>=b?T.next(t-b):(!e&&w(t),d)}}}const Je=Pt(.42,0,1,1),Qe=Pt(0,0,.58,1),tn=Pt(.42,0,.58,1),en=t=>Array.isArray(t)&&"number"==typeof t[0],nn={linear:e,easeIn:Je,easeInOut:tn,easeOut:Qe,circIn:Rt,circInOut:Dt,circOut:Bt,backIn:Et,backInOut:Ot,backOut:Ct,anticipate:It},sn=t=>{if(en(t)){n(4===t.length);const[e,s,i,r]=t;return Pt(e,s,i,r)}return"string"==typeof t?nn[t]:t},rn=(t,e)=>n=>e(t(n)),on=(...t)=>t.reduce(rn);function an(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+(e-t)*(2/3-n)*6:t}function ln(t,e){return n=>n>0?e:t}const un=(t,e,n)=>{const s=t*t,i=n*(e*e-s)+s;return i<0?0:Math.sqrt(i)},cn=[Ae,Ve,Me];function hn(t){const e=(n=t,cn.find(t=>t.test(n)));var n;if(!Boolean(e))return!1;let s=e.parse(t);return e===Me&&(s=function({hue:t,saturation:e,lightness:n,alpha:s}){t/=360,n/=100;let i=0,r=0,o=0;if(e/=100){const s=n<.5?n*(1+e):n+e-n*e,a=2*n-s;i=an(a,s,t+1/3),r=an(a,s,t),o=an(a,s,t-1/3)}else i=r=o=n;return{red:Math.round(255*i),green:Math.round(255*r),blue:Math.round(255*o),alpha:s}}(s)),s}const dn=(t,e)=>{const n=hn(t),s=hn(e);if(!n||!s)return ln(t,e);const i={...n};return t=>(i.red=un(n.red,s.red,t),i.green=un(n.green,s.green,t),i.blue=un(n.blue,s.blue,t),i.alpha=G(n.alpha,s.alpha,t),Ve.transform(i))},pn=new Set(["none","hidden"]);function fn(t,e){return n=>G(t,e,n)}function mn(t){return"number"==typeof t?fn:"string"==typeof t?zt(t)?ln:Pe.test(t)?dn:vn:Array.isArray(t)?gn:"object"==typeof t?Pe.test(t)?dn:yn:ln}function gn(t,e){const n=[...t],s=n.length,i=t.map((t,n)=>mn(t)(t,e[n]));return t=>{for(let e=0;e<s;e++)n[e]=i[e](t);return n}}function yn(t,e){const n={...t,...e},s={};for(const i in n)void 0!==t[i]&&void 0!==e[i]&&(s[i]=mn(t[i])(t[i],e[i]));return t=>{for(const e in s)n[e]=s[e](t);return n}}const vn=(t,e)=>{const n=Re.createTransformer(e),s=Ce(t),i=Ce(e);return s.indexes.var.length===i.indexes.var.length&&s.indexes.color.length===i.indexes.color.length&&s.indexes.number.length>=i.indexes.number.length?pn.has(t)&&!i.values.length||pn.has(e)&&!s.values.length?function(t,e){return pn.has(t)?n=>n<=0?t:e:n=>n>=1?e:t}(t,e):on(gn(function(t,e){var n;const s=[],i={color:0,var:0,number:0};for(let r=0;r<e.values.length;r++){const o=e.types[r],a=t.indexes[o][i[o]],l=null!==(n=t.values[a])&&void 0!==n?n:0;s[r]=l,i[o]++}return s}(s,i),i.values),n):ln(t,e)};function wn(t,e,n){if("number"==typeof t&&"number"==typeof e&&"number"==typeof n)return G(t,e,n);return mn(t)(t,e)}function bn(t,s,{clamp:i=!0,ease:r,mixer:o}={}){const a=t.length;if(n(a===s.length),1===a)return()=>s[0];if(2===a&&t[0]===t[1])return()=>s[1];t[0]>t[a-1]&&(t=[...t].reverse(),s=[...s].reverse());const l=function(t,n,s){const i=[],r=s||wn,o=t.length-1;for(let s=0;s<o;s++){let o=r(t[s],t[s+1]);if(n){const t=Array.isArray(n)?n[s]||e:n;o=on(t,o)}i.push(o)}return i}(s,r,o),u=l.length,c=e=>{let n=0;if(u>1)for(;n<t.length-2&&!(e<t[n+1]);n++);const s=x(t[n],t[n+1],e);return l[n](s)};return i?e=>c(P(t[0],t[a-1],e)):c}function Tn({duration:t=300,keyframes:e,times:n,ease:s="easeInOut"}){const i=it(s)?s.map(sn):sn(s),r={done:!1,value:e[0]},o=bn(function(t,e){return t.map(t=>t*e)}(n&&n.length===e.length?n:_(e),t),e,{ease:Array.isArray(i)?i:(a=e,l=i,a.map(()=>l||tn).splice(0,a.length-1))});var a,l;return{calculatedDuration:t,next:e=>(r.value=o(e),r.done=e>=t,r)}}const xn=t=>{const e=({timestamp:e})=>t(e);return{start:()=>a.update(e,!0),stop:()=>l(e),now:()=>u.isProcessing?u.timestamp:g.now()}},Sn={decay:_e,inertia:_e,tween:Tn,keyframes:Tn,spring:q},Vn=t=>t/100;class An extends Ze{constructor(t){super(t),this.holdTime=null,this.cancelTime=null,this.currentTime=0,this.playbackSpeed=1,this.pendingPlayState="running",this.startTime=null,this.state="idle",this.stop=()=>{if(this.resolver.cancel(),this.isStopped=!0,"idle"===this.state)return;this.teardown();const{onStop:t}=this.options;t&&t()};const{name:e,motionValue:n,element:s,keyframes:i}=this.options,r=(null==s?void 0:s.KeyframeResolver)||ye;this.resolver=new r(i,(t,e)=>this.onKeyframesResolved(t,e),e,n,s),this.resolver.scheduleResolve()}flatten(){super.flatten(),this._resolved&&Object.assign(this._resolved,this.initPlayback(this._resolved.keyframes))}initPlayback(t){const{type:e="keyframes",repeat:n=0,repeatDelay:s=0,repeatType:i,velocity:r=0}=this.options,o=et(e)?e:Sn[e]||Tn;let a,l;o!==Tn&&"number"!=typeof t[0]&&(a=on(Vn,wn(t[0],t[1])),t=[0,100]);const u=o({...this.options,keyframes:t});"mirror"===i&&(l=o({...this.options,keyframes:[...t].reverse(),velocity:-r})),null===u.calculatedDuration&&(u.calculatedDuration=$(u));const{calculatedDuration:c}=u,h=c+s;return{generator:u,mirroredGenerator:l,mapPercentToKeyframes:a,calculatedDuration:c,resolvedDuration:h,totalDuration:h*(n+1)-s}}onPostResolved(){const{autoplay:t=!0}=this.options;this.play(),"paused"!==this.pendingPlayState&&t?this.state=this.pendingPlayState:this.pause()}tick(t,e=!1){const{resolved:n}=this;if(!n){const{keyframes:t}=this.options;return{done:!0,value:t[t.length-1]}}const{finalKeyframe:s,generator:i,mirroredGenerator:r,mapPercentToKeyframes:o,keyframes:a,calculatedDuration:l,totalDuration:u,resolvedDuration:c}=n;if(null===this.startTime)return i.next(0);const{delay:h,repeat:d,repeatType:p,repeatDelay:f,onUpdate:m}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,t):this.speed<0&&(this.startTime=Math.min(t-u/this.speed,this.startTime)),e?this.currentTime=t:null!==this.holdTime?this.currentTime=this.holdTime:this.currentTime=Math.round(t-this.startTime)*this.speed;const g=this.currentTime-h*(this.speed>=0?1:-1),y=this.speed>=0?g<0:g>u;this.currentTime=Math.max(g,0),"finished"===this.state&&null===this.holdTime&&(this.currentTime=u);let v=this.currentTime,w=i;if(d){const t=Math.min(this.currentTime,u)/c;let e=Math.floor(t),n=t%1;!n&&t>=1&&(n=1),1===n&&e--,e=Math.min(e,d+1);Boolean(e%2)&&("reverse"===p?(n=1-n,f&&(n-=f/c)):"mirror"===p&&(w=r)),v=P(0,1,n)*c}const b=y?{done:!1,value:a[0]}:w.next(v);o&&(b.value=o(b.value));let{done:T}=b;y||null===l||(T=this.speed>=0?this.currentTime>=u:this.currentTime<=0);const x=null===this.holdTime&&("finished"===this.state||"running"===this.state&&T);return x&&void 0!==s&&(b.value=At(a,this.options,s)),m&&m(b.value),x&&this.finish(),b}get duration(){const{resolved:t}=this;return t?A(t.calculatedDuration):0}get time(){return A(this.currentTime)}set time(t){t=V(t),this.currentTime=t,null!==this.holdTime||0===this.speed?this.holdTime=t:this.driver&&(this.startTime=this.driver.now()-t/this.speed)}get speed(){return this.playbackSpeed}set speed(t){const e=this.playbackSpeed!==t;this.playbackSpeed=t,e&&(this.time=A(this.currentTime))}play(){if(this.resolver.isScheduled||this.resolver.resume(),!this._resolved)return void(this.pendingPlayState="running");if(this.isStopped)return;const{driver:t=xn,onPlay:e,startTime:n}=this.options;this.driver||(this.driver=t(t=>this.tick(t))),e&&e();const s=this.driver.now();null!==this.holdTime?this.startTime=s-this.holdTime:this.startTime?"finished"===this.state&&(this.startTime=s):this.startTime=null!=n?n:this.calcStartTime(),"finished"===this.state&&this.updateFinishedPromise(),this.cancelTime=this.startTime,this.holdTime=null,this.state="running",this.driver.start()}pause(){var t;this._resolved?(this.state="paused",this.holdTime=null!==(t=this.currentTime)&&void 0!==t?t:0):this.pendingPlayState="paused"}complete(){"running"!==this.state&&this.play(),this.pendingPlayState=this.state="finished",this.holdTime=null}finish(){this.teardown(),this.state="finished";const{onComplete:t}=this.options;t&&t()}cancel(){null!==this.cancelTime&&this.tick(this.cancelTime),this.teardown(),this.updateFinishedPromise()}teardown(){this.state="idle",this.stopDriver(),this.resolveFinishedPromise(),this.updateFinishedPromise(),this.startTime=this.cancelTime=null,this.resolver.cancel()}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(t){return this.startTime=0,this.tick(t,!0)}}const Mn=new Set(["opacity","clipPath","filter","transform"]),Pn={linearEasing:void 0};function kn(t,e){const n=w(t);return()=>{var t;return null!==(t=Pn[e])&&void 0!==t?t:n()}}const Fn=kn(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch(t){return!1}return!0},"linearEasing");function Cn(t){return Boolean("function"==typeof t&&Fn()||!t||"string"==typeof t&&(t in On||Fn())||en(t)||Array.isArray(t)&&t.every(Cn))}const En=([t,e,n,s])=>`cubic-bezier(${t}, ${e}, ${n}, ${s})`,On={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:En([0,.65,.55,1]),circOut:En([.55,0,1,.45]),backIn:En([.31,.01,.66,-.59]),backOut:En([.33,1.53,.69,.99])};function In(t,e,n,{delay:s=0,duration:i=300,repeat:r=0,repeatType:o="loop",ease:a="easeInOut",times:l}={}){const u={[e]:n};l&&(u.offset=l);const c=function t(e,n){return e?"function"==typeof e&&Fn()?S(e,n):en(e)?En(e):Array.isArray(e)?e.map(e=>t(e,n)||On.easeOut):On[e]:void 0}(a,i);return Array.isArray(c)&&(u.easing=c),t.animate(u,{delay:s,duration:i,easing:Array.isArray(c)?"linear":c,fill:"both",iterations:r+1,direction:"reverse"===o?"alternate":"normal"})}function Rn(t,e){t.timeline=e,t.onfinish=null}const Bn=w(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));const Dn={anticipate:It,backInOut:Ot,circInOut:Dt};class Ln extends Ze{constructor(t){super(t);const{name:e,motionValue:n,element:s,keyframes:i}=this.options;this.resolver=new qe(i,(t,e)=>this.onKeyframesResolved(t,e),e,n,s),this.resolver.scheduleResolve()}initPlayback(t,e){var n;let{duration:s=300,times:i,ease:r,type:o,motionValue:a,name:l,startTime:u}=this.options;if(!(null===(n=a.owner)||void 0===n?void 0:n.current))return!1;var c;if("string"==typeof r&&Fn()&&r in Dn&&(r=Dn[r]),et((c=this.options).type)||"spring"===c.type||!Cn(c.ease)){const{onComplete:e,onUpdate:n,motionValue:a,element:l,...u}=this.options,c=function(t,e){const n=new An({...e,keyframes:t,repeat:0,delay:0,isGenerator:!0});let s={done:!1,value:t[0]};const i=[];let r=0;for(;!s.done&&r<2e4;)s=n.sample(r),i.push(s.value),r+=10;return{times:void 0,keyframes:i,duration:r-10,ease:"linear"}}(t,u);1===(t=c.keyframes).length&&(t[1]=t[0]),s=c.duration,i=c.times,r=c.ease,o="keyframes"}const h=In(a.owner.current,l,t,{...this.options,duration:s,times:i,ease:r});return h.startTime=null!=u?u:this.calcStartTime(),this.pendingTimeline?(Rn(h,this.pendingTimeline),this.pendingTimeline=void 0):h.onfinish=()=>{const{onComplete:n}=this.options;a.set(At(t,this.options,e)),n&&n(),this.cancel(),this.resolveFinishedPromise()},{animation:h,duration:s,times:i,type:o,ease:r,keyframes:t}}get duration(){const{resolved:t}=this;if(!t)return 0;const{duration:e}=t;return A(e)}get time(){const{resolved:t}=this;if(!t)return 0;const{animation:e}=t;return A(e.currentTime||0)}set time(t){const{resolved:e}=this;if(!e)return;const{animation:n}=e;n.currentTime=V(t)}get speed(){const{resolved:t}=this;if(!t)return 1;const{animation:e}=t;return e.playbackRate}set speed(t){const{resolved:e}=this;if(!e)return;const{animation:n}=e;n.playbackRate=t}get state(){const{resolved:t}=this;if(!t)return"idle";const{animation:e}=t;return e.playState}get startTime(){const{resolved:t}=this;if(!t)return null;const{animation:e}=t;return e.startTime}attachTimeline(t){if(this._resolved){const{resolved:n}=this;if(!n)return e;const{animation:s}=n;Rn(s,t)}else this.pendingTimeline=t;return e}play(){if(this.isStopped)return;const{resolved:t}=this;if(!t)return;const{animation:e}=t;"finished"===e.playState&&this.updateFinishedPromise(),e.play()}pause(){const{resolved:t}=this;if(!t)return;const{animation:e}=t;e.pause()}stop(){if(this.resolver.cancel(),this.isStopped=!0,"idle"===this.state)return;this.resolveFinishedPromise(),this.updateFinishedPromise();const{resolved:t}=this;if(!t)return;const{animation:e,keyframes:n,duration:s,type:i,ease:r,times:o}=t;if("idle"===e.playState||"finished"===e.playState)return;if(this.time){const{motionValue:t,onUpdate:e,onComplete:a,element:l,...u}=this.options,c=new An({...u,keyframes:n,duration:s,type:i,ease:r,times:o,isGenerator:!0}),h=V(this.time);t.setWithVelocity(c.sample(h-10).value,c.sample(h).value,10)}const{onStop:a}=this.options;a&&a(),this.cancel()}complete(){const{resolved:t}=this;t&&t.animation.finish()}cancel(){const{resolved:t}=this;t&&t.animation.cancel()}static supports(t){const{motionValue:e,name:n,repeatDelay:s,repeatType:i,damping:r,type:o}=t;return Bn()&&n&&Mn.has(n)&&e&&e.owner&&e.owner.current instanceof HTMLElement&&!e.owner.getProps().onUpdate&&!s&&"mirror"!==i&&0!==r&&"inertia"!==o}}const Wn=(t,e,n,s={},i,r)=>o=>{const l=St(s,t)||{},u=l.delay||s.delay||0;let{elapsed:c=0}=s;c-=V(u);let h={keyframes:Array.isArray(n)?n:[null,n],ease:"easeOut",velocity:e.getVelocity(),...l,delay:-c,onUpdate:t=>{e.set(t),l.onUpdate&&l.onUpdate(t)},onComplete:()=>{o(),l.onComplete&&l.onComplete()},name:t,motionValue:e,element:r?void 0:i};(function({when:t,delay:e,delayChildren:n,staggerChildren:s,staggerDirection:i,repeat:r,repeatType:o,repeatDelay:a,from:l,elapsed:u,...c}){return!!Object.keys(c).length})(l)||(h={...h,...xt(t,h)}),h.duration&&(h.duration=V(h.duration)),h.repeatDelay&&(h.repeatDelay=V(h.repeatDelay)),void 0!==h.from&&(h.keyframes[0]=h.from);let d=!1;if((!1===h.type||0===h.duration&&!h.repeatDelay)&&(h.duration=0,0===h.delay&&(d=!0)),d&&!r&&void 0!==e.get()){const t=At(h.keyframes,l);if(void 0!==t)return a.update(()=>{h.onUpdate(t),h.onComplete()}),new T([])}return!r&&Ln.supports(h)?new Ln(h):new An(h)},Nn=t=>(t=>Array.isArray(t))(t)?t[t.length-1]||0:t;function Kn(t){const e=[{},{}];return null==t||t.values.forEach((t,n)=>{e[0][n]=t.get(),e[1][n]=t.getVelocity()}),e}function jn(t,e,n,s){if("function"==typeof e){const[i,r]=Kn(s);e=e(void 0!==n?n:t.custom,i,r)}if("string"==typeof e&&(e=t.variants&&t.variants[e]),"function"==typeof e){const[i,r]=Kn(s);e=e(void 0!==n?n:t.custom,i,r)}return e}function zn(t,e,n){t.hasValue(e)?t.getValue(e).set(n):t.addValue(e,v(n))}function $n(t,e){const n=function(t,e,n){const s=t.getProps();return jn(s,e,void 0!==n?n:s.custom,t)}(t,e);let{transitionEnd:s={},transition:i={},...r}=n||{};r={...r,...s};for(const e in r){zn(t,e,Nn(r[e]))}}const Hn=t=>t.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),Un="data-"+Hn("framerAppearId");function Yn(t){return t.props[Un]}function qn(t,e){const n=t.getValue("willChange");if(s=n,Boolean(J(s)&&s.add))return n.add(e);var s}function Xn({protectedKeys:t,needsAnimating:e},n){const s=t.hasOwnProperty(n)&&!0!==e[n];return e[n]=!1,s}function Gn(t,e,{delay:n=0,transitionOverride:s,type:i}={}){var r;let{transition:o=t.getDefaultTransition(),transitionEnd:l,...u}=e;s&&(o=s);const c=[],h=i&&t.animationState&&t.animationState.getState()[i];for(const e in u){const s=t.getValue(e,null!==(r=t.latestValues[e])&&void 0!==r?r:null),i=u[e];if(void 0===i||h&&Xn(h,e))continue;const l={delay:n,...St(o||{},e)};let d=!1;if(window.MotionHandoffAnimation){const n=Yn(t);if(n){const t=window.MotionHandoffAnimation(n,e,a);null!==t&&(l.startTime=t,d=!0)}}qn(t,e),s.start(Wn(e,s,i,t.shouldReduceMotion&&vt.has(e)?{type:!1}:l,t,d));const p=s.animation;p&&c.push(p)}return l&&Promise.all(c).then(()=>{a.update(()=>{l&&$n(t,l)})}),c}const Zn={};function _n(t,{layout:e,layoutId:n}){return vt.has(t)||t.startsWith("origin")||(e||void 0!==n)&&(!!Zn[t]||"opacity"===t)}function Jn(t,e,n){var s;const{style:i}=t,r={};for(const o in i)(J(i[o])||e.style&&J(e.style[o])||_n(o,t)||void 0!==(null===(s=null==n?void 0:n.getValue(o))||void 0===s?void 0:s.liveStyle))&&(r[o]=i[o]);return r}const Qn="undefined"!=typeof window,ts={current:null},es={current:!1};const ns=["initial","animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"];function ss(t){return null!==(e=t.animate)&&"object"==typeof e&&"function"==typeof e.start||ns.some(e=>function(t){return"string"==typeof t||Array.isArray(t)}(t[e]));var e}const is={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},rs={};for(const t in is)rs[t]={isEnabled:e=>is[t].some(t=>!!e[t])};const os=[...ce,Pe,Re],as=()=>({x:{min:0,max:0},y:{min:0,max:0}}),ls=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class us{scrapeMotionValuesFromProps(t,e,n){return{}}constructor({parent:t,props:e,presenceContext:n,reducedMotionConfig:s,blockInitialAnimation:i,visualState:r},o={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=ye,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const t=g.now();this.renderScheduledAt<t&&(this.renderScheduledAt=t,a.render(this.render,!1,!0))};const{latestValues:l,renderState:u}=r;this.latestValues=l,this.baseTarget={...l},this.initialValues=e.initial?{...l}:{},this.renderState=u,this.parent=t,this.props=e,this.presenceContext=n,this.depth=t?t.depth+1:0,this.reducedMotionConfig=s,this.options=o,this.blockInitialAnimation=Boolean(i),this.isControllingVariants=ss(e),this.isVariantNode=function(t){return Boolean(ss(t)||t.variants)}(e),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=Boolean(t&&t.current);const{willChange:c,...h}=this.scrapeMotionValuesFromProps(e,{},this);for(const t in h){const e=h[t];void 0!==l[t]&&J(e)&&e.set(l[t],!1)}}mount(t){this.current=t,gt.set(t,this),this.projection&&!this.projection.instance&&this.projection.mount(t),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((t,e)=>this.bindToMotionValue(e,t)),es.current||function(){if(es.current=!0,Qn)if(window.matchMedia){const t=window.matchMedia("(prefers-reduced-motion)"),e=()=>ts.current=t.matches;t.addListener(e),e()}else ts.current=!1}(),this.shouldReduceMotion="never"!==this.reducedMotionConfig&&("always"===this.reducedMotionConfig||ts.current),this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){gt.delete(this.current),this.projection&&this.projection.unmount(),l(this.notifyUpdate),l(this.render),this.valueSubscriptions.forEach(t=>t()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const t in this.events)this.events[t].clear();for(const t in this.features){const e=this.features[t];e&&(e.unmount(),e.isMounted=!1)}this.current=null}bindToMotionValue(t,e){this.valueSubscriptions.has(t)&&this.valueSubscriptions.get(t)();const n=vt.has(t),s=e.on("change",e=>{this.latestValues[t]=e,this.props.onUpdate&&a.preRender(this.notifyUpdate),n&&this.projection&&(this.projection.isTransformDirty=!0)}),i=e.on("renderRequest",this.scheduleRender);let r;window.MotionCheckAppearSync&&(r=window.MotionCheckAppearSync(this,t,e)),this.valueSubscriptions.set(t,()=>{s(),i(),r&&r(),e.owner&&e.stop()})}sortNodePosition(t){return this.current&&this.sortInstanceNodePosition&&this.type===t.type?this.sortInstanceNodePosition(this.current,t.current):0}updateFeatures(){let t="animation";for(t in rs){const e=rs[t];if(!e)continue;const{isEnabled:n,Feature:s}=e;if(!this.features[t]&&s&&n(this.props)&&(this.features[t]=new s(this)),this.features[t]){const e=this.features[t];e.isMounted?e.update():(e.mount(),e.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):{x:{min:0,max:0},y:{min:0,max:0}}}getStaticValue(t){return this.latestValues[t]}setStaticValue(t,e){this.latestValues[t]=e}update(t,e){(t.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=t,this.prevPresenceContext=this.presenceContext,this.presenceContext=e;for(let e=0;e<ls.length;e++){const n=ls[e];this.propEventSubscriptions[n]&&(this.propEventSubscriptions[n](),delete this.propEventSubscriptions[n]);const s=t["on"+n];s&&(this.propEventSubscriptions[n]=this.on(n,s))}this.prevMotionValues=function(t,e,n){for(const s in e){const i=e[s],r=n[s];if(J(i))t.addValue(s,i);else if(J(r))t.addValue(s,v(i,{owner:t}));else if(r!==i)if(t.hasValue(s)){const e=t.getValue(s);!0===e.liveStyle?e.jump(i):e.hasAnimated||e.set(i)}else{const e=t.getStaticValue(s);t.addValue(s,v(void 0!==e?e:i,{owner:t}))}}for(const s in n)void 0===e[s]&&t.removeValue(s);return e}(this,this.scrapeMotionValuesFromProps(t,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(t){return this.props.variants?this.props.variants[t]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(t){const e=this.getClosestVariantNode();if(e)return e.variantChildren&&e.variantChildren.add(t),()=>e.variantChildren.delete(t)}addValue(t,e){const n=this.values.get(t);e!==n&&(n&&this.removeValue(t),this.bindToMotionValue(t,e),this.values.set(t,e),this.latestValues[t]=e.get())}removeValue(t){this.values.delete(t);const e=this.valueSubscriptions.get(t);e&&(e(),this.valueSubscriptions.delete(t)),delete this.latestValues[t],this.removeValueFromRenderState(t,this.renderState)}hasValue(t){return this.values.has(t)}getValue(t,e){if(this.props.values&&this.props.values[t])return this.props.values[t];let n=this.values.get(t);return void 0===n&&void 0!==e&&(n=v(null===e?void 0:e,{owner:this}),this.addValue(t,n)),n}readValue(t,e){var n;let s=void 0===this.latestValues[t]&&this.current?null!==(n=this.getBaseTargetFromProps(this.props,t))&&void 0!==n?n:this.readValueFromInstance(this.current,t,this.options):this.latestValues[t];var i;return null!=s&&("string"==typeof s&&(Wt(s)||Lt(s))?s=parseFloat(s):(i=s,!os.find(ue(i))&&Re.test(e)&&(s=Ue(t,e))),this.setBaseTarget(t,J(s)?s.get():s)),J(s)?s.get():s}setBaseTarget(t,e){this.baseTarget[t]=e}getBaseTarget(t){var e;const{initial:n}=this.props;let s;if("string"==typeof n||"object"==typeof n){const i=jn(this.props,n,null===(e=this.presenceContext)||void 0===e?void 0:e.custom);i&&(s=i[t])}if(n&&void 0!==s)return s;const i=this.getBaseTargetFromProps(this.props,t);return void 0===i||J(i)?void 0!==this.initialValues[t]&&void 0===s?void 0:this.baseTarget[t]:i}on(t,e){return this.events[t]||(this.events[t]=new d),this.events[t].add(e)}notify(t,...e){this.events[t]&&this.events[t].notify(...e)}}class cs extends us{constructor(){super(...arguments),this.KeyframeResolver=qe}sortInstanceNodePosition(t,e){return 2&t.compareDocumentPosition(e)?1:-1}getBaseTargetFromProps(t,e){return t.style?t.style[e]:void 0}removeValueFromRenderState(t,{vars:e,style:n}){delete e[t],delete n[t]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:t}=this.props;J(t)&&(this.childSubscription=t.on("change",t=>{this.current&&(this.current.textContent=""+t)}))}}const hs=(t,e)=>e&&"number"==typeof t?e.transform(t):t,ds={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},ps=yt.length;function fs(t,e,n){const{style:s,vars:i,transformOrigin:r}=t;let o=!1,a=!1;for(const t in e){const n=e[t];if(vt.has(t))o=!0;else if(Kt(t))i[t]=n;else{const e=hs(n,ze[t]);t.startsWith("origin")?(a=!0,r[t]=e):s[t]=e}}if(e.transform||(o||n?s.transform=function(t,e,n){let s="",i=!0;for(let r=0;r<ps;r++){const o=yt[r],a=t[o];if(void 0===a)continue;let l=!0;if(l="number"==typeof a?a===(o.startsWith("scale")?1:0):0===parseFloat(a),!l||n){const t=hs(a,ze[o]);if(!l){i=!1;s+=`${ds[o]||o}(${t}) `}n&&(e[o]=t)}}return s=s.trim(),n?s=n(e,i?"":s):i&&(s="none"),s}(e,t.transform,n):s.transform&&(s.transform="none")),a){const{originX:t="50%",originY:e="50%",originZ:n=0}=r;s.transformOrigin=`${t} ${e} ${n}`}}function ms(t,e,n){return"string"==typeof t?t:Jt.transform(e+n*t)}const gs={offset:"stroke-dashoffset",array:"stroke-dasharray"},ys={offset:"strokeDashoffset",array:"strokeDasharray"};function vs(t,{attrX:e,attrY:n,attrScale:s,originX:i,originY:r,pathLength:o,pathSpacing:a=1,pathOffset:l=0,...u},c,h){if(fs(t,u,h),c)return void(t.style.viewBox&&(t.attrs.viewBox=t.style.viewBox));t.attrs=t.style,t.style={};const{attrs:d,style:p,dimensions:f}=t;d.transform&&(f&&(p.transform=d.transform),delete d.transform),f&&(void 0!==i||void 0!==r||p.transform)&&(p.transformOrigin=function(t,e,n){return`${ms(e,t.x,t.width)} ${ms(n,t.y,t.height)}`}(f,void 0!==i?i:.5,void 0!==r?r:.5)),void 0!==e&&(d.x=e),void 0!==n&&(d.y=n),void 0!==s&&(d.scale=s),void 0!==o&&function(t,e,n=1,s=0,i=!0){t.pathLength=1;const r=i?gs:ys;t[r.offset]=Jt.transform(-s);const o=Jt.transform(e),a=Jt.transform(n);t[r.array]=`${o} ${a}`}(d,o,a,l,!1)}const ws=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function bs(t,{style:e,vars:n},s,i){Object.assign(t.style,e,i&&i.getProjectionStyles(s));for(const e in n)t.style.setProperty(e,n[e])}class Ts extends cs{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=as}getBaseTargetFromProps(t,e){return t[e]}readValueFromInstance(t,e){if(vt.has(e)){const t=He(e);return t&&t.default||0}return e=ws.has(e)?e:Hn(e),t.getAttribute(e)}scrapeMotionValuesFromProps(t,e,n){return function(t,e,n){const s=Jn(t,e,n);for(const n in t)if(J(t[n])||J(e[n])){s[-1!==yt.indexOf(n)?"attr"+n.charAt(0).toUpperCase()+n.substring(1):n]=t[n]}return s}(t,e,n)}build(t,e,n){vs(t,e,this.isSVGTag,n.transformTemplate)}renderInstance(t,e,n,s){!function(t,e,n,s){bs(t,e,void 0,s);for(const n in e.attrs)t.setAttribute(ws.has(n)?n:Hn(n),e.attrs[n])}(t,e,0,s)}mount(t){var e;this.isSVGTag="string"==typeof(e=t.tagName)&&"svg"===e.toLowerCase(),super.mount(t)}}class xs extends cs{constructor(){super(...arguments),this.type="html",this.renderInstance=bs}readValueFromInstance(t,e){if(vt.has(e)){const t=He(e);return t&&t.default||0}{const s=(n=t,window.getComputedStyle(n)),i=(Kt(e)?s.getPropertyValue(e):s[e])||0;return"string"==typeof i?i.trim():i}var n}measureInstanceViewportBox(t,{transformPagePoint:e}){return function(t,e){return function({top:t,left:e,right:n,bottom:s}){return{x:{min:e,max:n},y:{min:t,max:s}}}(function(t,e){if(!e)return t;const n=e({x:t.left,y:t.top}),s=e({x:t.right,y:t.bottom});return{top:n.y,left:n.x,bottom:s.y,right:s.x}}(t.getBoundingClientRect(),e))}(t,e)}build(t,e,n){fs(t,e,n.transformTemplate)}scrapeMotionValuesFromProps(t,e,n){return Jn(t,e,n)}}class Ss extends us{constructor(){super(...arguments),this.type="object"}readValueFromInstance(t,e){if(function(t,e){return t in e}(e,t)){const n=t[e];if("string"==typeof n||"number"==typeof n)return n}}getBaseTargetFromProps(){}removeValueFromRenderState(t,e){delete e.output[t]}measureInstanceViewportBox(){return{x:{min:0,max:0},y:{min:0,max:0}}}build(t,e){Object.assign(t.output,e)}renderInstance(t,{output:e}){Object.assign(t,e)}sortInstanceNodePosition(){return 0}}function Vs(t){const e={presenceContext:null,props:{},visualState:{renderState:{transform:{},transformOrigin:{},style:{},vars:{},attrs:{}},latestValues:{}}},n=function(t){return t instanceof SVGElement&&"svg"!==t.tagName}(t)?new Ts(e):new xs(e);n.mount(t),gt.set(t,n)}function As(t){const e=new Ss({presenceContext:null,props:{},visualState:{renderState:{output:{}},latestValues:{}}});e.mount(t),gt.set(t,e)}function Ms(t,e,n,s){const i=[];if(function(t,e){return J(t)||"number"==typeof t||"string"==typeof t&&!Q(e)}(t,e))i.push(function(t,e,n){const s=J(t)?t:v(t);return s.start(Wn("",s,e,n)),s.animation}(t,Q(e)&&e.default||e,n&&n.default||n));else{const r=tt(t,e,s),o=r.length;for(let t=0;t<o;t++){const s=r[t],a=s instanceof Element?Vs:As;gt.has(s)||a(s);const l=gt.get(s),u={...n};"delay"in u&&"function"==typeof u.delay&&(u.delay=u.delay(t,o)),i.push(...Gn(l,{...e,transition:u},{}))}}return i}function Ps(t,e,n){const s=[];return function(t,{defaultTransition:e={},...n}={},s,i){const r=e.duration||.3,o=new Map,a=new Map,l={},u=new Map;let c=0,h=0,d=0;for(let n=0;n<t.length;n++){const o=t[n];if("string"==typeof o){u.set(o,h);continue}if(!Array.isArray(o)){u.set(o.name,nt(h,o.at,c,u));continue}let[p,f,m={}]=o;void 0!==m.at&&(h=nt(h,m.at,c,u));let g=0;const y=(t,n,s,o=0,a=0)=>{const l=dt(t),{delay:u=0,times:c=_(l),type:p="keyframes",repeat:f,repeatType:m,repeatDelay:y=0,...v}=n;let{ease:w=e.ease||"easeOut",duration:b}=n;const T="function"==typeof u?u(o,a):u,x=l.length,S=et(p)?p:null==i?void 0:i[p];if(x<=2&&S){let t=100;if(2===x&&mt(l)){const e=l[1]-l[0];t=Math.abs(e)}const e={...v};void 0!==b&&(e.duration=V(b));const n=X(e,t,S);w=n.ease,b=n.duration}null!=b||(b=r);const A=h+T;1===c.length&&0===c[0]&&(c[1]=1);const M=c.length-l.length;if(M>0&&Z(c,M),1===l.length&&l.unshift(null),f){b=ut(b,f);const t=[...l],e=[...c];w=Array.isArray(w)?[...w]:[w];const n=[...w];for(let s=0;s<f;s++){l.push(...t);for(let i=0;i<t.length;i++)c.push(e[i]+(s+1)),w.push(0===i?"linear":rt(n,i-1))}lt(c,f)}const P=A+b;ot(s,l,w,c,A,P),g=Math.max(T+b,g),d=Math.max(P,d)};if(J(p)){y(f,m,ht("default",ct(p,a)))}else{const t=tt(p,f,s,l),e=t.length;for(let n=0;n<e;n++){f=f,m=m;const s=ct(t[n],a);for(const t in f)y(f[t],pt(m,t),ht(t,s),n,e)}}c=h,h+=g}return a.forEach((t,s)=>{for(const i in t){const r=t[i];r.sort(at);const a=[],l=[],u=[];for(let t=0;t<r.length;t++){const{at:e,value:n,easing:s}=r[t];a.push(n),l.push(x(0,d,e)),u.push(s||"easeOut")}0!==l[0]&&(l.unshift(0),a.unshift(a[0]),u.unshift("easeInOut")),1!==l[l.length-1]&&(l.push(1),a.push(null)),o.has(s)||o.set(s,{keyframes:{},transition:{}});const c=o.get(s);c.keyframes[i]=a,c.transition[i]={...e,duration:d,ease:u,times:l,...n}}}),o}(t,e,n,{spring:q}).forEach(({keyframes:t,transition:e},n)=>{s.push(...Ms(n,t,e))}),s}function ks(t){return function(e,n,s){let i=[];var r;r=e,i=Array.isArray(r)&&Array.isArray(r[0])?Ps(e,n,t):Ms(e,n,s,t);const o=new T(i);return t&&t.animations.push(o),o}}const Fs=ks();function Cs(t,e,n){t.style.setProperty("--"+e,n)}function Es(t,e,n){t.style[e]=n}const Os=w(()=>{try{document.createElement("div").animate({opacity:[1]})}catch(t){return!1}return!0}),Is=new WeakMap;function Rs(t){const e=Is.get(t)||new Map;return Is.set(t,e),Is.get(t)}class Bs{constructor(t,e,s,i){const r=e.startsWith("--");this.setValue=r?Cs:Es,this.options=i,this.updateFinishedPromise(),n("string"!=typeof i.type);const o=Rs(t).get(e);o&&o.stop();if(Array.isArray(s)||(s=[s]),function(t,e,n){for(let s=0;s<e.length;s++)null===e[s]&&(e[s]=0===s?n():e[s-1]),"number"==typeof e[s]&&Ne[t]&&(e[s]=Ne[t].transform(e[s]));!Os()&&e.length<2&&e.unshift(n())}(e,s,()=>e.startsWith("--")?t.style.getPropertyValue(e):window.getComputedStyle(t)[e]),et(i.type)){const t=X(i,100,i.type);i.ease=Fn()?t.ease:"easeOut",i.duration=V(t.duration),i.type="keyframes"}else i.ease=i.ease||"easeOut";this.removeAnimation=()=>{var n;return null===(n=Is.get(t))||void 0===n?void 0:n.delete(e)};const a=()=>{this.setValue(t,e,At(s,this.options)),this.cancel(),this.resolveFinishedPromise()};Bn()?(this.animation=In(t,e,s,i),!1===i.autoplay&&this.animation.pause(),this.animation.onfinish=a,this.pendingTimeline&&Rn(this.animation,this.pendingTimeline),Rs(t).set(e,this)):a()}get duration(){return A(this.options.duration||300)}get time(){var t;return this.animation?A((null===(t=this.animation)||void 0===t?void 0:t.currentTime)||0):0}set time(t){this.animation&&(this.animation.currentTime=V(t))}get speed(){return this.animation?this.animation.playbackRate:1}set speed(t){this.animation&&(this.animation.playbackRate=t)}get state(){return this.animation?this.animation.playState:"finished"}get startTime(){return this.animation?this.animation.startTime:null}flatten(){var t;this.animation&&(null===(t=this.animation.effect)||void 0===t||t.updateTiming({easing:"linear"}))}play(){"finished"===this.state&&this.updateFinishedPromise(),this.animation&&this.animation.play()}pause(){this.animation&&this.animation.pause()}stop(){this.animation&&"idle"!==this.state&&"finished"!==this.state&&(this.animation.commitStyles&&this.animation.commitStyles(),this.cancel())}complete(){this.animation&&this.animation.finish()}cancel(){this.removeAnimation();try{this.animation&&this.animation.cancel()}catch(t){}}then(t,e){return this.currentFinishedPromise.then(t,e)}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}attachTimeline(t){return this.animation?Rn(this.animation,t):this.pendingTimeline=t,e}}const Ds=(t=>function(e,n,s){return new T(function(t,e,n,s){const r=i(t,s),o=r.length,a=[];for(let t=0;t<o;t++){const s=r[t],i={...n};"function"==typeof i.delay&&(i.delay=i.delay(t,o));for(const t in e){const n=e[t],r={...St(i,t)};r.duration=r.duration?V(r.duration):r.duration,r.delay=V(r.delay||0),a.push(new Bs(s,t,n,r))}}return a}(e,n,s,t))})(),Ls=new WeakMap;let Ws;function Ns({target:t,contentRect:e,borderBoxSize:n}){var s;null===(s=Ls.get(t))||void 0===s||s.forEach(s=>{s({target:t,contentSize:e,get size(){return function(t,e){if(e){const{inlineSize:t,blockSize:n}=e[0];return{width:t,height:n}}return t instanceof SVGElement&&"getBBox"in t?t.getBBox():{width:t.offsetWidth,height:t.offsetHeight}}(t,n)}})})}function Ks(t){t.forEach(Ns)}function js(t,e){Ws||"undefined"!=typeof ResizeObserver&&(Ws=new ResizeObserver(Ks));const n=i(t);return n.forEach(t=>{let n=Ls.get(t);n||(n=new Set,Ls.set(t,n)),n.add(e),null==Ws||Ws.observe(t)}),()=>{n.forEach(t=>{const n=Ls.get(t);null==n||n.delete(e),(null==n?void 0:n.size)||null==Ws||Ws.unobserve(t)})}}const zs=new Set;let $s;function Hs(t){return zs.add(t),$s||($s=()=>{const t={width:window.innerWidth,height:window.innerHeight},e={target:window,size:t,contentSize:t};zs.forEach(t=>t(e))},window.addEventListener("resize",$s)),()=>{zs.delete(t),!zs.size&&$s&&($s=void 0)}}const Us={x:{length:"Width",position:"Left"},y:{length:"Height",position:"Top"}};function Ys(t,e,n,s){const i=n[e],{length:r,position:o}=Us[e],a=i.current,l=n.time;i.current=t["scroll"+o],i.scrollLength=t["scroll"+r]-t["client"+r],i.offset.length=0,i.offset[0]=0,i.offset[1]=i.scrollLength,i.progress=x(0,i.scrollLength,i.current);const u=s-l;i.velocity=u>50?0:p(i.current-a,u)}const qs={Enter:[[0,1],[1,1]],Exit:[[0,0],[1,0]],Any:[[1,0],[0,1]],All:[[0,0],[1,1]]},Xs={start:0,center:.5,end:1};function Gs(t,e,n=0){let s=0;if(t in Xs&&(t=Xs[t]),"string"==typeof t){const e=parseFloat(t);t.endsWith("px")?s=e:t.endsWith("%")?t=e/100:t.endsWith("vw")?s=e/100*document.documentElement.clientWidth:t.endsWith("vh")?s=e/100*document.documentElement.clientHeight:t=e}return"number"==typeof t&&(s=e*t),n+s}const Zs=[0,0];function _s(t,e,n,s){let i=Array.isArray(t)?t:Zs,r=0,o=0;return"number"==typeof t?i=[t,t]:"string"==typeof t&&(i=(t=t.trim()).includes(" ")?t.split(" "):[t,Xs[t]?t:"0"]),r=Gs(i[0],n,s),o=Gs(i[1],e),r-o}const Js={x:0,y:0};function Qs(t,e,n){const{offset:s=qs.All}=n,{target:i=t,axis:r="y"}=n,o="y"===r?"height":"width",a=i!==t?function(t,e){const n={x:0,y:0};let s=t;for(;s&&s!==e;)if(s instanceof HTMLElement)n.x+=s.offsetLeft,n.y+=s.offsetTop,s=s.offsetParent;else if("svg"===s.tagName){const t=s.getBoundingClientRect();s=s.parentElement;const e=s.getBoundingClientRect();n.x+=t.left-e.left,n.y+=t.top-e.top}else{if(!(s instanceof SVGGraphicsElement))break;{const{x:t,y:e}=s.getBBox();n.x+=t,n.y+=e;let i=null,r=s.parentNode;for(;!i;)"svg"===r.tagName&&(i=r),r=s.parentNode;s=i}}return n}(i,t):Js,l=i===t?{width:t.scrollWidth,height:t.scrollHeight}:function(t){return"getBBox"in t&&"svg"!==t.tagName?t.getBBox():{width:t.clientWidth,height:t.clientHeight}}(i),u={width:t.clientWidth,height:t.clientHeight};e[r].offset.length=0;let c=!e[r].interpolate;const h=s.length;for(let t=0;t<h;t++){const n=_s(s[t],u[o],l[o],a[r]);c||n===e[r].interpolatorOffsets[t]||(c=!0),e[r].offset[t]=n}c&&(e[r].interpolate=bn(e[r].offset,_(s)),e[r].interpolatorOffsets=[...e[r].offset]),e[r].progress=e[r].interpolate(e[r].current)}function ti(t,e,n,s={}){return{measure:()=>function(t,e=t,n){if(n.x.targetOffset=0,n.y.targetOffset=0,e!==t){let s=e;for(;s&&s!==t;)n.x.targetOffset+=s.offsetLeft,n.y.targetOffset+=s.offsetTop,s=s.offsetParent}n.x.targetLength=e===t?e.scrollWidth:e.clientWidth,n.y.targetLength=e===t?e.scrollHeight:e.clientHeight,n.x.containerLength=t.clientWidth,n.y.containerLength=t.clientHeight}(t,s.target,n),update:e=>{!function(t,e,n){Ys(t,"x",e,n),Ys(t,"y",e,n),e.time=n}(t,n,e),(s.offset||s.target)&&Qs(t,n,s)},notify:()=>e(n)}}const ei=new WeakMap,ni=new WeakMap,si=new WeakMap,ii=t=>t===document.documentElement?window:t;function ri(t,{container:e=document.documentElement,...n}={}){let s=si.get(e);s||(s=new Set,si.set(e,s));const i=ti(e,t,{time:0,x:{current:0,offset:[],progress:0,scrollLength:0,targetOffset:0,targetLength:0,containerLength:0,velocity:0},y:{current:0,offset:[],progress:0,scrollLength:0,targetOffset:0,targetLength:0,containerLength:0,velocity:0}},n);if(s.add(i),!ei.has(e)){const t=()=>{for(const t of s)t.measure()},n=()=>{for(const t of s)t.update(u.timestamp)},i=()=>{for(const t of s)t.notify()},l=()=>{a.read(t,!1,!0),a.read(n,!1,!0),a.update(i,!1,!0)};ei.set(e,l);const c=ii(e);window.addEventListener("resize",l,{passive:!0}),e!==document.documentElement&&ni.set(e,(o=l,"function"==typeof(r=e)?Hs(r):js(r,o))),c.addEventListener("scroll",l,{passive:!0})}var r,o;const c=ei.get(e);return a.read(c,!1,!0),()=>{var t;l(c);const n=si.get(e);if(!n)return;if(n.delete(i),n.size)return;const s=ei.get(e);ei.delete(e),s&&(ii(e).removeEventListener("scroll",s),null===(t=ni.get(e))||void 0===t||t(),window.removeEventListener("resize",s))}}function oi(t,e){let n;const s=()=>{const{currentTime:s}=e,i=(null===s?0:s.value)/100;n!==i&&t(i),n=i};return a.update(s,!0),()=>l(s)}const ai=new Map;function li({source:t,container:e=document.documentElement,axis:n="y"}={}){t&&(e=t),ai.has(e)||ai.set(e,{});const s=ai.get(e);return s[n]||(s[n]=b()?new ScrollTimeline({source:e,axis:n}):function({source:t,container:e,axis:n="y"}){t&&(e=t);const s={value:0},i=ri(t=>{s.value=100*t[n].progress},{container:e,axis:n});return{currentTime:s,cancel:i}}({source:e,axis:n})),s[n]}function ui(t){return t&&(t.target||t.offset)}const ci={some:0,all:1};const hi=(t,e)=>Math.abs(t-e);const di=a,pi=o.reduce((t,e)=>(t[e]=t=>l(t),t),{});t.MotionValue=y,t.animate=Fs,t.animateMini=Ds,t.anticipate=It,t.backIn=Et,t.backInOut=Ot,t.backOut=Ct,t.cancelFrame=l,t.cancelSync=pi,t.circIn=Rt,t.circInOut=Dt,t.circOut=Bt,t.clamp=P,t.createScopedAnimate=ks,t.cubicBezier=Pt,t.delay=function(t,e){return function(t,e){const n=g.now(),s=({timestamp:i})=>{const r=i-n;r>=e&&(l(s),t(r-e))};return a.read(s,!0),()=>l(s)}(t,V(e))},t.distance=hi,t.distance2D=function(t,e){const n=hi(t.x,e.x),s=hi(t.y,e.y);return Math.sqrt(n**2+s**2)},t.easeIn=Je,t.easeInOut=tn,t.easeOut=Qe,t.frame=a,t.frameData=u,t.frameSteps=c,t.inView=function(t,e,{root:n,margin:s,amount:r="some"}={}){const o=i(t),a=new WeakMap,l=new IntersectionObserver(t=>{t.forEach(t=>{const n=a.get(t.target);if(t.isIntersecting!==Boolean(n))if(t.isIntersecting){const n=e(t);"function"==typeof n?a.set(t.target,n):l.unobserve(t.target)}else n&&(n(t),a.delete(t.target))})},{root:n,rootMargin:s,threshold:"number"==typeof r?r:ci[r]});return o.forEach(t=>l.observe(t)),()=>l.disconnect()},t.inertia=_e,t.interpolate=bn,t.invariant=n,t.isDragActive=function(){return s},t.keyframes=Tn,t.mirrorEasing=kt,t.mix=wn,t.motionValue=v,t.noop=e,t.pipe=on,t.progress=x,t.reverseEasing=Ft,t.scroll=function(t,{axis:n="y",...s}={}){const i={axis:n,...s};return"function"==typeof t?function(t,e){return function(t){return 2===t.length}(t)||ui(e)?ri(n=>{t(n[e.axis].progress,n)},e):oi(t,li(e))}(t,i):function(t,n){if(t.flatten(),ui(n))return t.pause(),ri(e=>{t.time=t.duration*e[n.axis].progress},n);{const s=li(n);return t.attachTimeline?t.attachTimeline(s,t=>(t.pause(),oi(e=>{t.time=t.duration*e},s))):e}}(t,i)},t.scrollInfo=ri,t.spring=q,t.stagger=function(t=.1,{startDelay:e=0,from:n=0,ease:s}={}){return(i,r)=>{const o="number"==typeof n?n:function(t,e){if("first"===t)return 0;{const n=e-1;return"last"===t?n:n/2}}(n,r),a=Math.abs(o-i);let l=t*a;if(s){const e=r*t;l=sn(s)(l/e)*e}return e+l}},t.steps=function(t,e="end"){return n=>{const s=(n="end"===e?Math.min(n,.999):Math.max(n,.001))*t,i="end"===e?Math.floor(s):Math.ceil(s);return P(0,1,i/t)}},t.sync=di,t.time=g,t.transform=function(...t){const e=!Array.isArray(t[0]),n=e?0:-1,s=t[0+n],i=t[1+n],r=t[2+n],o=t[3+n],a=bn(i,r,{mixer:(l=r[0],(t=>t&&"object"==typeof t&&t.mix)(l)?l.mix:void 0),...o});var l;return e?a(s):a},t.wrap=st}));
+!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Motion={})}(this,(function(t){"use strict";const e=t=>t,n=!1;const s=["read","resolveKeyframes","update","preRender","render","postRender"];const{schedule:i,cancel:r,state:o,steps:a}=function(t,e){let n=!1,i=!0;const r={delta:0,timestamp:0,isProcessing:!1},o=()=>n=!0,a=s.reduce((t,e)=>(t[e]=function(t){let e=new Set,n=new Set,s=!1,i=!1;const r=new WeakSet;let o={delta:0,timestamp:0,isProcessing:!1};function a(e){r.has(e)&&(l.schedule(e),t()),e(o)}const l={schedule:(t,i=!1,o=!1)=>{const a=o&&s?e:n;return i&&r.add(t),a.has(t)||a.add(t),t},cancel:t=>{n.delete(t),r.delete(t)},process:t=>{o=t,s?i=!0:(s=!0,[e,n]=[n,e],n.clear(),e.forEach(a),s=!1,i&&(i=!1,l.process(t)))}};return l}(o),t),{}),{read:l,resolveKeyframes:u,update:c,preRender:h,render:d,postRender:p}=a,f=()=>{const s=performance.now();n=!1,r.delta=i?1e3/60:Math.max(Math.min(s-r.timestamp,40),1),r.timestamp=s,r.isProcessing=!0,l.process(r),u.process(r),c.process(r),h.process(r),d.process(r),p.process(r),r.isProcessing=!1,n&&e&&(i=!1,t(f))};return{schedule:s.reduce((e,s)=>{const o=a[s];return e[s]=(e,s=!1,a=!1)=>(n||(n=!0,i=!0,r.isProcessing||t(f)),o.schedule(e,s,a)),e},{}),cancel:t=>{for(let e=0;e<s.length;e++)a[s[e]].cancel(t)},state:r,steps:a}}("undefined"!=typeof requestAnimationFrame?requestAnimationFrame:e,!0);function l(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class u{constructor(){this.subscriptions=[]}add(t){var e,n;return e=this.subscriptions,n=t,-1===e.indexOf(n)&&e.push(n),()=>l(this.subscriptions,t)}notify(t,e,n){const s=this.subscriptions.length;if(s)if(1===s)this.subscriptions[0](t,e,n);else for(let i=0;i<s;i++){const s=this.subscriptions[i];s&&s(t,e,n)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}function c(t,e){return e?t*(1e3/e):0}let h;function d(){h=void 0}const p={now:()=>(void 0===h&&p.set(o.isProcessing||n?o.timestamp:performance.now()),h),set:t=>{h=t,queueMicrotask(d)}};class f{constructor(t,e={}){this.version="11.11.10",this.canTrackVelocity=null,this.events={},this.updateAndNotify=(t,e=!0)=>{const n=p.now();this.updatedAt!==n&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(t),this.current!==this.prev&&this.events.change&&this.events.change.notify(this.current),e&&this.events.renderRequest&&this.events.renderRequest.notify(this.current)},this.hasAnimated=!1,this.setCurrent(t),this.owner=e.owner}setCurrent(t){var e;this.current=t,this.updatedAt=p.now(),null===this.canTrackVelocity&&void 0!==t&&(this.canTrackVelocity=(e=this.current,!isNaN(parseFloat(e))))}setPrevFrameValue(t=this.current){this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt}onChange(t){return this.on("change",t)}on(t,e){this.events[t]||(this.events[t]=new u);const n=this.events[t].add(e);return"change"===t?()=>{n(),i.read(()=>{this.events.change.getSize()||this.stop()})}:n}clearListeners(){for(const t in this.events)this.events[t].clear()}attach(t,e){this.passiveEffect=t,this.stopPassiveEffect=e}set(t,e=!0){e&&this.passiveEffect?this.passiveEffect(t,this.updateAndNotify):this.updateAndNotify(t,e)}setWithVelocity(t,e,n){this.set(e),this.prev=void 0,this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt-n}jump(t,e=!0){this.updateAndNotify(t),this.prev=t,this.prevUpdatedAt=this.prevFrameValue=void 0,e&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const t=p.now();if(!this.canTrackVelocity||void 0===this.prevFrameValue||t-this.updatedAt>30)return 0;const e=Math.min(this.updatedAt-this.prevUpdatedAt,30);return c(parseFloat(this.current)-parseFloat(this.prevFrameValue),e)}start(t){return this.stop(),new Promise(e=>{this.hasAnimated=!0,this.animation=t(e),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function m(t,e){return new f(t,e)}function g(t){let e;return()=>(void 0===e&&(e=t()),e)}const y=g(()=>void 0!==window.ScrollTimeline);class v{constructor(t){this.stop=()=>this.runAll("stop"),this.animations=t.filter(Boolean)}then(t,e){return Promise.all(this.animations).then(t).catch(e)}getAll(t){return this.animations[0][t]}setAll(t,e){for(let n=0;n<this.animations.length;n++)this.animations[n][t]=e}attachTimeline(t,e){const n=this.animations.map(n=>y()&&n.attachTimeline?n.attachTimeline(t):e(n));return()=>{n.forEach((t,e)=>{t&&t(),this.animations[e].stop()})}}get time(){return this.getAll("time")}set time(t){this.setAll("time",t)}get speed(){return this.getAll("speed")}set speed(t){this.setAll("speed",t)}get startTime(){return this.getAll("startTime")}get duration(){let t=0;for(let e=0;e<this.animations.length;e++)t=Math.max(t,this.animations[e].duration);return t}runAll(t){this.animations.forEach(e=>e[t]())}play(){this.runAll("play")}pause(){this.runAll("pause")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}const w=t=>1e3*t,b=t=>t/1e3;function x(t,e,n){const s=Math.max(e-5,0);return c(n-t(s),e-s)}let T=e,S=e;const V=(t,e,n)=>n>e?e:n<t?t:n;function A({duration:t=800,bounce:e=.25,velocity:n=0,mass:s=1}){let i,r,o=1-e;o=V(.05,1,o),t=V(.01,10,b(t)),o<1?(i=e=>{const s=e*o,i=s*t;return.001-(s-n)/M(e,o)*Math.exp(-i)},r=e=>{const s=e*o*t,r=s*n+n,a=Math.pow(o,2)*Math.pow(e,2)*t,l=Math.exp(-s),u=M(Math.pow(e,2),o);return(.001-i(e)>0?-1:1)*((r-a)*l)/u}):(i=e=>Math.exp(-e*t)*((e-n)*t+1)-.001,r=e=>Math.exp(-e*t)*(t*t*(n-e)));const a=function(t,e,n){let s=n;for(let n=1;n<12;n++)s-=t(s)/e(s);return s}(i,r,5/t);if(t=w(t),isNaN(a))return{stiffness:100,damping:10,duration:t};{const e=Math.pow(a,2)*s;return{stiffness:e,damping:2*o*Math.sqrt(s*e),duration:t}}}function M(t,e){return t*Math.sqrt(1-e*e)}const P=["duration","bounce"],k=["stiffness","damping","mass"];function F(t,e){return e.some(e=>void 0!==t[e])}function C({keyframes:t,restDelta:e,restSpeed:n,...s}){const i=t[0],r=t[t.length-1],o={done:!1,value:i},{stiffness:a,damping:l,mass:u,duration:c,velocity:h,isResolvedFromDuration:d}=function(t){let e={velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1,...t};if(!F(t,k)&&F(t,P)){const n=A(t);e={...e,...n,mass:1},e.isResolvedFromDuration=!0}return e}({...s,velocity:-b(s.velocity||0)}),p=h||0,f=l/(2*Math.sqrt(a*u)),m=r-i,g=b(Math.sqrt(a/u)),y=Math.abs(m)<5;let v;if(n||(n=y?.01:2),e||(e=y?.005:.5),f<1){const t=M(g,f);v=e=>{const n=Math.exp(-f*g*e);return r-n*((p+f*g*m)/t*Math.sin(t*e)+m*Math.cos(t*e))}}else if(1===f)v=t=>r-Math.exp(-g*t)*(m+(p+g*m)*t);else{const t=g*Math.sqrt(f*f-1);v=e=>{const n=Math.exp(-f*g*e),s=Math.min(t*e,300);return r-n*((p+f*g*m)*Math.sinh(s)+t*m*Math.cosh(s))/t}}return{calculatedDuration:d&&c||null,next:t=>{const s=v(t);if(d)o.done=t>=c;else{let i=0;f<1&&(i=0===t?w(p):x(v,t,s));const a=Math.abs(i)<=n,l=Math.abs(r-s)<=e;o.done=a&&l}return o.value=o.done?r:s,o}}}function E(t){let e=0;let n=t.next(e);for(;!n.done&&e<2e4;)e+=50,n=t.next(e);return e>=2e4?1/0:e}function O(t,e=100,n){const s=n({...t,keyframes:[0,e]}),i=Math.min(E(s),2e4);return{type:"keyframes",ease:t=>s.next(i*t).value/e,duration:b(i)}}const R=(t,e,n)=>t+(e-t)*n,I=(t,e,n)=>{const s=e-t;return 0===s?1:(n-t)/s};function B(t,e){const n=t[t.length-1];for(let s=1;s<=e;s++){const i=I(0,e,s);t.push(R(n,1,i))}}function L(t){const e=[0];return B(e,t.length-1),e}const W=t=>Boolean(t&&t.getVelocity);function D(t,e,n){var s;if("string"==typeof t){let i=document;e&&(S(Boolean(e.current)),i=e.current),n?(null!==(s=n[t])&&void 0!==s||(n[t]=i.querySelectorAll(t)),t=n[t]):t=i.querySelectorAll(t)}else t instanceof Element&&(t=[t]);return Array.from(t||[])}function N(t){return"object"==typeof t&&!Array.isArray(t)}function K(t,e,n,s){return"string"==typeof t&&N(e)?D(t,n,s):t instanceof NodeList?Array.from(t):Array.isArray(t)?t:[t]}function z(t){return"function"==typeof t}function j(t,e,n,s){var i;return"number"==typeof e?e:e.startsWith("-")||e.startsWith("+")?Math.max(0,t+parseFloat(e)):"<"===e?n:null!==(i=s.get(e))&&void 0!==i?i:t}const $=(t,e,n)=>{const s=e-t;return((n-t)%s+s)%s+t},H=t=>Array.isArray(t)&&"number"!=typeof t[0];function U(t,e){return H(t)?t[$(0,t.length,e)]:t}function Y(t,e,n,s,i,r){!function(t,e,n){for(let s=0;s<t.length;s++){const i=t[s];i.at>e&&i.at<n&&(l(t,i),s--)}}(t,i,r);for(let o=0;o<e.length;o++)t.push({value:e[o],at:R(i,r,s[o]),easing:U(n,o)})}function q(t,e){return t.at===e.at?null===t.value?1:null===e.value?-1:0:t.at-e.at}function X(t,e){return!e.has(t)&&e.set(t,{}),e.get(t)}function G(t,e){return e[t]||(e[t]=[]),e[t]}function Z(t){return Array.isArray(t)?t:[t]}function _(t,e){return t&&t[e]?{...t,...t[e]}:{...t}}const J=t=>"number"==typeof t,Q=t=>t.every(J),tt=new WeakMap,et=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],nt=new Set(et),st={type:"spring",stiffness:500,damping:25,restSpeed:10},it={type:"keyframes",duration:.8},rt={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},ot=(t,{keyframes:e})=>e.length>2?it:nt.has(t)?t.startsWith("scale")?{type:"spring",stiffness:550,damping:0===e[1]?2*Math.sqrt(550):30,restSpeed:10}:st:rt;function at(t,e){return t?t[e]||t.default||t:void 0}const lt=t=>null!==t;function ut(t,{repeat:e,repeatType:n="loop"},s){const i=t.filter(lt),r=e&&"loop"!==n&&e%2==1?0:i.length-1;return r&&void 0!==s?s:i[r]}const ct=(t,e,n)=>(((1-3*n+3*e)*t+(3*n-6*e))*t+3*e)*t;function ht(t,n,s,i){if(t===n&&s===i)return e;const r=e=>function(t,e,n,s,i){let r,o,a=0;do{o=e+(n-e)/2,r=ct(o,s,i)-t,r>0?n=o:e=o}while(Math.abs(r)>1e-7&&++a<12);return o}(e,0,1,t,s);return t=>0===t||1===t?t:ct(r(t),n,i)}const dt=t=>e=>e<=.5?t(2*e)/2:(2-t(2*(1-e)))/2,pt=t=>e=>1-t(1-e),ft=ht(.33,1.53,.69,.99),mt=pt(ft),gt=dt(mt),yt=t=>(t*=2)<1?.5*mt(t):.5*(2-Math.pow(2,-10*(t-1))),vt=t=>1-Math.sin(Math.acos(t)),wt=pt(vt),bt=dt(vt),xt=t=>/^0[^.\s]+$/u.test(t);const Tt=t=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),St=t=>e=>"string"==typeof e&&e.startsWith(t),Vt=St("--"),At=St("var(--"),Mt=t=>!!At(t)&&Pt.test(t.split("/*")[0].trim()),Pt=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,kt=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function Ft(t,e,n=1){const[s,i]=function(t){const e=kt.exec(t);if(!e)return[,];const[,n,s,i]=e;return["--"+(null!=n?n:s),i]}(t);if(!s)return;const r=window.getComputedStyle(e).getPropertyValue(s);if(r){const t=r.trim();return Tt(t)?parseFloat(t):t}return Mt(i)?Ft(i,e,n+1):i}const Ct={test:t=>"number"==typeof t,parse:parseFloat,transform:t=>t},Et={...Ct,transform:t=>V(0,1,t)},Ot={...Ct,default:1},Rt=t=>({test:e=>"string"==typeof e&&e.endsWith(t)&&1===e.split(" ").length,parse:parseFloat,transform:e=>`${e}${t}`}),It=Rt("deg"),Bt=Rt("%"),Lt=Rt("px"),Wt=Rt("vh"),Dt=Rt("vw"),Nt={...Bt,parse:t=>Bt.parse(t)/100,transform:t=>Bt.transform(100*t)},Kt=new Set(["width","height","top","left","right","bottom","x","y","translateX","translateY"]),zt=t=>t===Ct||t===Lt,jt=(t,e)=>parseFloat(t.split(", ")[e]),$t=(t,e)=>(n,{transform:s})=>{if("none"===s||!s)return 0;const i=s.match(/^matrix3d\((.+)\)$/u);if(i)return jt(i[1],e);{const e=s.match(/^matrix\((.+)\)$/u);return e?jt(e[1],t):0}},Ht=new Set(["x","y","z"]),Ut=et.filter(t=>!Ht.has(t));const Yt={width:({x:t},{paddingLeft:e="0",paddingRight:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),height:({y:t},{paddingTop:e="0",paddingBottom:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),top:(t,{top:e})=>parseFloat(e),left:(t,{left:e})=>parseFloat(e),bottom:({y:t},{top:e})=>parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=>parseFloat(e)+(t.max-t.min),x:$t(4,13),y:$t(5,14)};Yt.translateX=Yt.x,Yt.translateY=Yt.y;const qt=t=>e=>e.test(t),Xt=[Ct,Lt,Bt,It,Dt,Wt,{test:t=>"auto"===t,parse:t=>t}],Gt=t=>Xt.find(qt(t)),Zt=new Set;let _t=!1,Jt=!1;function Qt(){if(Jt){const t=Array.from(Zt).filter(t=>t.needsMeasurement),e=new Set(t.map(t=>t.element)),n=new Map;e.forEach(t=>{const e=function(t){const e=[];return Ut.forEach(n=>{const s=t.getValue(n);void 0!==s&&(e.push([n,s.get()]),s.set(n.startsWith("scale")?1:0))}),e}(t);e.length&&(n.set(t,e),t.render())}),t.forEach(t=>t.measureInitialState()),e.forEach(t=>{t.render();const e=n.get(t);e&&e.forEach(([e,n])=>{var s;null===(s=t.getValue(e))||void 0===s||s.set(n)})}),t.forEach(t=>t.measureEndState()),t.forEach(t=>{void 0!==t.suspendedScrollY&&window.scrollTo(0,t.suspendedScrollY)})}Jt=!1,_t=!1,Zt.forEach(t=>t.complete()),Zt.clear()}function te(){Zt.forEach(t=>{t.readKeyframes(),t.needsMeasurement&&(Jt=!0)})}class ee{constructor(t,e,n,s,i,r=!1){this.isComplete=!1,this.isAsync=!1,this.needsMeasurement=!1,this.isScheduled=!1,this.unresolvedKeyframes=[...t],this.onComplete=e,this.name=n,this.motionValue=s,this.element=i,this.isAsync=r}scheduleResolve(){this.isScheduled=!0,this.isAsync?(Zt.add(this),_t||(_t=!0,i.read(te),i.resolveKeyframes(Qt))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:t,name:e,element:n,motionValue:s}=this;for(let i=0;i<t.length;i++)if(null===t[i])if(0===i){const i=null==s?void 0:s.get(),r=t[t.length-1];if(void 0!==i)t[0]=i;else if(n&&e){const s=n.readValue(e,r);null!=s&&(t[0]=s)}void 0===t[0]&&(t[0]=r),s&&void 0===i&&s.set(t[0])}else t[i]=t[i-1]}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(){this.isComplete=!0,this.onComplete(this.unresolvedKeyframes,this.finalKeyframe),Zt.delete(this)}cancel(){this.isComplete||(this.isScheduled=!1,Zt.delete(this))}resume(){this.isComplete||this.scheduleResolve()}}const ne=t=>Math.round(1e5*t)/1e5,se=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;const ie=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,re=(t,e)=>n=>Boolean("string"==typeof n&&ie.test(n)&&n.startsWith(t)||e&&!function(t){return null==t}(n)&&Object.prototype.hasOwnProperty.call(n,e)),oe=(t,e,n)=>s=>{if("string"!=typeof s)return s;const[i,r,o,a]=s.match(se);return{[t]:parseFloat(i),[e]:parseFloat(r),[n]:parseFloat(o),alpha:void 0!==a?parseFloat(a):1}},ae={...Ct,transform:t=>Math.round((t=>V(0,255,t))(t))},le={test:re("rgb","red"),parse:oe("red","green","blue"),transform:({red:t,green:e,blue:n,alpha:s=1})=>"rgba("+ae.transform(t)+", "+ae.transform(e)+", "+ae.transform(n)+", "+ne(Et.transform(s))+")"};const ue={test:re("#"),parse:function(t){let e="",n="",s="",i="";return t.length>5?(e=t.substring(1,3),n=t.substring(3,5),s=t.substring(5,7),i=t.substring(7,9)):(e=t.substring(1,2),n=t.substring(2,3),s=t.substring(3,4),i=t.substring(4,5),e+=e,n+=n,s+=s,i+=i),{red:parseInt(e,16),green:parseInt(n,16),blue:parseInt(s,16),alpha:i?parseInt(i,16)/255:1}},transform:le.transform},ce={test:re("hsl","hue"),parse:oe("hue","saturation","lightness"),transform:({hue:t,saturation:e,lightness:n,alpha:s=1})=>"hsla("+Math.round(t)+", "+Bt.transform(ne(e))+", "+Bt.transform(ne(n))+", "+ne(Et.transform(s))+")"},he={test:t=>le.test(t)||ue.test(t)||ce.test(t),parse:t=>le.test(t)?le.parse(t):ce.test(t)?ce.parse(t):ue.parse(t),transform:t=>"string"==typeof t?t:t.hasOwnProperty("red")?le.transform(t):ce.transform(t)},de=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;const pe=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function fe(t){const e=t.toString(),n=[],s={color:[],number:[],var:[]},i=[];let r=0;const o=e.replace(pe,t=>(he.test(t)?(s.color.push(r),i.push("color"),n.push(he.parse(t))):t.startsWith("var(")?(s.var.push(r),i.push("var"),n.push(t)):(s.number.push(r),i.push("number"),n.push(parseFloat(t))),++r,"${}")).split("${}");return{values:n,split:o,indexes:s,types:i}}function me(t){return fe(t).values}function ge(t){const{split:e,types:n}=fe(t),s=e.length;return t=>{let i="";for(let r=0;r<s;r++)if(i+=e[r],void 0!==t[r]){const e=n[r];i+="number"===e?ne(t[r]):"color"===e?he.transform(t[r]):t[r]}return i}}const ye=t=>"number"==typeof t?0:t;const ve={test:function(t){var e,n;return isNaN(t)&&"string"==typeof t&&((null===(e=t.match(se))||void 0===e?void 0:e.length)||0)+((null===(n=t.match(de))||void 0===n?void 0:n.length)||0)>0},parse:me,createTransformer:ge,getAnimatableNone:function(t){const e=me(t);return ge(t)(e.map(ye))}},we=new Set(["brightness","contrast","saturate","opacity"]);function be(t){const[e,n]=t.slice(0,-1).split("(");if("drop-shadow"===e)return t;const[s]=n.match(se)||[];if(!s)return t;const i=n.replace(s,"");let r=we.has(e)?1:0;return s!==n&&(r*=100),e+"("+r+i+")"}const xe=/\b([a-z-]*)\(.*?\)/gu,Te={...ve,getAnimatableNone:t=>{const e=t.match(xe);return e?e.map(be).join(" "):t}},Se={borderWidth:Lt,borderTopWidth:Lt,borderRightWidth:Lt,borderBottomWidth:Lt,borderLeftWidth:Lt,borderRadius:Lt,radius:Lt,borderTopLeftRadius:Lt,borderTopRightRadius:Lt,borderBottomRightRadius:Lt,borderBottomLeftRadius:Lt,width:Lt,maxWidth:Lt,height:Lt,maxHeight:Lt,top:Lt,right:Lt,bottom:Lt,left:Lt,padding:Lt,paddingTop:Lt,paddingRight:Lt,paddingBottom:Lt,paddingLeft:Lt,margin:Lt,marginTop:Lt,marginRight:Lt,marginBottom:Lt,marginLeft:Lt,backgroundPositionX:Lt,backgroundPositionY:Lt},Ve={rotate:It,rotateX:It,rotateY:It,rotateZ:It,scale:Ot,scaleX:Ot,scaleY:Ot,scaleZ:Ot,skew:It,skewX:It,skewY:It,distance:Lt,translateX:Lt,translateY:Lt,translateZ:Lt,x:Lt,y:Lt,z:Lt,perspective:Lt,transformPerspective:Lt,opacity:Et,originX:Nt,originY:Nt,originZ:Lt},Ae={...Ct,transform:Math.round},Me={...Se,...Ve,zIndex:Ae,size:Lt,fillOpacity:Et,strokeOpacity:Et,numOctaves:Ae},Pe={...Me,color:he,backgroundColor:he,outlineColor:he,fill:he,stroke:he,borderColor:he,borderTopColor:he,borderRightColor:he,borderBottomColor:he,borderLeftColor:he,filter:Te,WebkitFilter:Te},ke=t=>Pe[t];function Fe(t,e){let n=ke(t);return n!==Te&&(n=ve),n.getAnimatableNone?n.getAnimatableNone(e):void 0}const Ce=new Set(["auto","none","0"]);class Ee extends ee{constructor(t,e,n,s,i){super(t,e,n,s,i,!0)}readKeyframes(){const{unresolvedKeyframes:t,element:e,name:n}=this;if(!e||!e.current)return;super.readKeyframes();for(let n=0;n<t.length;n++){let s=t[n];if("string"==typeof s&&(s=s.trim(),Mt(s))){const i=Ft(s,e.current);void 0!==i&&(t[n]=i),n===t.length-1&&(this.finalKeyframe=s)}}if(this.resolveNoneKeyframes(),!Kt.has(n)||2!==t.length)return;const[s,i]=t,r=Gt(s),o=Gt(i);if(r!==o)if(zt(r)&&zt(o))for(let e=0;e<t.length;e++){const n=t[e];"string"==typeof n&&(t[e]=parseFloat(n))}else this.needsMeasurement=!0}resolveNoneKeyframes(){const{unresolvedKeyframes:t,name:e}=this,n=[];for(let e=0;e<t.length;e++)("number"==typeof(s=t[e])?0===s:null===s||"none"===s||"0"===s||xt(s))&&n.push(e);var s;n.length&&function(t,e,n){let s=0,i=void 0;for(;s<t.length&&!i;){const e=t[s];"string"==typeof e&&!Ce.has(e)&&fe(e).values.length&&(i=t[s]),s++}if(i&&n)for(const s of e)t[s]=Fe(n,i)}(t,n,e)}measureInitialState(){const{element:t,unresolvedKeyframes:e,name:n}=this;if(!t||!t.current)return;"height"===n&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=Yt[n](t.measureViewportBox(),window.getComputedStyle(t.current)),e[0]=this.measuredOrigin;const s=e[e.length-1];void 0!==s&&t.getValue(n,s).jump(s,!1)}measureEndState(){var t;const{element:e,name:n,unresolvedKeyframes:s}=this;if(!e||!e.current)return;const i=e.getValue(n);i&&i.jump(this.measuredOrigin,!1);const r=s.length-1,o=s[r];s[r]=Yt[n](e.measureViewportBox(),window.getComputedStyle(e.current)),null!==o&&void 0===this.finalKeyframe&&(this.finalKeyframe=o),(null===(t=this.removedTransforms)||void 0===t?void 0:t.length)&&this.removedTransforms.forEach(([t,n])=>{e.getValue(t).set(n)}),this.resolveNoneKeyframes()}}const Oe=(t,e)=>"zIndex"!==e&&(!("number"!=typeof t&&!Array.isArray(t))||!("string"!=typeof t||!ve.test(t)&&"0"!==t||t.startsWith("url(")));function Re(t,e,n,s){const i=t[0];if(null===i)return!1;if("display"===e||"visibility"===e)return!0;const r=t[t.length-1],o=Oe(i,e),a=Oe(r,e);return!(!o||!a)&&(function(t){const e=t[0];if(1===t.length)return!0;for(let n=0;n<t.length;n++)if(t[n]!==e)return!0}(t)||("spring"===n||z(n))&&s)}class Ie{constructor({autoplay:t=!0,delay:e=0,type:n="keyframes",repeat:s=0,repeatDelay:i=0,repeatType:r="loop",...o}){this.isStopped=!1,this.hasAttemptedResolve=!1,this.createdAt=p.now(),this.options={autoplay:t,delay:e,type:n,repeat:s,repeatDelay:i,repeatType:r,...o},this.updateFinishedPromise()}calcStartTime(){return this.resolvedAt&&this.resolvedAt-this.createdAt>40?this.resolvedAt:this.createdAt}get resolved(){return this._resolved||this.hasAttemptedResolve||(te(),Qt()),this._resolved}onKeyframesResolved(t,e){this.resolvedAt=p.now(),this.hasAttemptedResolve=!0;const{name:n,type:s,velocity:i,delay:r,onComplete:o,onUpdate:a,isGenerator:l}=this.options;if(!l&&!Re(t,n,s,i)){if(!r)return null==a||a(ut(t,this.options,e)),null==o||o(),void this.resolveFinishedPromise();this.options.duration=0}const u=this.initPlayback(t,e);!1!==u&&(this._resolved={keyframes:t,finalKeyframe:e,...u},this.onPostResolved())}onPostResolved(){}then(t,e){return this.currentFinishedPromise.then(t,e)}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}}function Be({keyframes:t,velocity:e=0,power:n=.8,timeConstant:s=325,bounceDamping:i=10,bounceStiffness:r=500,modifyTarget:o,min:a,max:l,restDelta:u=.5,restSpeed:c}){const h=t[0],d={done:!1,value:h},p=t=>void 0===a?l:void 0===l||Math.abs(a-t)<Math.abs(l-t)?a:l;let f=n*e;const m=h+f,g=void 0===o?m:o(m);g!==m&&(f=g-h);const y=t=>-f*Math.exp(-t/s),v=t=>g+y(t),w=t=>{const e=y(t),n=v(t);d.done=Math.abs(e)<=u,d.value=d.done?g:n};let b,T;const S=t=>{var e;(e=d.value,void 0!==a&&e<a||void 0!==l&&e>l)&&(b=t,T=C({keyframes:[d.value,p(d.value)],velocity:x(v,t,d.value),damping:i,stiffness:r,restDelta:u,restSpeed:c}))};return S(0),{calculatedDuration:null,next:t=>{let e=!1;return T||void 0!==b||(e=!0,w(t),S(t)),void 0!==b&&t>=b?T.next(t-b):(!e&&w(t),d)}}}const Le=ht(.42,0,1,1),We=ht(0,0,.58,1),De=ht(.42,0,.58,1),Ne=t=>Array.isArray(t)&&"number"==typeof t[0],Ke={linear:e,easeIn:Le,easeInOut:De,easeOut:We,circIn:vt,circInOut:bt,circOut:wt,backIn:mt,backInOut:gt,backOut:ft,anticipate:yt},ze=t=>{if(Ne(t)){S(4===t.length);const[e,n,s,i]=t;return ht(e,n,s,i)}return"string"==typeof t?Ke[t]:t},je=(t,e)=>n=>e(t(n)),$e=(...t)=>t.reduce(je);function He(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+(e-t)*(2/3-n)*6:t}function Ue(t,e){return n=>n>0?e:t}const Ye=(t,e,n)=>{const s=t*t,i=n*(e*e-s)+s;return i<0?0:Math.sqrt(i)},qe=[ue,le,ce];function Xe(t){const e=(n=t,qe.find(t=>t.test(n)));var n;if(!Boolean(e))return!1;let s=e.parse(t);return e===ce&&(s=function({hue:t,saturation:e,lightness:n,alpha:s}){t/=360,n/=100;let i=0,r=0,o=0;if(e/=100){const s=n<.5?n*(1+e):n+e-n*e,a=2*n-s;i=He(a,s,t+1/3),r=He(a,s,t),o=He(a,s,t-1/3)}else i=r=o=n;return{red:Math.round(255*i),green:Math.round(255*r),blue:Math.round(255*o),alpha:s}}(s)),s}const Ge=(t,e)=>{const n=Xe(t),s=Xe(e);if(!n||!s)return Ue(t,e);const i={...n};return t=>(i.red=Ye(n.red,s.red,t),i.green=Ye(n.green,s.green,t),i.blue=Ye(n.blue,s.blue,t),i.alpha=R(n.alpha,s.alpha,t),le.transform(i))},Ze=new Set(["none","hidden"]);function _e(t,e){return n=>R(t,e,n)}function Je(t){return"number"==typeof t?_e:"string"==typeof t?Mt(t)?Ue:he.test(t)?Ge:en:Array.isArray(t)?Qe:"object"==typeof t?he.test(t)?Ge:tn:Ue}function Qe(t,e){const n=[...t],s=n.length,i=t.map((t,n)=>Je(t)(t,e[n]));return t=>{for(let e=0;e<s;e++)n[e]=i[e](t);return n}}function tn(t,e){const n={...t,...e},s={};for(const i in n)void 0!==t[i]&&void 0!==e[i]&&(s[i]=Je(t[i])(t[i],e[i]));return t=>{for(const e in s)n[e]=s[e](t);return n}}const en=(t,e)=>{const n=ve.createTransformer(e),s=fe(t),i=fe(e);return s.indexes.var.length===i.indexes.var.length&&s.indexes.color.length===i.indexes.color.length&&s.indexes.number.length>=i.indexes.number.length?Ze.has(t)&&!i.values.length||Ze.has(e)&&!s.values.length?function(t,e){return Ze.has(t)?n=>n<=0?t:e:n=>n>=1?e:t}(t,e):$e(Qe(function(t,e){var n;const s=[],i={color:0,var:0,number:0};for(let r=0;r<e.values.length;r++){const o=e.types[r],a=t.indexes[o][i[o]],l=null!==(n=t.values[a])&&void 0!==n?n:0;s[r]=l,i[o]++}return s}(s,i),i.values),n):Ue(t,e)};function nn(t,e,n){if("number"==typeof t&&"number"==typeof e&&"number"==typeof n)return R(t,e,n);return Je(t)(t,e)}function sn(t,n,{clamp:s=!0,ease:i,mixer:r}={}){const o=t.length;if(S(o===n.length),1===o)return()=>n[0];if(2===o&&t[0]===t[1])return()=>n[1];t[0]>t[o-1]&&(t=[...t].reverse(),n=[...n].reverse());const a=function(t,n,s){const i=[],r=s||nn,o=t.length-1;for(let s=0;s<o;s++){let o=r(t[s],t[s+1]);if(n){const t=Array.isArray(n)?n[s]||e:n;o=$e(t,o)}i.push(o)}return i}(n,i,r),l=a.length,u=e=>{let n=0;if(l>1)for(;n<t.length-2&&!(e<t[n+1]);n++);const s=I(t[n],t[n+1],e);return a[n](s)};return s?e=>u(V(t[0],t[o-1],e)):u}function rn({duration:t=300,keyframes:e,times:n,ease:s="easeInOut"}){const i=H(s)?s.map(ze):ze(s),r={done:!1,value:e[0]},o=sn(function(t,e){return t.map(t=>t*e)}(n&&n.length===e.length?n:L(e),t),e,{ease:Array.isArray(i)?i:(a=e,l=i,a.map(()=>l||De).splice(0,a.length-1))});var a,l;return{calculatedDuration:t,next:e=>(r.value=o(e),r.done=e>=t,r)}}const on=t=>{const e=({timestamp:e})=>t(e);return{start:()=>i.update(e,!0),stop:()=>r(e),now:()=>o.isProcessing?o.timestamp:p.now()}},an={decay:Be,inertia:Be,tween:rn,keyframes:rn,spring:C},ln=t=>t/100;class un extends Ie{constructor(t){super(t),this.holdTime=null,this.cancelTime=null,this.currentTime=0,this.playbackSpeed=1,this.pendingPlayState="running",this.startTime=null,this.state="idle",this.stop=()=>{if(this.resolver.cancel(),this.isStopped=!0,"idle"===this.state)return;this.teardown();const{onStop:t}=this.options;t&&t()};const{name:e,motionValue:n,element:s,keyframes:i}=this.options,r=(null==s?void 0:s.KeyframeResolver)||ee;this.resolver=new r(i,(t,e)=>this.onKeyframesResolved(t,e),e,n,s),this.resolver.scheduleResolve()}initPlayback(t){const{type:e="keyframes",repeat:n=0,repeatDelay:s=0,repeatType:i,velocity:r=0}=this.options,o=z(e)?e:an[e]||rn;let a,l;o!==rn&&"number"!=typeof t[0]&&(a=$e(ln,nn(t[0],t[1])),t=[0,100]);const u=o({...this.options,keyframes:t});"mirror"===i&&(l=o({...this.options,keyframes:[...t].reverse(),velocity:-r})),null===u.calculatedDuration&&(u.calculatedDuration=E(u));const{calculatedDuration:c}=u,h=c+s;return{generator:u,mirroredGenerator:l,mapPercentToKeyframes:a,calculatedDuration:c,resolvedDuration:h,totalDuration:h*(n+1)-s}}onPostResolved(){const{autoplay:t=!0}=this.options;this.play(),"paused"!==this.pendingPlayState&&t?this.state=this.pendingPlayState:this.pause()}tick(t,e=!1){const{resolved:n}=this;if(!n){const{keyframes:t}=this.options;return{done:!0,value:t[t.length-1]}}const{finalKeyframe:s,generator:i,mirroredGenerator:r,mapPercentToKeyframes:o,keyframes:a,calculatedDuration:l,totalDuration:u,resolvedDuration:c}=n;if(null===this.startTime)return i.next(0);const{delay:h,repeat:d,repeatType:p,repeatDelay:f,onUpdate:m}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,t):this.speed<0&&(this.startTime=Math.min(t-u/this.speed,this.startTime)),e?this.currentTime=t:null!==this.holdTime?this.currentTime=this.holdTime:this.currentTime=Math.round(t-this.startTime)*this.speed;const g=this.currentTime-h*(this.speed>=0?1:-1),y=this.speed>=0?g<0:g>u;this.currentTime=Math.max(g,0),"finished"===this.state&&null===this.holdTime&&(this.currentTime=u);let v=this.currentTime,w=i;if(d){const t=Math.min(this.currentTime,u)/c;let e=Math.floor(t),n=t%1;!n&&t>=1&&(n=1),1===n&&e--,e=Math.min(e,d+1);Boolean(e%2)&&("reverse"===p?(n=1-n,f&&(n-=f/c)):"mirror"===p&&(w=r)),v=V(0,1,n)*c}const b=y?{done:!1,value:a[0]}:w.next(v);o&&(b.value=o(b.value));let{done:x}=b;y||null===l||(x=this.speed>=0?this.currentTime>=u:this.currentTime<=0);const T=null===this.holdTime&&("finished"===this.state||"running"===this.state&&x);return T&&void 0!==s&&(b.value=ut(a,this.options,s)),m&&m(b.value),T&&this.finish(),b}get duration(){const{resolved:t}=this;return t?b(t.calculatedDuration):0}get time(){return b(this.currentTime)}set time(t){t=w(t),this.currentTime=t,null!==this.holdTime||0===this.speed?this.holdTime=t:this.driver&&(this.startTime=this.driver.now()-t/this.speed)}get speed(){return this.playbackSpeed}set speed(t){const e=this.playbackSpeed!==t;this.playbackSpeed=t,e&&(this.time=b(this.currentTime))}play(){if(this.resolver.isScheduled||this.resolver.resume(),!this._resolved)return void(this.pendingPlayState="running");if(this.isStopped)return;const{driver:t=on,onPlay:e,startTime:n}=this.options;this.driver||(this.driver=t(t=>this.tick(t))),e&&e();const s=this.driver.now();null!==this.holdTime?this.startTime=s-this.holdTime:this.startTime?"finished"===this.state&&(this.startTime=s):this.startTime=null!=n?n:this.calcStartTime(),"finished"===this.state&&this.updateFinishedPromise(),this.cancelTime=this.startTime,this.holdTime=null,this.state="running",this.driver.start()}pause(){var t;this._resolved?(this.state="paused",this.holdTime=null!==(t=this.currentTime)&&void 0!==t?t:0):this.pendingPlayState="paused"}complete(){"running"!==this.state&&this.play(),this.pendingPlayState=this.state="finished",this.holdTime=null}finish(){this.teardown(),this.state="finished";const{onComplete:t}=this.options;t&&t()}cancel(){null!==this.cancelTime&&this.tick(this.cancelTime),this.teardown(),this.updateFinishedPromise()}teardown(){this.state="idle",this.stopDriver(),this.resolveFinishedPromise(),this.updateFinishedPromise(),this.startTime=this.cancelTime=null,this.resolver.cancel()}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(t){return this.startTime=0,this.tick(t,!0)}}const cn=new Set(["opacity","clipPath","filter","transform"]),hn={linearEasing:void 0};function dn(t,e){const n=g(t);return()=>{var t;return null!==(t=hn[e])&&void 0!==t?t:n()}}const pn=dn(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch(t){return!1}return!0},"linearEasing");function fn(t){return Boolean("function"==typeof t&&pn()||!t||"string"==typeof t&&(t in gn||pn())||Ne(t)||Array.isArray(t)&&t.every(fn))}const mn=([t,e,n,s])=>`cubic-bezier(${t}, ${e}, ${n}, ${s})`,gn={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:mn([0,.65,.55,1]),circOut:mn([.55,0,1,.45]),backIn:mn([.31,.01,.66,-.59]),backOut:mn([.33,1.53,.69,.99])};function yn(t,e){return t?"function"==typeof t&&pn()?((t,e)=>{let n="";const s=Math.max(Math.round(e/10),2);for(let e=0;e<s;e++)n+=t(I(0,s-1,e))+", ";return`linear(${n.substring(0,n.length-2)})`})(t,e):Ne(t)?mn(t):Array.isArray(t)?t.map(t=>yn(t,e)||gn.easeOut):gn[t]:void 0}function vn(t,e,n,{delay:s=0,duration:i=300,repeat:r=0,repeatType:o="loop",ease:a,times:l}={}){const u={[e]:n};l&&(u.offset=l);const c=yn(a,i);return Array.isArray(c)&&(u.easing=c),t.animate(u,{delay:s,duration:i,easing:Array.isArray(c)?"linear":c,fill:"both",iterations:r+1,direction:"reverse"===o?"alternate":"normal"})}function wn(t,e){t.timeline=e,t.onfinish=null}const bn=g(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));const xn={anticipate:yt,backInOut:gt,circInOut:bt};class Tn extends Ie{constructor(t){super(t);const{name:e,motionValue:n,element:s,keyframes:i}=this.options;this.resolver=new Ee(i,(t,e)=>this.onKeyframesResolved(t,e),e,n,s),this.resolver.scheduleResolve()}initPlayback(t,e){var n;let{duration:s=300,times:i,ease:r,type:o,motionValue:a,name:l,startTime:u}=this.options;if(!(null===(n=a.owner)||void 0===n?void 0:n.current))return!1;var c;if("string"==typeof r&&pn()&&r in xn&&(r=xn[r]),z((c=this.options).type)||"spring"===c.type||!fn(c.ease)){const{onComplete:e,onUpdate:n,motionValue:a,element:l,...u}=this.options,c=function(t,e){const n=new un({...e,keyframes:t,repeat:0,delay:0,isGenerator:!0});let s={done:!1,value:t[0]};const i=[];let r=0;for(;!s.done&&r<2e4;)s=n.sample(r),i.push(s.value),r+=10;return{times:void 0,keyframes:i,duration:r-10,ease:"linear"}}(t,u);1===(t=c.keyframes).length&&(t[1]=t[0]),s=c.duration,i=c.times,r=c.ease,o="keyframes"}const h=vn(a.owner.current,l,t,{...this.options,duration:s,times:i,ease:r});return h.startTime=null!=u?u:this.calcStartTime(),this.pendingTimeline?(wn(h,this.pendingTimeline),this.pendingTimeline=void 0):h.onfinish=()=>{const{onComplete:n}=this.options;a.set(ut(t,this.options,e)),n&&n(),this.cancel(),this.resolveFinishedPromise()},{animation:h,duration:s,times:i,type:o,ease:r,keyframes:t}}get duration(){const{resolved:t}=this;if(!t)return 0;const{duration:e}=t;return b(e)}get time(){const{resolved:t}=this;if(!t)return 0;const{animation:e}=t;return b(e.currentTime||0)}set time(t){const{resolved:e}=this;if(!e)return;const{animation:n}=e;n.currentTime=w(t)}get speed(){const{resolved:t}=this;if(!t)return 1;const{animation:e}=t;return e.playbackRate}set speed(t){const{resolved:e}=this;if(!e)return;const{animation:n}=e;n.playbackRate=t}get state(){const{resolved:t}=this;if(!t)return"idle";const{animation:e}=t;return e.playState}get startTime(){const{resolved:t}=this;if(!t)return null;const{animation:e}=t;return e.startTime}attachTimeline(t){if(this._resolved){const{resolved:n}=this;if(!n)return e;const{animation:s}=n;wn(s,t)}else this.pendingTimeline=t;return e}play(){if(this.isStopped)return;const{resolved:t}=this;if(!t)return;const{animation:e}=t;"finished"===e.playState&&this.updateFinishedPromise(),e.play()}pause(){const{resolved:t}=this;if(!t)return;const{animation:e}=t;e.pause()}stop(){if(this.resolver.cancel(),this.isStopped=!0,"idle"===this.state)return;this.resolveFinishedPromise(),this.updateFinishedPromise();const{resolved:t}=this;if(!t)return;const{animation:e,keyframes:n,duration:s,type:i,ease:r,times:o}=t;if("idle"===e.playState||"finished"===e.playState)return;if(this.time){const{motionValue:t,onUpdate:e,onComplete:a,element:l,...u}=this.options,c=new un({...u,keyframes:n,duration:s,type:i,ease:r,times:o,isGenerator:!0}),h=w(this.time);t.setWithVelocity(c.sample(h-10).value,c.sample(h).value,10)}const{onStop:a}=this.options;a&&a(),this.cancel()}complete(){const{resolved:t}=this;t&&t.animation.finish()}cancel(){const{resolved:t}=this;t&&t.animation.cancel()}static supports(t){const{motionValue:e,name:n,repeatDelay:s,repeatType:i,damping:r,type:o}=t;return bn()&&n&&cn.has(n)&&e&&e.owner&&e.owner.current instanceof HTMLElement&&!e.owner.getProps().onUpdate&&!s&&"mirror"!==i&&0!==r&&"inertia"!==o}}const Sn=(t,e,n,s={},r,o)=>a=>{const l=at(s,t)||{},u=l.delay||s.delay||0;let{elapsed:c=0}=s;c-=w(u);let h={keyframes:Array.isArray(n)?n:[null,n],ease:"easeOut",velocity:e.getVelocity(),...l,delay:-c,onUpdate:t=>{e.set(t),l.onUpdate&&l.onUpdate(t)},onComplete:()=>{a(),l.onComplete&&l.onComplete()},name:t,motionValue:e,element:o?void 0:r};(function({when:t,delay:e,delayChildren:n,staggerChildren:s,staggerDirection:i,repeat:r,repeatType:o,repeatDelay:a,from:l,elapsed:u,...c}){return!!Object.keys(c).length})(l)||(h={...h,...ot(t,h)}),h.duration&&(h.duration=w(h.duration)),h.repeatDelay&&(h.repeatDelay=w(h.repeatDelay)),void 0!==h.from&&(h.keyframes[0]=h.from);let d=!1;if((!1===h.type||0===h.duration&&!h.repeatDelay)&&(h.duration=0,0===h.delay&&(d=!0)),d&&!o&&void 0!==e.get()){const t=ut(h.keyframes,l);if(void 0!==t)return i.update(()=>{h.onUpdate(t),h.onComplete()}),new v([])}return!o&&Tn.supports(h)?new Tn(h):new un(h)},Vn=t=>(t=>Array.isArray(t))(t)?t[t.length-1]||0:t;function An(t){const e=[{},{}];return null==t||t.values.forEach((t,n)=>{e[0][n]=t.get(),e[1][n]=t.getVelocity()}),e}function Mn(t,e,n,s){if("function"==typeof e){const[i,r]=An(s);e=e(void 0!==n?n:t.custom,i,r)}if("string"==typeof e&&(e=t.variants&&t.variants[e]),"function"==typeof e){const[i,r]=An(s);e=e(void 0!==n?n:t.custom,i,r)}return e}function Pn(t,e,n){t.hasValue(e)?t.getValue(e).set(n):t.addValue(e,m(n))}function kn(t,e){const n=function(t,e,n){const s=t.getProps();return Mn(s,e,void 0!==n?n:s.custom,t)}(t,e);let{transitionEnd:s={},transition:i={},...r}=n||{};r={...r,...s};for(const e in r){Pn(t,e,Vn(r[e]))}}const Fn=t=>t.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),Cn="data-"+Fn("framerAppearId");function En(t){return t.props[Cn]}function On(t,e){const n=t.getValue("willChange");if(s=n,Boolean(W(s)&&s.add))return n.add(e);var s}function Rn({protectedKeys:t,needsAnimating:e},n){const s=t.hasOwnProperty(n)&&!0!==e[n];return e[n]=!1,s}function In(t,e,{delay:n=0,transitionOverride:s,type:r}={}){var o;let{transition:a=t.getDefaultTransition(),transitionEnd:l,...u}=e;s&&(a=s);const c=[],h=r&&t.animationState&&t.animationState.getState()[r];for(const e in u){const s=t.getValue(e,null!==(o=t.latestValues[e])&&void 0!==o?o:null),r=u[e];if(void 0===r||h&&Rn(h,e))continue;const l={delay:n,...at(a||{},e)};let d=!1;if(window.MotionHandoffAnimation){const n=En(t);if(n){const t=window.MotionHandoffAnimation(n,e,i);null!==t&&(l.startTime=t,d=!0)}}On(t,e),s.start(Sn(e,s,r,t.shouldReduceMotion&&nt.has(e)?{type:!1}:l,t,d));const p=s.animation;p&&c.push(p)}return l&&Promise.all(c).then(()=>{i.update(()=>{l&&kn(t,l)})}),c}const Bn={};function Ln(t,{layout:e,layoutId:n}){return nt.has(t)||t.startsWith("origin")||(e||void 0!==n)&&(!!Bn[t]||"opacity"===t)}function Wn(t,e,n){var s;const{style:i}=t,r={};for(const o in i)(W(i[o])||e.style&&W(e.style[o])||Ln(o,t)||void 0!==(null===(s=null==n?void 0:n.getValue(o))||void 0===s?void 0:s.liveStyle))&&(r[o]=i[o]);return r}const Dn="undefined"!=typeof window,Nn={current:null},Kn={current:!1};const zn=["initial","animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"];function jn(t){return null!==(e=t.animate)&&"object"==typeof e&&"function"==typeof e.start||zn.some(e=>function(t){return"string"==typeof t||Array.isArray(t)}(t[e]));var e}const $n={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},Hn={};for(const t in $n)Hn[t]={isEnabled:e=>$n[t].some(t=>!!e[t])};const Un=[...Xt,he,ve],Yn=()=>({x:{min:0,max:0},y:{min:0,max:0}}),qn=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class Xn{scrapeMotionValuesFromProps(t,e,n){return{}}constructor({parent:t,props:e,presenceContext:n,reducedMotionConfig:s,blockInitialAnimation:r,visualState:o},a={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=ee,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const t=p.now();this.renderScheduledAt<t&&(this.renderScheduledAt=t,i.render(this.render,!1,!0))};const{latestValues:l,renderState:u}=o;this.latestValues=l,this.baseTarget={...l},this.initialValues=e.initial?{...l}:{},this.renderState=u,this.parent=t,this.props=e,this.presenceContext=n,this.depth=t?t.depth+1:0,this.reducedMotionConfig=s,this.options=a,this.blockInitialAnimation=Boolean(r),this.isControllingVariants=jn(e),this.isVariantNode=function(t){return Boolean(jn(t)||t.variants)}(e),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=Boolean(t&&t.current);const{willChange:c,...h}=this.scrapeMotionValuesFromProps(e,{},this);for(const t in h){const e=h[t];void 0!==l[t]&&W(e)&&e.set(l[t],!1)}}mount(t){this.current=t,tt.set(t,this),this.projection&&!this.projection.instance&&this.projection.mount(t),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((t,e)=>this.bindToMotionValue(e,t)),Kn.current||function(){if(Kn.current=!0,Dn)if(window.matchMedia){const t=window.matchMedia("(prefers-reduced-motion)"),e=()=>Nn.current=t.matches;t.addListener(e),e()}else Nn.current=!1}(),this.shouldReduceMotion="never"!==this.reducedMotionConfig&&("always"===this.reducedMotionConfig||Nn.current),this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){tt.delete(this.current),this.projection&&this.projection.unmount(),r(this.notifyUpdate),r(this.render),this.valueSubscriptions.forEach(t=>t()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const t in this.events)this.events[t].clear();for(const t in this.features){const e=this.features[t];e&&(e.unmount(),e.isMounted=!1)}this.current=null}bindToMotionValue(t,e){this.valueSubscriptions.has(t)&&this.valueSubscriptions.get(t)();const n=nt.has(t),s=e.on("change",e=>{this.latestValues[t]=e,this.props.onUpdate&&i.preRender(this.notifyUpdate),n&&this.projection&&(this.projection.isTransformDirty=!0)}),r=e.on("renderRequest",this.scheduleRender);let o;window.MotionCheckAppearSync&&(o=window.MotionCheckAppearSync(this,t,e)),this.valueSubscriptions.set(t,()=>{s(),r(),o&&o(),e.owner&&e.stop()})}sortNodePosition(t){return this.current&&this.sortInstanceNodePosition&&this.type===t.type?this.sortInstanceNodePosition(this.current,t.current):0}updateFeatures(){let t="animation";for(t in Hn){const e=Hn[t];if(!e)continue;const{isEnabled:n,Feature:s}=e;if(!this.features[t]&&s&&n(this.props)&&(this.features[t]=new s(this)),this.features[t]){const e=this.features[t];e.isMounted?e.update():(e.mount(),e.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):{x:{min:0,max:0},y:{min:0,max:0}}}getStaticValue(t){return this.latestValues[t]}setStaticValue(t,e){this.latestValues[t]=e}update(t,e){(t.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=t,this.prevPresenceContext=this.presenceContext,this.presenceContext=e;for(let e=0;e<qn.length;e++){const n=qn[e];this.propEventSubscriptions[n]&&(this.propEventSubscriptions[n](),delete this.propEventSubscriptions[n]);const s=t["on"+n];s&&(this.propEventSubscriptions[n]=this.on(n,s))}this.prevMotionValues=function(t,e,n){for(const s in e){const i=e[s],r=n[s];if(W(i))t.addValue(s,i);else if(W(r))t.addValue(s,m(i,{owner:t}));else if(r!==i)if(t.hasValue(s)){const e=t.getValue(s);!0===e.liveStyle?e.jump(i):e.hasAnimated||e.set(i)}else{const e=t.getStaticValue(s);t.addValue(s,m(void 0!==e?e:i,{owner:t}))}}for(const s in n)void 0===e[s]&&t.removeValue(s);return e}(this,this.scrapeMotionValuesFromProps(t,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(t){return this.props.variants?this.props.variants[t]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(t){const e=this.getClosestVariantNode();if(e)return e.variantChildren&&e.variantChildren.add(t),()=>e.variantChildren.delete(t)}addValue(t,e){const n=this.values.get(t);e!==n&&(n&&this.removeValue(t),this.bindToMotionValue(t,e),this.values.set(t,e),this.latestValues[t]=e.get())}removeValue(t){this.values.delete(t);const e=this.valueSubscriptions.get(t);e&&(e(),this.valueSubscriptions.delete(t)),delete this.latestValues[t],this.removeValueFromRenderState(t,this.renderState)}hasValue(t){return this.values.has(t)}getValue(t,e){if(this.props.values&&this.props.values[t])return this.props.values[t];let n=this.values.get(t);return void 0===n&&void 0!==e&&(n=m(null===e?void 0:e,{owner:this}),this.addValue(t,n)),n}readValue(t,e){var n;let s=void 0===this.latestValues[t]&&this.current?null!==(n=this.getBaseTargetFromProps(this.props,t))&&void 0!==n?n:this.readValueFromInstance(this.current,t,this.options):this.latestValues[t];var i;return null!=s&&("string"==typeof s&&(Tt(s)||xt(s))?s=parseFloat(s):(i=s,!Un.find(qt(i))&&ve.test(e)&&(s=Fe(t,e))),this.setBaseTarget(t,W(s)?s.get():s)),W(s)?s.get():s}setBaseTarget(t,e){this.baseTarget[t]=e}getBaseTarget(t){var e;const{initial:n}=this.props;let s;if("string"==typeof n||"object"==typeof n){const i=Mn(this.props,n,null===(e=this.presenceContext)||void 0===e?void 0:e.custom);i&&(s=i[t])}if(n&&void 0!==s)return s;const i=this.getBaseTargetFromProps(this.props,t);return void 0===i||W(i)?void 0!==this.initialValues[t]&&void 0===s?void 0:this.baseTarget[t]:i}on(t,e){return this.events[t]||(this.events[t]=new u),this.events[t].add(e)}notify(t,...e){this.events[t]&&this.events[t].notify(...e)}}class Gn extends Xn{constructor(){super(...arguments),this.KeyframeResolver=Ee}sortInstanceNodePosition(t,e){return 2&t.compareDocumentPosition(e)?1:-1}getBaseTargetFromProps(t,e){return t.style?t.style[e]:void 0}removeValueFromRenderState(t,{vars:e,style:n}){delete e[t],delete n[t]}}const Zn=(t,e)=>e&&"number"==typeof t?e.transform(t):t,_n={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},Jn=et.length;function Qn(t,e,n){const{style:s,vars:i,transformOrigin:r}=t;let o=!1,a=!1;for(const t in e){const n=e[t];if(nt.has(t))o=!0;else if(Vt(t))i[t]=n;else{const e=Zn(n,Me[t]);t.startsWith("origin")?(a=!0,r[t]=e):s[t]=e}}if(e.transform||(o||n?s.transform=function(t,e,n){let s="",i=!0;for(let r=0;r<Jn;r++){const o=et[r],a=t[o];if(void 0===a)continue;let l=!0;if(l="number"==typeof a?a===(o.startsWith("scale")?1:0):0===parseFloat(a),!l||n){const t=Zn(a,Me[o]);if(!l){i=!1;s+=`${_n[o]||o}(${t}) `}n&&(e[o]=t)}}return s=s.trim(),n?s=n(e,i?"":s):i&&(s="none"),s}(e,t.transform,n):s.transform&&(s.transform="none")),a){const{originX:t="50%",originY:e="50%",originZ:n=0}=r;s.transformOrigin=`${t} ${e} ${n}`}}function ts(t,e,n){return"string"==typeof t?t:Lt.transform(e+n*t)}const es={offset:"stroke-dashoffset",array:"stroke-dasharray"},ns={offset:"strokeDashoffset",array:"strokeDasharray"};function ss(t,{attrX:e,attrY:n,attrScale:s,originX:i,originY:r,pathLength:o,pathSpacing:a=1,pathOffset:l=0,...u},c,h){if(Qn(t,u,h),c)return void(t.style.viewBox&&(t.attrs.viewBox=t.style.viewBox));t.attrs=t.style,t.style={};const{attrs:d,style:p,dimensions:f}=t;d.transform&&(f&&(p.transform=d.transform),delete d.transform),f&&(void 0!==i||void 0!==r||p.transform)&&(p.transformOrigin=function(t,e,n){return`${ts(e,t.x,t.width)} ${ts(n,t.y,t.height)}`}(f,void 0!==i?i:.5,void 0!==r?r:.5)),void 0!==e&&(d.x=e),void 0!==n&&(d.y=n),void 0!==s&&(d.scale=s),void 0!==o&&function(t,e,n=1,s=0,i=!0){t.pathLength=1;const r=i?es:ns;t[r.offset]=Lt.transform(-s);const o=Lt.transform(e),a=Lt.transform(n);t[r.array]=`${o} ${a}`}(d,o,a,l,!1)}const is=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function rs(t,{style:e,vars:n},s,i){Object.assign(t.style,e,i&&i.getProjectionStyles(s));for(const e in n)t.style.setProperty(e,n[e])}class os extends Gn{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=Yn}getBaseTargetFromProps(t,e){return t[e]}readValueFromInstance(t,e){if(nt.has(e)){const t=ke(e);return t&&t.default||0}return e=is.has(e)?e:Fn(e),t.getAttribute(e)}scrapeMotionValuesFromProps(t,e,n){return function(t,e,n){const s=Wn(t,e,n);for(const n in t)if(W(t[n])||W(e[n])){s[-1!==et.indexOf(n)?"attr"+n.charAt(0).toUpperCase()+n.substring(1):n]=t[n]}return s}(t,e,n)}build(t,e,n){ss(t,e,this.isSVGTag,n.transformTemplate)}renderInstance(t,e,n,s){!function(t,e,n,s){rs(t,e,void 0,s);for(const n in e.attrs)t.setAttribute(is.has(n)?n:Fn(n),e.attrs[n])}(t,e,0,s)}mount(t){var e;this.isSVGTag="string"==typeof(e=t.tagName)&&"svg"===e.toLowerCase(),super.mount(t)}}class as extends Gn{constructor(){super(...arguments),this.type="html",this.renderInstance=rs}readValueFromInstance(t,e){if(nt.has(e)){const t=ke(e);return t&&t.default||0}{const s=(n=t,window.getComputedStyle(n)),i=(Vt(e)?s.getPropertyValue(e):s[e])||0;return"string"==typeof i?i.trim():i}var n}measureInstanceViewportBox(t,{transformPagePoint:e}){return function(t,e){return function({top:t,left:e,right:n,bottom:s}){return{x:{min:e,max:n},y:{min:t,max:s}}}(function(t,e){if(!e)return t;const n=e({x:t.left,y:t.top}),s=e({x:t.right,y:t.bottom});return{top:n.y,left:n.x,bottom:s.y,right:s.x}}(t.getBoundingClientRect(),e))}(t,e)}build(t,e,n){Qn(t,e,n.transformTemplate)}scrapeMotionValuesFromProps(t,e,n){return Wn(t,e,n)}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:t}=this.props;W(t)&&(this.childSubscription=t.on("change",t=>{this.current&&(this.current.textContent=""+t)}))}}class ls extends Xn{constructor(){super(...arguments),this.type="object"}readValueFromInstance(t,e){if(function(t,e){return t in e}(e,t)){const n=t[e];if("string"==typeof n||"number"==typeof n)return n}}getBaseTargetFromProps(){}removeValueFromRenderState(t,e){delete e.output[t]}measureInstanceViewportBox(){return{x:{min:0,max:0},y:{min:0,max:0}}}build(t,e){Object.assign(t.output,e)}renderInstance(t,{output:e}){Object.assign(t,e)}sortInstanceNodePosition(){return 0}}function us(t){const e={presenceContext:null,props:{},visualState:{renderState:{transform:{},transformOrigin:{},style:{},vars:{},attrs:{}},latestValues:{}}},n=function(t){return t instanceof SVGElement&&"svg"!==t.tagName}(t)?new os(e):new as(e);n.mount(t),tt.set(t,n)}function cs(t){const e=new ls({presenceContext:null,props:{},visualState:{renderState:{output:{}},latestValues:{}}});e.mount(t),tt.set(t,e)}function hs(t,e,n,s){const i=[];if(function(t,e){return W(t)||"number"==typeof t||"string"==typeof t&&!N(e)}(t,e))i.push(function(t,e,n){const s=W(t)?t:m(t);return s.start(Sn("",s,e,n)),s.animation}(t,N(e)&&e.default||e,n&&n.default||n));else{const r=K(t,e,s),o=r.length;for(let t=0;t<o;t++){const s=r[t],a=s instanceof Element?us:cs;tt.has(s)||a(s);const l=tt.get(s),u={...n};"delay"in u&&"function"==typeof u.delay&&(u.delay=u.delay(t,o)),i.push(...In(l,{...e,transition:u},{}))}}return i}function ds(t,e,n){const s=[];return function(t,{defaultTransition:e={},...n}={},s,i){const r=e.duration||.3,o=new Map,a=new Map,l={},u=new Map;let c=0,h=0,d=0;for(let n=0;n<t.length;n++){const o=t[n];if("string"==typeof o){u.set(o,h);continue}if(!Array.isArray(o)){u.set(o.name,j(h,o.at,c,u));continue}let[p,f,m={}]=o;void 0!==m.at&&(h=j(h,m.at,c,u));let g=0;const y=(t,n,s,o=0,a=0)=>{const l=Z(t),{delay:u=0,times:c=L(l),type:p="keyframes",...f}=n;let{ease:m=e.ease||"easeOut",duration:y}=n;const v="function"==typeof u?u(o,a):u,b=l.length,x=z(p)?p:null==i?void 0:i[p];if(b<=2&&x){let t=100;if(2===b&&Q(l)){const e=l[1]-l[0];t=Math.abs(e)}const e={...f};void 0!==y&&(e.duration=w(y));const n=O(e,t,x);m=n.ease,y=n.duration}null!=y||(y=r);const T=h+v,S=T+y;1===c.length&&0===c[0]&&(c[1]=1);const V=c.length-l.length;V>0&&B(c,V),1===l.length&&l.unshift(null),Y(s,l,m,c,T,S),g=Math.max(v+y,g),d=Math.max(S,d)};if(W(p)){y(f,m,G("default",X(p,a)))}else{const t=K(p,f,s,l),e=t.length;for(let n=0;n<e;n++){f=f,m=m;const s=X(t[n],a);for(const t in f)y(f[t],_(m,t),G(t,s),n,e)}}c=h,h+=g}return a.forEach((t,s)=>{for(const i in t){const r=t[i];r.sort(q);const a=[],l=[],u=[];for(let t=0;t<r.length;t++){const{at:e,value:n,easing:s}=r[t];a.push(n),l.push(I(0,d,e)),u.push(s||"easeOut")}0!==l[0]&&(l.unshift(0),a.unshift(a[0]),u.unshift("easeInOut")),1!==l[l.length-1]&&(l.push(1),a.push(null)),o.has(s)||o.set(s,{keyframes:{},transition:{}});const c=o.get(s);c.keyframes[i]=a,c.transition[i]={...e,duration:d,ease:u,times:l,...n}}}),o}(t,e,n,{spring:C}).forEach(({keyframes:t,transition:e},n)=>{s.push(...hs(n,t,e))}),s}function ps(t){return function(e,n,s){let i=[];var r;r=e,i=Array.isArray(r)&&Array.isArray(r[0])?ds(e,n,t):hs(e,n,s,t);const o=new v(i);return t&&t.animations.push(o),o}}const fs=ps();function ms(t,e,n){t.style.setProperty("--"+e,n)}function gs(t,e,n){t.style[e]=n}const ys=g(()=>{try{document.createElement("div").animate({opacity:[1]})}catch(t){return!1}return!0}),vs=new WeakMap;function ws(t){const e=vs.get(t)||new Map;return vs.set(t,e),vs.get(t)}class bs{constructor(t,e,n,s){const i=e.startsWith("--");this.setValue=i?ms:gs,this.options=s,this.updateFinishedPromise(),S("string"!=typeof s.type);const r=ws(t).get(e);r&&r.stop();if(Array.isArray(n)||(n=[n]),function(t,e,n){for(let s=0;s<e.length;s++)null===e[s]&&(e[s]=0===s?n():e[s-1]),"number"==typeof e[s]&&Se[t]&&(e[s]=Se[t].transform(e[s]));!ys()&&e.length<2&&e.unshift(n())}(e,n,()=>e.startsWith("--")?t.style.getPropertyValue(e):window.getComputedStyle(t)[e]),z(s.type)){const t=O(s,100,s.type);s.ease=pn()?t.ease:"easeOut",s.duration=w(t.duration),s.type="keyframes"}else s.ease=s.ease||"easeOut";this.removeAnimation=()=>{var n;return null===(n=vs.get(t))||void 0===n?void 0:n.delete(e)};const o=()=>{this.setValue(t,e,ut(n,this.options)),this.cancel(),this.resolveFinishedPromise()};bn()?(this.animation=vn(t,e,n,s),!1===s.autoplay&&this.animation.pause(),this.animation.onfinish=o,this.pendingTimeline&&wn(this.animation,this.pendingTimeline),ws(t).set(e,this)):o()}get duration(){return b(this.options.duration||300)}get time(){var t;return this.animation?b((null===(t=this.animation)||void 0===t?void 0:t.currentTime)||0):0}set time(t){this.animation&&(this.animation.currentTime=w(t))}get speed(){return this.animation?this.animation.playbackRate:1}set speed(t){this.animation&&(this.animation.playbackRate=t)}get state(){return this.animation?this.animation.playState:"finished"}get startTime(){return this.animation?this.animation.startTime:null}play(){"finished"===this.state&&this.updateFinishedPromise(),this.animation&&this.animation.play()}pause(){this.animation&&this.animation.pause()}stop(){this.animation&&"idle"!==this.state&&"finished"!==this.state&&(this.animation.commitStyles&&this.animation.commitStyles(),this.cancel())}complete(){this.animation&&this.animation.finish()}cancel(){this.removeAnimation();try{this.animation&&this.animation.cancel()}catch(t){}}then(t,e){return this.currentFinishedPromise.then(t,e)}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}attachTimeline(t){return this.animation?wn(this.animation,t):this.pendingTimeline=t,e}}const xs=(t=>function(e,n,s){return new v(function(t,e,n,s){const i=D(t,s),r=i.length,o=[];for(let t=0;t<r;t++){const s=i[t],a={...n};"function"==typeof a.delay&&(a.delay=a.delay(t,r));for(const t in e){const i=e[t],r={...at(n,t)};r.duration=r.duration?w(r.duration):r.duration,r.delay=w(r.delay||0),o.push(new bs(s,t,i,r))}}return o}(e,n,s,t))})(),Ts=new WeakMap;let Ss;function Vs({target:t,contentRect:e,borderBoxSize:n}){var s;null===(s=Ts.get(t))||void 0===s||s.forEach(s=>{s({target:t,contentSize:e,get size(){return function(t,e){if(e){const{inlineSize:t,blockSize:n}=e[0];return{width:t,height:n}}return t instanceof SVGElement&&"getBBox"in t?t.getBBox():{width:t.offsetWidth,height:t.offsetHeight}}(t,n)}})})}function As(t){t.forEach(Vs)}function Ms(t,e){Ss||"undefined"!=typeof ResizeObserver&&(Ss=new ResizeObserver(As));const n=D(t);return n.forEach(t=>{let n=Ts.get(t);n||(n=new Set,Ts.set(t,n)),n.add(e),null==Ss||Ss.observe(t)}),()=>{n.forEach(t=>{const n=Ts.get(t);null==n||n.delete(e),(null==n?void 0:n.size)||null==Ss||Ss.unobserve(t)})}}const Ps=new Set;let ks;function Fs(t){return Ps.add(t),ks||(ks=()=>{const t={width:window.innerWidth,height:window.innerHeight},e={target:window,size:t,contentSize:t};Ps.forEach(t=>t(e))},window.addEventListener("resize",ks)),()=>{Ps.delete(t),!Ps.size&&ks&&(ks=void 0)}}const Cs={x:{length:"Width",position:"Left"},y:{length:"Height",position:"Top"}};function Es(t,e,n,s){const i=n[e],{length:r,position:o}=Cs[e],a=i.current,l=n.time;i.current=t["scroll"+o],i.scrollLength=t["scroll"+r]-t["client"+r],i.offset.length=0,i.offset[0]=0,i.offset[1]=i.scrollLength,i.progress=I(0,i.scrollLength,i.current);const u=s-l;i.velocity=u>50?0:c(i.current-a,u)}const Os={Enter:[[0,1],[1,1]],Exit:[[0,0],[1,0]],Any:[[1,0],[0,1]],All:[[0,0],[1,1]]},Rs={start:0,center:.5,end:1};function Is(t,e,n=0){let s=0;if(t in Rs&&(t=Rs[t]),"string"==typeof t){const e=parseFloat(t);t.endsWith("px")?s=e:t.endsWith("%")?t=e/100:t.endsWith("vw")?s=e/100*document.documentElement.clientWidth:t.endsWith("vh")?s=e/100*document.documentElement.clientHeight:t=e}return"number"==typeof t&&(s=e*t),n+s}const Bs=[0,0];function Ls(t,e,n,s){let i=Array.isArray(t)?t:Bs,r=0,o=0;return"number"==typeof t?i=[t,t]:"string"==typeof t&&(i=(t=t.trim()).includes(" ")?t.split(" "):[t,Rs[t]?t:"0"]),r=Is(i[0],n,s),o=Is(i[1],e),r-o}const Ws={x:0,y:0};function Ds(t,e,n){const{offset:s=Os.All}=n,{target:i=t,axis:r="y"}=n,o="y"===r?"height":"width",a=i!==t?function(t,e){const n={x:0,y:0};let s=t;for(;s&&s!==e;)if(s instanceof HTMLElement)n.x+=s.offsetLeft,n.y+=s.offsetTop,s=s.offsetParent;else if("svg"===s.tagName){const t=s.getBoundingClientRect();s=s.parentElement;const e=s.getBoundingClientRect();n.x+=t.left-e.left,n.y+=t.top-e.top}else{if(!(s instanceof SVGGraphicsElement))break;{const{x:t,y:e}=s.getBBox();n.x+=t,n.y+=e;let i=null,r=s.parentNode;for(;!i;)"svg"===r.tagName&&(i=r),r=s.parentNode;s=i}}return n}(i,t):Ws,l=i===t?{width:t.scrollWidth,height:t.scrollHeight}:function(t){return"getBBox"in t&&"svg"!==t.tagName?t.getBBox():{width:t.clientWidth,height:t.clientHeight}}(i),u={width:t.clientWidth,height:t.clientHeight};e[r].offset.length=0;let c=!e[r].interpolate;const h=s.length;for(let t=0;t<h;t++){const n=Ls(s[t],u[o],l[o],a[r]);c||n===e[r].interpolatorOffsets[t]||(c=!0),e[r].offset[t]=n}c&&(e[r].interpolate=sn(e[r].offset,L(s)),e[r].interpolatorOffsets=[...e[r].offset]),e[r].progress=e[r].interpolate(e[r].current)}function Ns(t,e,n,s={}){return{measure:()=>function(t,e=t,n){if(n.x.targetOffset=0,n.y.targetOffset=0,e!==t){let s=e;for(;s&&s!==t;)n.x.targetOffset+=s.offsetLeft,n.y.targetOffset+=s.offsetTop,s=s.offsetParent}n.x.targetLength=e===t?e.scrollWidth:e.clientWidth,n.y.targetLength=e===t?e.scrollHeight:e.clientHeight,n.x.containerLength=t.clientWidth,n.y.containerLength=t.clientHeight}(t,s.target,n),update:e=>{!function(t,e,n){Es(t,"x",e,n),Es(t,"y",e,n),e.time=n}(t,n,e),(s.offset||s.target)&&Ds(t,n,s)},notify:()=>e(n)}}const Ks=new WeakMap,zs=new WeakMap,js=new WeakMap,$s=t=>t===document.documentElement?window:t;function Hs(t,{container:e=document.documentElement,...n}={}){let s=js.get(e);s||(s=new Set,js.set(e,s));const a=Ns(e,t,{time:0,x:{current:0,offset:[],progress:0,scrollLength:0,targetOffset:0,targetLength:0,containerLength:0,velocity:0},y:{current:0,offset:[],progress:0,scrollLength:0,targetOffset:0,targetLength:0,containerLength:0,velocity:0}},n);if(s.add(a),!Ks.has(e)){const t=()=>{for(const t of s)t.measure()},n=()=>{for(const t of s)t.update(o.timestamp)},r=()=>{for(const t of s)t.notify()},a=()=>{i.read(t,!1,!0),i.read(n,!1,!0),i.update(r,!1,!0)};Ks.set(e,a);const c=$s(e);window.addEventListener("resize",a,{passive:!0}),e!==document.documentElement&&zs.set(e,(u=a,"function"==typeof(l=e)?Fs(l):Ms(l,u))),c.addEventListener("scroll",a,{passive:!0})}var l,u;const c=Ks.get(e);return i.read(c,!1,!0),()=>{var t;r(c);const n=js.get(e);if(!n)return;if(n.delete(a),n.size)return;const s=Ks.get(e);Ks.delete(e),s&&($s(e).removeEventListener("scroll",s),null===(t=zs.get(e))||void 0===t||t(),window.removeEventListener("resize",s))}}function Us(t,e){let n;const s=()=>{const{currentTime:s}=e,i=(null===s?0:s.value)/100;n!==i&&t(i),n=i};return i.update(s,!0),()=>r(s)}const Ys=new Map;function qs({source:t,container:e=document.documentElement,axis:n="y"}={}){t&&(e=t),Ys.has(e)||Ys.set(e,{});const s=Ys.get(e);return s[n]||(s[n]=y()?new ScrollTimeline({source:e,axis:n}):function({source:t,container:e,axis:n="y"}){t&&(e=t);const s={value:0},i=Hs(t=>{s.value=100*t[n].progress},{container:e,axis:n});return{currentTime:s,cancel:i}}({source:e,axis:n})),s[n]}function Xs(t){return t&&(t.target||t.offset)}const Gs={some:0,all:1};const Zs=(t,e)=>Math.abs(t-e);const _s=i,Js=s.reduce((t,e)=>(t[e]=t=>r(t),t),{});t.MotionValue=f,t.animate=fs,t.animateMini=xs,t.anticipate=yt,t.backIn=mt,t.backInOut=gt,t.backOut=ft,t.cancelFrame=r,t.cancelSync=Js,t.circIn=vt,t.circInOut=bt,t.circOut=wt,t.clamp=V,t.createScopedAnimate=ps,t.cubicBezier=ht,t.delay=function(t,e){return function(t,e){const n=p.now(),s=({timestamp:i})=>{const o=i-n;o>=e&&(r(s),t(o-e))};return i.read(s,!0),()=>r(s)}(t,w(e))},t.distance=Zs,t.distance2D=function(t,e){const n=Zs(t.x,e.x),s=Zs(t.y,e.y);return Math.sqrt(n**2+s**2)},t.easeIn=Le,t.easeInOut=De,t.easeOut=We,t.frame=i,t.frameData=o,t.frameSteps=a,t.inView=function(t,e,{root:n,margin:s,amount:i="some"}={}){const r=D(t),o=new WeakMap,a=new IntersectionObserver(t=>{t.forEach(t=>{const n=o.get(t.target);if(t.isIntersecting!==Boolean(n))if(t.isIntersecting){const n=e(t);"function"==typeof n?o.set(t.target,n):a.unobserve(t.target)}else n&&(n(t),o.delete(t.target))})},{root:n,rootMargin:s,threshold:"number"==typeof i?i:Gs[i]});return r.forEach(t=>a.observe(t)),()=>a.disconnect()},t.inertia=Be,t.interpolate=sn,t.invariant=S,t.keyframes=rn,t.mirrorEasing=dt,t.mix=nn,t.motionValue=m,t.pipe=$e,t.progress=I,t.reverseEasing=pt,t.scroll=function(t,{axis:e="y",...n}={}){const s={axis:e,...n};return"function"==typeof t?function(t,e){return function(t){return 2===t.length}(t)||Xs(e)?Hs(n=>{t(n[e.axis].progress,n)},e):Us(t,qs(e))}(t,s):function(t,e){if(Xs(e))return t.pause(),Hs(n=>{t.time=t.duration*n[e.axis].progress},e);{const n=qs(e);return t.attachTimeline(n,t=>(t.pause(),Us(e=>{t.time=t.duration*e},n)))}}(t,s)},t.scrollInfo=Hs,t.spring=C,t.stagger=function(t=.1,{startDelay:e=0,from:n=0,ease:s}={}){return(i,r)=>{const o="number"==typeof n?n:function(t,e){if("first"===t)return 0;{const n=e-1;return"last"===t?n:n/2}}(n,r),a=Math.abs(o-i);let l=t*a;if(s){const e=r*t;l=ze(s)(l/e)*e}return e+l}},t.steps=function(t,e="end"){return n=>{const s=(n="end"===e?Math.min(n,.999):Math.max(n,.001))*t,i="end"===e?Math.floor(s):Math.ceil(s);return V(0,1,i/t)}},t.sync=_s,t.transform=function(...t){const e=!Array.isArray(t[0]),n=e?0:-1,s=t[0+n],i=t[1+n],r=t[2+n],o=t[3+n],a=sn(i,r,{mixer:(l=r[0],(t=>t&&"object"==typeof t&&t.mix)(l)?l.mix:void 0),...o});var l;return e?a(s):a},t.warning=T,t.wrap=$}));
diff --git a/dist/es/animation/GroupPlaybackControls.mjs b/dist/es/animation/GroupPlaybackControls.mjs
index b7ed5ddd00b4d3b85934dc2c6154bce4b8cbd10a..7b6d14e4a23cd7ce886e7b68a151dcdd442a9f25 100644
--- a/dist/es/animation/GroupPlaybackControls.mjs
+++ b/dist/es/animation/GroupPlaybackControls.mjs
@@ -61,9 +61,6 @@ class GroupPlaybackControls {
     runAll(methodName) {
         this.animations.forEach((controls) => controls[methodName]());
     }
-    flatten() {
-        this.runAll("flatten");
-    }
     play() {
         this.runAll("play");
     }
diff --git a/dist/es/animation/animate/resolve-subjects.mjs b/dist/es/animation/animate/resolve-subjects.mjs
index cb9c63d6558cb8c58f5a532d1bc5279d6ca89571..327372d357a417c3449452d8b83305029ec72e53 100644
--- a/dist/es/animation/animate/resolve-subjects.mjs
+++ b/dist/es/animation/animate/resolve-subjects.mjs
@@ -1,4 +1,4 @@
-import { resolveElements } from 'motion-dom';
+import { resolveElements } from '../../render/dom/utils/resolve-element.mjs';
 import { isDOMKeyframes } from '../utils/is-dom-keyframes.mjs';
 
 function resolveSubjects(subject, keyframes, scope, selectorCache) {
diff --git a/dist/es/animation/animate/subject.mjs b/dist/es/animation/animate/subject.mjs
index a4f6441a388c0447e7acb9946191c0ca5d463feb..2e093c7fb371f08cb21397054899064705c0b430 100644
--- a/dist/es/animation/animate/subject.mjs
+++ b/dist/es/animation/animate/subject.mjs
@@ -1,5 +1,5 @@
-import { invariant } from 'motion-utils';
 import { visualElementStore } from '../../render/store.mjs';
+import { invariant } from '../../utils/errors.mjs';
 import { isMotionValue } from '../../value/utils/is-motion-value.mjs';
 import { animateTarget } from '../interfaces/visual-element-target.mjs';
 import { createDOMVisualElement, createObjectVisualElement } from '../utils/create-visual-element.mjs';
diff --git a/dist/es/animation/animators/AcceleratedAnimation.mjs b/dist/es/animation/animators/AcceleratedAnimation.mjs
index 73c70a815ac89ce2f4a0eae0f54c1d108ae0ad40..1071cb26e6a39a93ac0f8e65bd520c90ab9bc409 100644
--- a/dist/es/animation/animators/AcceleratedAnimation.mjs
+++ b/dist/es/animation/animators/AcceleratedAnimation.mjs
@@ -2,7 +2,7 @@ import { anticipate } from '../../easing/anticipate.mjs';
 import { backInOut } from '../../easing/back.mjs';
 import { circInOut } from '../../easing/circ.mjs';
 import { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';
-import { noop } from 'motion-utils';
+import { noop } from '../../utils/noop.mjs';
 import { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';
 import { isGenerator } from '../generators/utils/is-generator.mjs';
 import { BaseAnimation } from './BaseAnimation.mjs';
diff --git a/dist/es/animation/animators/BaseAnimation.mjs b/dist/es/animation/animators/BaseAnimation.mjs
index d4ca345c6f6e0e28a1bf61783850e779b7fc8211..f5343b6b9d0d572e211b550fecaa7d66237b3dae 100644
--- a/dist/es/animation/animators/BaseAnimation.mjs
+++ b/dist/es/animation/animators/BaseAnimation.mjs
@@ -103,10 +103,6 @@ class BaseAnimation {
     then(resolve, reject) {
         return this.currentFinishedPromise.then(resolve, reject);
     }
-    flatten() {
-        this.options.type = "keyframes";
-        this.options.ease = "linear";
-    }
     updateFinishedPromise() {
         this.currentFinishedPromise = new Promise((resolve) => {
             this.resolveFinishedPromise = resolve;
diff --git a/dist/es/animation/animators/MainThreadAnimation.mjs b/dist/es/animation/animators/MainThreadAnimation.mjs
index 76dc70781f48b48b95c77dc7c69b620a88d2975f..4386392defa3567cecad7e071a56095afe856171 100644
--- a/dist/es/animation/animators/MainThreadAnimation.mjs
+++ b/dist/es/animation/animators/MainThreadAnimation.mjs
@@ -8,7 +8,7 @@ import { mix } from '../../utils/mix/index.mjs';
 import { calcGeneratorDuration } from '../generators/utils/calc-duration.mjs';
 import { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';
 import { clamp } from '../../utils/clamp.mjs';
-import { invariant } from 'motion-utils';
+import { invariant } from '../../utils/errors.mjs';
 import { frameloopDriver } from './drivers/driver-frameloop.mjs';
 import { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';
 import { isGenerator } from '../generators/utils/is-generator.mjs';
@@ -75,13 +75,6 @@ class MainThreadAnimation extends BaseAnimation {
         this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);
         this.resolver.scheduleResolve();
     }
-    flatten() {
-        super.flatten();
-        // If we've already resolved the animation, re-initialise it
-        if (this._resolved) {
-            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
-        }
-    }
     initPlayback(keyframes$1) {
         const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;
         const generatorFactory = isGenerator(type)
diff --git a/dist/es/animation/animators/utils/can-animate.mjs b/dist/es/animation/animators/utils/can-animate.mjs
index d8a9d67aac882167f142e287b9cd9065fa3fd011..133eb550939b5e4816ecc96ef88cb9e69dd5ae53 100644
--- a/dist/es/animation/animators/utils/can-animate.mjs
+++ b/dist/es/animation/animators/utils/can-animate.mjs
@@ -1,4 +1,4 @@
-import { warning } from 'motion-utils';
+import { warning } from '../../../utils/errors.mjs';
 import { isGenerator } from '../../generators/utils/is-generator.mjs';
 import { isAnimatable } from '../../utils/is-animatable.mjs';
 
diff --git a/dist/es/animation/animators/waapi/NativeAnimation.mjs b/dist/es/animation/animators/waapi/NativeAnimation.mjs
index 2f97b84a79fa9903d29b4fb01e080dae5e1aecd0..1e04f1889996f57a7f92f49aea66052fcce6e237 100644
--- a/dist/es/animation/animators/waapi/NativeAnimation.mjs
+++ b/dist/es/animation/animators/waapi/NativeAnimation.mjs
@@ -1,7 +1,8 @@
 import { startWaapiAnimation } from './index.mjs';
 import { createGeneratorEasing } from '../../../easing/utils/create-generator-easing.mjs';
 import { browserNumberValueTypes } from '../../../render/dom/value-types/number-browser.mjs';
-import { invariant, noop } from 'motion-utils';
+import { invariant } from '../../../utils/errors.mjs';
+import { noop } from '../../../utils/noop.mjs';
 import { secondsToMilliseconds, millisecondsToSeconds } from '../../../utils/time-conversion.mjs';
 import { isGenerator } from '../../generators/utils/is-generator.mjs';
 import { attachTimeline } from './utils/attach-timeline.mjs';
@@ -50,7 +51,6 @@ class NativeAnimation {
             valueKeyframes = [valueKeyframes];
         }
         hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe);
-        // TODO: Replace this with toString()?
         if (isGenerator(options.type)) {
             const generatorOptions = createGeneratorEasing(options, 100, options.type);
             options.ease = supportsLinearEasing()
@@ -112,12 +112,6 @@ class NativeAnimation {
     get startTime() {
         return this.animation ? this.animation.startTime : null;
     }
-    flatten() {
-        var _a;
-        if (!this.animation)
-            return;
-        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: "linear" });
-    }
     play() {
         if (this.state === "finished") {
             this.updateFinishedPromise();
diff --git a/dist/es/animation/animators/waapi/animate-elements.mjs b/dist/es/animation/animators/waapi/animate-elements.mjs
index 47a34c86656fed795edff73e0aded5dae82b689d..6fdcfd18a84d48bca7ed1f7881ab1b87f0f55ad4 100644
--- a/dist/es/animation/animators/waapi/animate-elements.mjs
+++ b/dist/es/animation/animators/waapi/animate-elements.mjs
@@ -1,5 +1,5 @@
-import { resolveElements } from 'motion-dom';
-import { invariant } from 'motion-utils';
+import { resolveElements } from '../../../render/dom/utils/resolve-element.mjs';
+import { invariant } from '../../../utils/errors.mjs';
 import { secondsToMilliseconds } from '../../../utils/time-conversion.mjs';
 import { getValueTransition } from '../../utils/get-value-transition.mjs';
 import { NativeAnimation } from './NativeAnimation.mjs';
@@ -21,7 +21,7 @@ function animateElements(elementOrSelector, keyframes, options, scope) {
         for (const valueName in keyframes) {
             const valueKeyframes = keyframes[valueName];
             const valueOptions = {
-                ...getValueTransition(elementTransition, valueName),
+                ...getValueTransition(options, valueName),
             };
             valueOptions.duration = valueOptions.duration
                 ? secondsToMilliseconds(valueOptions.duration)
diff --git a/dist/es/animation/animators/waapi/index.mjs b/dist/es/animation/animators/waapi/index.mjs
index 94bf4ca02b8ec715582a622fc2499ecbd41023af..050a84666117de93337b30dccc56c9e64d32dcf5 100644
--- a/dist/es/animation/animators/waapi/index.mjs
+++ b/dist/es/animation/animators/waapi/index.mjs
@@ -1,6 +1,6 @@
 import { mapEasingToNativeEasing } from './easing.mjs';
 
-function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeInOut", times, } = {}) {
+function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease, times, } = {}) {
     const keyframeOptions = { [valueName]: keyframes };
     if (times)
         keyframeOptions.offset = times;
diff --git a/dist/es/animation/animators/waapi/utils/linear.mjs b/dist/es/animation/animators/waapi/utils/linear.mjs
index b24ace777fef9f0447809a6916a1f3023f421162..0b809c4170974364a298c397eaf1ed8403c368b3 100644
--- a/dist/es/animation/animators/waapi/utils/linear.mjs
+++ b/dist/es/animation/animators/waapi/utils/linear.mjs
@@ -1,7 +1,8 @@
 import { progress } from '../../../../utils/progress.mjs';
 
-const generateLinearEasing = (easing, duration, // as milliseconds
-resolution = 10 // as milliseconds
+// Create a linear easing point for every 10 ms
+const resolution = 10;
+const generateLinearEasing = (easing, duration // as milliseconds
 ) => {
     let points = "";
     const numPoints = Math.max(Math.round(duration / resolution), 2);
diff --git a/dist/es/animation/generators/spring/defaults.mjs b/dist/es/animation/generators/spring/defaults.mjs
deleted file mode 100644
index 3e9e4e47853d7a4b622da812c1245291f1ee93c0..0000000000000000000000000000000000000000
diff --git a/dist/es/animation/generators/spring/find.mjs b/dist/es/animation/generators/spring/find.mjs
index 750e8ba3ca2f763c89b535a3d9f72636c9f68349..0b6a87496cd2adc6759e8ecf1554d14a6711ff4d 100644
--- a/dist/es/animation/generators/spring/find.mjs
+++ b/dist/es/animation/generators/spring/find.mjs
@@ -1,19 +1,22 @@
-import { warning } from 'motion-utils';
+import { warning } from '../../../utils/errors.mjs';
 import { clamp } from '../../../utils/clamp.mjs';
 import { secondsToMilliseconds, millisecondsToSeconds } from '../../../utils/time-conversion.mjs';
-import { springDefaults } from './defaults.mjs';
 
 const safeMin = 0.001;
-function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {
+const minDuration = 0.01;
+const maxDuration = 10.0;
+const minDamping = 0.05;
+const maxDamping = 1;
+function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {
     let envelope;
     let derivative;
-    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
+    warning(duration <= secondsToMilliseconds(maxDuration), "Spring duration must be 10 seconds or less");
     let dampingRatio = 1 - bounce;
     /**
      * Restrict dampingRatio and duration to within acceptable ranges.
      */
-    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
-    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
+    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
+    duration = clamp(minDuration, maxDuration, millisecondsToSeconds(duration));
     if (dampingRatio < 1) {
         /**
          * Underdamped spring
@@ -57,8 +60,8 @@ function findSpring({ duration = springDefaults.duration, bounce = springDefault
     duration = secondsToMilliseconds(duration);
     if (isNaN(undampedFreq)) {
         return {
-            stiffness: springDefaults.stiffness,
-            damping: springDefaults.damping,
+            stiffness: 100,
+            damping: 10,
             duration,
         };
     }
@@ -83,4 +86,4 @@ function calcAngularFreq(undampedFreq, dampingRatio) {
     return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
 }
 
-export { calcAngularFreq, findSpring };
+export { calcAngularFreq, findSpring, maxDamping, maxDuration, minDamping, minDuration };
diff --git a/dist/es/animation/generators/spring/index.mjs b/dist/es/animation/generators/spring/index.mjs
index 1415b4ed61dfa89cedfbdfa366cc96ace5fec348..5dde31c3d9729f19872416cf9b1d3ab09130f25f 100644
--- a/dist/es/animation/generators/spring/index.mjs
+++ b/dist/es/animation/generators/spring/index.mjs
@@ -1,10 +1,6 @@
-import { generateLinearEasing } from '../../animators/waapi/utils/linear.mjs';
 import { millisecondsToSeconds, secondsToMilliseconds } from '../../../utils/time-conversion.mjs';
 import { calcGeneratorVelocity } from '../utils/velocity.mjs';
 import { findSpring, calcAngularFreq } from './find.mjs';
-import { calcGeneratorDuration, maxGeneratorDuration } from '../utils/calc-duration.mjs';
-import { clamp } from '../../../utils/clamp.mjs';
-import { springDefaults } from './defaults.mjs';
 
 const durationKeys = ["duration", "bounce"];
 const physicsKeys = ["stiffness", "damping", "mass"];
@@ -13,51 +9,29 @@ function isSpringType(options, keys) {
 }
 function getSpringOptions(options) {
     let springOptions = {
-        velocity: springDefaults.velocity,
-        stiffness: springDefaults.stiffness,
-        damping: springDefaults.damping,
-        mass: springDefaults.mass,
+        velocity: 0.0,
+        stiffness: 100,
+        damping: 10,
+        mass: 1.0,
         isResolvedFromDuration: false,
         ...options,
     };
     // stiffness/damping/mass overrides duration/bounce
     if (!isSpringType(options, physicsKeys) &&
         isSpringType(options, durationKeys)) {
-        if (options.visualDuration) {
-            const visualDuration = options.visualDuration;
-            const root = (2 * Math.PI) / (visualDuration * 1.2);
-            const stiffness = root * root;
-            const damping = 2 * clamp(0.05, 1, 1 - options.bounce) * Math.sqrt(stiffness);
-            springOptions = {
-                ...springOptions,
-                mass: springDefaults.mass,
-                stiffness,
-                damping,
-            };
-        }
-        else {
-            const derived = findSpring(options);
-            springOptions = {
-                ...springOptions,
-                ...derived,
-                mass: springDefaults.mass,
-            };
-            springOptions.isResolvedFromDuration = true;
-        }
+        const derived = findSpring(options);
+        springOptions = {
+            ...springOptions,
+            ...derived,
+            mass: 1.0,
+        };
+        springOptions.isResolvedFromDuration = true;
     }
     return springOptions;
 }
-function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
-    const options = typeof optionsOrVisualDuration !== "object"
-        ? {
-            visualDuration: optionsOrVisualDuration,
-            keyframes: [0, 1],
-            bounce,
-        }
-        : optionsOrVisualDuration;
-    let { restSpeed, restDelta } = options;
-    const origin = options.keyframes[0];
-    const target = options.keyframes[options.keyframes.length - 1];
+function spring({ keyframes, restDelta, restSpeed, ...options }) {
+    const origin = keyframes[0];
+    const target = keyframes[keyframes.length - 1];
     /**
      * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
      * to reduce GC during animation.
@@ -79,12 +53,8 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
      * ratio between feeling good and finishing as soon as changes are imperceptible.
      */
     const isGranularScale = Math.abs(initialDelta) < 5;
-    restSpeed || (restSpeed = isGranularScale
-        ? springDefaults.restSpeed.granular
-        : springDefaults.restSpeed.default);
-    restDelta || (restDelta = isGranularScale
-        ? springDefaults.restDelta.granular
-        : springDefaults.restDelta.default);
+    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
+    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);
     let resolveSpring;
     if (dampingRatio < 1) {
         const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
@@ -125,7 +95,7 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
                     dampedAngularFreq);
         };
     }
-    const generator = {
+    return {
         calculatedDuration: isResolvedFromDuration ? duration || null : null,
         next: (t) => {
             const current = resolveSpring(t);
@@ -153,13 +123,7 @@ function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce
             state.value = state.done ? target : current;
             return state;
         },
-        toString: () => {
-            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
-            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);
-            return calculatedDuration + "ms " + easing;
-        },
     };
-    return generator;
 }
 
 export { spring };
diff --git a/dist/es/animation/hooks/animation-controls.mjs b/dist/es/animation/hooks/animation-controls.mjs
index 7edc5e211301dcdfb83a4cd7cd784cf4b659fdf1..9ccf5debb9bf0f8be51a5031d008d34a2b6fd519 100644
--- a/dist/es/animation/hooks/animation-controls.mjs
+++ b/dist/es/animation/hooks/animation-controls.mjs
@@ -1,4 +1,4 @@
-import { invariant } from 'motion-utils';
+import { invariant } from '../../utils/errors.mjs';
 import { setTarget } from '../../render/utils/setters.mjs';
 import { animateVisualElement } from '../interfaces/visual-element.mjs';
 
diff --git a/dist/es/animation/optimized-appear/start.mjs b/dist/es/animation/optimized-appear/start.mjs
index 611e46357f1d16c4385de5dbaf63ffbf03c86769..e5e4d4231d8ad50ed6ab4bf0b26c7ddad6945f8f 100644
--- a/dist/es/animation/optimized-appear/start.mjs
+++ b/dist/es/animation/optimized-appear/start.mjs
@@ -3,7 +3,7 @@ import { startWaapiAnimation } from '../animators/waapi/index.mjs';
 import { optimizedAppearDataId } from './data-id.mjs';
 import { handoffOptimizedAppearAnimation } from './handoff.mjs';
 import { appearAnimationStore, appearComplete } from './store.mjs';
-import { noop } from 'motion-utils';
+import { noop } from '../../utils/noop.mjs';
 import { getOptimisedAppearId } from './get-appear-id.mjs';
 
 /**
diff --git a/dist/es/animation/sequence/create.mjs b/dist/es/animation/sequence/create.mjs
index 5bdfbdd0b99806ada43a6cd5b565a31b4ac99540..3183085f08b3ec123700545f65a07047aa6bc5e2 100644
--- a/dist/es/animation/sequence/create.mjs
+++ b/dist/es/animation/sequence/create.mjs
@@ -9,13 +9,8 @@ import { isGenerator } from '../generators/utils/is-generator.mjs';
 import { calcNextTime } from './utils/calc-time.mjs';
 import { addKeyframes } from './utils/edit.mjs';
 import { compareByTime } from './utils/sort.mjs';
-import { invariant } from 'motion-utils';
-import { normalizeTimes } from './utils/normalize-times.mjs';
-import { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';
-import { getEasingForSegment } from '../../easing/utils/get-easing-for-segment.mjs';
 
 const defaultSegmentEasing = "easeInOut";
-const MAX_REPEAT = 20;
 function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {
     const defaultDuration = defaultTransition.duration || 0.3;
     const animationDefinitions = new Map();
@@ -58,7 +53,7 @@ function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...seq
         let maxDuration = 0;
         const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
             const valueKeyframesAsList = keyframesAsList(valueKeyframes);
-            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;
+            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = "keyframes", ...remainingTransition } = valueTransition;
             let { ease = defaultTransition.ease || "easeOut", duration } = valueTransition;
             /**
              * Resolve stagger() if defined.
@@ -96,6 +91,7 @@ function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...seq
             }
             duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);
             const startTime = currentTime + calculatedDelay;
+            const targetTime = startTime + duration;
             /**
              * If there's only one time offset of 0, fill in a second with length 1
              */
@@ -114,28 +110,6 @@ function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...seq
              */
             valueKeyframesAsList.length === 1 &&
                 valueKeyframesAsList.unshift(null);
-            /**
-             * Handle repeat options
-             */
-            if (repeat) {
-                invariant(repeat < MAX_REPEAT, "Repeat count too high, must be less than 20");
-                duration = calculateRepeatDuration(duration, repeat);
-                const originalKeyframes = [...valueKeyframesAsList];
-                const originalTimes = [...times];
-                ease = Array.isArray(ease) ? [...ease] : [ease];
-                const originalEase = [...ease];
-                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
-                    valueKeyframesAsList.push(...originalKeyframes);
-                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {
-                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));
-                        ease.push(keyframeIndex === 0
-                            ? "linear"
-                            : getEasingForSegment(originalEase, keyframeIndex - 1));
-                    }
-                }
-                normalizeTimes(times, repeat);
-            }
-            const targetTime = startTime + duration;
             /**
              * Add keyframes, mapping offsets to absolute time.
              */
diff --git a/dist/es/animation/sequence/utils/calc-repeat-duration.mjs b/dist/es/animation/sequence/utils/calc-repeat-duration.mjs
deleted file mode 100644
index 93372213c0410e3f123f5540cb7e0f43e44ad5e7..0000000000000000000000000000000000000000
diff --git a/dist/es/animation/sequence/utils/normalize-times.mjs b/dist/es/animation/sequence/utils/normalize-times.mjs
deleted file mode 100644
index ad36448ba63d92135597fd029d10d9b1490594de..0000000000000000000000000000000000000000
diff --git a/dist/es/components/AnimatePresence/PopChild.mjs b/dist/es/components/AnimatePresence/PopChild.mjs
index f81cf3410b86473bf037d21d4296bd985daca808..b5bd393c506013b60906902795e3102e18f905bd 100644
--- a/dist/es/components/AnimatePresence/PopChild.mjs
+++ b/dist/es/components/AnimatePresence/PopChild.mjs
@@ -28,7 +28,7 @@ class PopChildMeasure extends React.Component {
         return this.props.children;
     }
 }
-function PopChild({ children, isPresent }) {
+function PopChild({ children, isPresent, parentDom }) {
     const id = useId();
     const ref = useRef(null);
     const size = useRef({
@@ -55,7 +55,8 @@ function PopChild({ children, isPresent }) {
         const style = document.createElement("style");
         if (nonce)
             style.nonce = nonce;
-        document.head.appendChild(style);
+        const parent = parentDom !== null && parentDom !== void 0 ? parentDom : document.head;
+        parent.appendChild(style);
         if (style.sheet) {
             style.sheet.insertRule(`
           [data-motion-pop-id="${id}"] {
@@ -68,7 +69,7 @@ function PopChild({ children, isPresent }) {
         `);
         }
         return () => {
-            document.head.removeChild(style);
+            parent.removeChild(style);
         };
     }, [isPresent]);
     return (jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React.cloneElement(children, { ref }) }));
diff --git a/dist/es/components/AnimatePresence/PresenceChild.mjs b/dist/es/components/AnimatePresence/PresenceChild.mjs
index 5ce38b0e9f55ebcb289705ad77b337ea5b5314e6..129e07d37fbbd5028115eb42d7038ab80ece3aac 100644
--- a/dist/es/components/AnimatePresence/PresenceChild.mjs
+++ b/dist/es/components/AnimatePresence/PresenceChild.mjs
@@ -6,7 +6,7 @@ import { PresenceContext } from '../../context/PresenceContext.mjs';
 import { useConstant } from '../../utils/use-constant.mjs';
 import { PopChild } from './PopChild.mjs';
 
-const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, }) => {
+const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, parentDom }) => {
     const presenceChildren = useConstant(newChildrenMap);
     const id = useId();
     const memoizedOnExitComplete = useCallback((childId) => {
@@ -50,7 +50,7 @@ const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, p
             onExitComplete();
     }, [isPresent]);
     if (mode === "popLayout") {
-        children = jsx(PopChild, { isPresent: isPresent, children: children });
+        children = jsx(PopChild, { isPresent: isPresent, parentDom: parentDom, children: children });
     }
     return (jsx(PresenceContext.Provider, { value: context, children: children }));
 };
diff --git a/dist/es/components/AnimatePresence/index.mjs b/dist/es/components/AnimatePresence/index.mjs
index db1302c95ca0f701a20fd8fc465a776db0c78b6b..5902488a201114ba7309fe13b7cd6a7cbad2774b 100644
--- a/dist/es/components/AnimatePresence/index.mjs
+++ b/dist/es/components/AnimatePresence/index.mjs
@@ -3,7 +3,7 @@ import { jsx, Fragment } from 'react/jsx-runtime';
 import { useMemo, useRef, useState, useContext } from 'react';
 import { PresenceChild } from './PresenceChild.mjs';
 import { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';
-import { invariant } from 'motion-utils';
+import { invariant } from '../../utils/errors.mjs';
 import { useConstant } from '../../utils/use-constant.mjs';
 import { onlyElements, getChildKey } from './utils.mjs';
 import { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';
@@ -41,7 +41,7 @@ import { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs
  *
  * @public
  */
-const AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", }) => {
+const AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", parentDom, }) => {
     invariant(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
     /**
      * Filter any children that aren't ReactElements. We can only track components
@@ -156,7 +156,7 @@ const AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, on
             };
             return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial
                     ? undefined
-                    : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, children: child }, key));
+                    : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, parentDom: parentDom, onExitComplete: isPresent ? undefined : onExit, children: child }, key));
         }) }));
 };
 
diff --git a/dist/es/components/AnimateSharedLayout.mjs b/dist/es/components/AnimateSharedLayout.mjs
index d8a1e31a36e58345520fd37cb1fd834dbccd2b47..0a783e9e728535b8dde7434574aa07f5dd31fb9d 100644
--- a/dist/es/components/AnimateSharedLayout.mjs
+++ b/dist/es/components/AnimateSharedLayout.mjs
@@ -1,5 +1,5 @@
 import { jsx } from 'react/jsx-runtime';
-import { invariant } from 'motion-utils';
+import { invariant } from '../utils/errors.mjs';
 import * as React from 'react';
 import { useConstant } from '../utils/use-constant.mjs';
 import { LayoutGroup } from './LayoutGroup/index.mjs';
diff --git a/dist/es/components/Reorder/Group.mjs b/dist/es/components/Reorder/Group.mjs
index baf025a2c53e2cc9e3de9f70e089d6412cffb850..d8ee1cc33453f6f4ae3cb807dc673e613988d1f6 100644
--- a/dist/es/components/Reorder/Group.mjs
+++ b/dist/es/components/Reorder/Group.mjs
@@ -1,6 +1,6 @@
 "use client";
 import { jsx } from 'react/jsx-runtime';
-import { invariant } from 'motion-utils';
+import { invariant } from '../../utils/errors.mjs';
 import { forwardRef, useRef, useEffect } from 'react';
 import { ReorderContext } from '../../context/ReorderContext.mjs';
 import { motion } from '../../render/components/motion/proxy.mjs';
diff --git a/dist/es/components/Reorder/Item.mjs b/dist/es/components/Reorder/Item.mjs
index 2985e5af7e81dd5bf280e7eb225ee19e7a0ca7c4..e5499ddb92e6eccc97fc00fae5e83000aa13f41c 100644
--- a/dist/es/components/Reorder/Item.mjs
+++ b/dist/es/components/Reorder/Item.mjs
@@ -1,6 +1,6 @@
 "use client";
 import { jsx } from 'react/jsx-runtime';
-import { invariant } from 'motion-utils';
+import { invariant } from '../../utils/errors.mjs';
 import { forwardRef, useContext } from 'react';
 import { ReorderContext } from '../../context/ReorderContext.mjs';
 import { motion } from '../../render/components/motion/proxy.mjs';
diff --git a/dist/es/dom.mjs b/dist/es/dom.mjs
index 6a2a419999d6069ef418b880742b8d9913c1e3fb..b768debff1b7c0c3227eb0a06e523d5107cb1717 100644
--- a/dist/es/dom.mjs
+++ b/dist/es/dom.mjs
@@ -1,5 +1,3 @@
-export { invariant, noop } from 'motion-utils';
-export { isDragActive } from 'motion-dom';
 export { MotionValue, motionValue } from './value/index.mjs';
 export { animate, createScopedAnimate } from './animation/animate/index.mjs';
 export { animateMini } from './animation/animators/waapi/animate-style.mjs';
@@ -22,11 +20,11 @@ export { transform } from './utils/transform.mjs';
 export { clamp } from './utils/clamp.mjs';
 export { delayInSeconds as delay } from './utils/delay.mjs';
 export { distance, distance2D } from './utils/distance.mjs';
+export { invariant, warning } from './utils/errors.mjs';
 export { interpolate } from './utils/interpolate.mjs';
 export { mix } from './utils/mix/index.mjs';
 export { pipe } from './utils/pipe.mjs';
 export { progress } from './utils/progress.mjs';
 export { wrap } from './utils/wrap.mjs';
-export { time } from './frameloop/sync-time.mjs';
 export { cancelSync, sync } from './frameloop/index-legacy.mjs';
 export { cancelFrame, frame, frameData, frameSteps } from './frameloop/frame.mjs';
diff --git a/dist/es/easing/cubic-bezier.mjs b/dist/es/easing/cubic-bezier.mjs
index 9185303321d2233cafbf22b908247a958328391b..8c9d6babf9bc07939188d0357ee7a3c91ab909f2 100644
--- a/dist/es/easing/cubic-bezier.mjs
+++ b/dist/es/easing/cubic-bezier.mjs
@@ -1,4 +1,4 @@
-import { noop } from 'motion-utils';
+import { noop } from '../utils/noop.mjs';
 
 /*
   Bezier function generator
diff --git a/dist/es/easing/utils/map.mjs b/dist/es/easing/utils/map.mjs
index 83da4c0748956515d6d256022f47a1eac899c01a..a7d9f426d5f31dc686e638afc2be14f5a379cea4 100644
--- a/dist/es/easing/utils/map.mjs
+++ b/dist/es/easing/utils/map.mjs
@@ -1,5 +1,6 @@
-import { invariant, noop } from 'motion-utils';
+import { invariant } from '../../utils/errors.mjs';
 import { cubicBezier } from '../cubic-bezier.mjs';
+import { noop } from '../../utils/noop.mjs';
 import { easeIn, easeInOut, easeOut } from '../ease.mjs';
 import { circIn, circInOut, circOut } from '../circ.mjs';
 import { backIn, backInOut, backOut } from '../back.mjs';
diff --git a/dist/es/events/event-info.mjs b/dist/es/events/event-info.mjs
index 91e60b533ebeb8d3389459652089ed4faff5ed0f..8e02ec7462ba490e3d648e1398439b0ced90e2cb 100644
--- a/dist/es/events/event-info.mjs
+++ b/dist/es/events/event-info.mjs
@@ -1,10 +1,10 @@
-import { isPrimaryPointer } from 'motion-dom';
+import { isPrimaryPointer } from './utils/is-primary-pointer.mjs';
 
-function extractEventInfo(event) {
+function extractEventInfo(event, pointType = "page") {
     return {
         point: {
-            x: event.pageX,
-            y: event.pageY,
+            x: event[`${pointType}X`],
+            y: event[`${pointType}Y`],
         },
     };
 }
diff --git a/dist/es/events/utils/is-primary-pointer.mjs b/dist/es/events/utils/is-primary-pointer.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..02665fbc2d922a00f8ca0065854c66f68892ac6f
--- /dev/null
+++ b/dist/es/events/utils/is-primary-pointer.mjs
@@ -0,0 +1,18 @@
+const isPrimaryPointer = (event) => {
+    if (event.pointerType === "mouse") {
+        return typeof event.button !== "number" || event.button <= 0;
+    }
+    else {
+        /**
+         * isPrimary is true for all mice buttons, whereas every touch point
+         * is regarded as its own input. So subsequent concurrent touch points
+         * will be false.
+         *
+         * Specifically match against false here as incomplete versions of
+         * PointerEvents in very old browser might have it set as undefined.
+         */
+        return event.isPrimary !== false;
+    }
+};
+
+export { isPrimaryPointer };
diff --git a/dist/es/frameloop/frame.mjs b/dist/es/frameloop/frame.mjs
index 01588836db03ecb21b257f7c5177d2d5e494f660..591edbbc2fe6709246e5a2e1826bfae08775083f 100644
--- a/dist/es/frameloop/frame.mjs
+++ b/dist/es/frameloop/frame.mjs
@@ -1,4 +1,4 @@
-import { noop } from 'motion-utils';
+import { noop } from '../utils/noop.mjs';
 import { createRenderBatcher } from './batcher.mjs';
 
 const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);
diff --git a/dist/es/frameloop/render-step.mjs b/dist/es/frameloop/render-step.mjs
index 6f866ae31f35197d1fbe9d4690554f8bfc39f3c2..fa9e25058de7b55714a0936466bd01d270b07831 100644
--- a/dist/es/frameloop/render-step.mjs
+++ b/dist/es/frameloop/render-step.mjs
@@ -63,11 +63,10 @@ function createRenderStep(runNextFrame) {
             }
             isProcessing = true;
             [thisFrame, nextFrame] = [nextFrame, thisFrame];
+            // Clear the next frame queue
+            nextFrame.clear();
             // Execute this frame
             thisFrame.forEach(triggerCallback);
-            // Clear the frame so no callbacks remain. This is to avoid
-            // memory leaks should this render step not run for a while.
-            thisFrame.clear();
             isProcessing = false;
             if (flushNextFrame) {
                 flushNextFrame = false;
diff --git a/dist/es/gestures/drag/VisualElementDragControls.mjs b/dist/es/gestures/drag/VisualElementDragControls.mjs
index b42a42dd28d92d97689057f1f9111837119ff619..8eec60c22b89d76070761a47936409508fc7f3e9 100644
--- a/dist/es/gestures/drag/VisualElementDragControls.mjs
+++ b/dist/es/gestures/drag/VisualElementDragControls.mjs
@@ -1,6 +1,6 @@
-import { invariant } from 'motion-utils';
-import { setDragLock } from 'motion-dom';
+import { invariant } from '../../utils/errors.mjs';
 import { PanSession } from '../pan/PanSession.mjs';
+import { getGlobalLock } from './utils/lock.mjs';
 import { isRefObject } from '../../utils/is-ref-object.mjs';
 import { addPointerEvent } from '../../events/add-pointer-event.mjs';
 import { applyConstraints, calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, calcOrigin, defaultElastic } from './utils/constraints.mjs';
@@ -25,7 +25,10 @@ const elementDragControls = new WeakMap();
 // let latestPointerEvent: PointerEvent
 class VisualElementDragControls {
     constructor(visualElement) {
-        this.openDragLock = null;
+        // This is a reference to the global drag gesture lock, ensuring only one component
+        // can "capture" the drag of one or both axes.
+        // TODO: Look into moving this into pansession?
+        this.openGlobalLock = null;
         this.isDragging = false;
         this.currentDirection = null;
         this.originPoint = { x: 0, y: 0 };
@@ -53,18 +56,18 @@ class VisualElementDragControls {
             // the component.
             dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();
             if (snapToCursor) {
-                this.snapToCursor(extractEventInfo(event).point);
+                this.snapToCursor(extractEventInfo(event, "page").point);
             }
         };
         const onStart = (event, info) => {
             // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
             const { drag, dragPropagation, onDragStart } = this.getProps();
             if (drag && !dragPropagation) {
-                if (this.openDragLock)
-                    this.openDragLock();
-                this.openDragLock = setDragLock(drag);
+                if (this.openGlobalLock)
+                    this.openGlobalLock();
+                this.openGlobalLock = getGlobalLock(drag);
                 // If we don 't have the lock, don't start dragging
-                if (!this.openDragLock)
+                if (!this.openGlobalLock)
                     return;
             }
             this.isDragging = true;
@@ -106,7 +109,7 @@ class VisualElementDragControls {
             // latestPointerEvent = event
             const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();
             // If we didn't successfully receive the gesture lock, early return.
-            if (!dragPropagation && !this.openDragLock)
+            if (!dragPropagation && !this.openGlobalLock)
                 return;
             const { offset } = info;
             // Attempt to detect drag direction if directionLock is true
@@ -174,9 +177,9 @@ class VisualElementDragControls {
         this.panSession && this.panSession.end();
         this.panSession = undefined;
         const { dragPropagation } = this.getProps();
-        if (!dragPropagation && this.openDragLock) {
-            this.openDragLock();
-            this.openDragLock = null;
+        if (!dragPropagation && this.openGlobalLock) {
+            this.openGlobalLock();
+            this.openGlobalLock = null;
         }
         animationState && animationState.setActive("whileDrag", false);
     }
diff --git a/dist/es/gestures/drag/index.mjs b/dist/es/gestures/drag/index.mjs
index 5d968ae7ff3f15126d3110ddc908cf6bc1bd3ad5..9f19768fdcd349196909cf63e3dfdaff19e2ccfe 100644
--- a/dist/es/gestures/drag/index.mjs
+++ b/dist/es/gestures/drag/index.mjs
@@ -1,5 +1,5 @@
 import { Feature } from '../../motion/features/Feature.mjs';
-import { noop } from 'motion-utils';
+import { noop } from '../../utils/noop.mjs';
 import { VisualElementDragControls } from './VisualElementDragControls.mjs';
 
 class DragGesture extends Feature {
diff --git a/dist/es/gestures/drag/utils/lock.mjs b/dist/es/gestures/drag/utils/lock.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..99d28b6c280ea331f679a1c18f9c71a022cd061f
--- /dev/null
+++ b/dist/es/gestures/drag/utils/lock.mjs
@@ -0,0 +1,53 @@
+function createLock(name) {
+    let lock = null;
+    return () => {
+        const openLock = () => {
+            lock = null;
+        };
+        if (lock === null) {
+            lock = name;
+            return openLock;
+        }
+        return false;
+    };
+}
+const globalHorizontalLock = createLock("dragHorizontal");
+const globalVerticalLock = createLock("dragVertical");
+function getGlobalLock(drag) {
+    let lock = false;
+    if (drag === "y") {
+        lock = globalVerticalLock();
+    }
+    else if (drag === "x") {
+        lock = globalHorizontalLock();
+    }
+    else {
+        const openHorizontal = globalHorizontalLock();
+        const openVertical = globalVerticalLock();
+        if (openHorizontal && openVertical) {
+            lock = () => {
+                openHorizontal();
+                openVertical();
+            };
+        }
+        else {
+            // Release the locks because we don't use them
+            if (openHorizontal)
+                openHorizontal();
+            if (openVertical)
+                openVertical();
+        }
+    }
+    return lock;
+}
+function isDragActive() {
+    // Check the gesture lock - if we get it, it means no drag gesture is active
+    // and we can safely fire the tap gesture.
+    const openGestureLock = getGlobalLock(true);
+    if (!openGestureLock)
+        return true;
+    openGestureLock();
+    return false;
+}
+
+export { createLock, getGlobalLock, isDragActive };
diff --git a/dist/es/gestures/hover.mjs b/dist/es/gestures/hover.mjs
index 85688ca37278480a21f161fe640c7aef0f04d032..df5c0740d38b6248f39cb0cc59d3381a868f5291 100644
--- a/dist/es/gestures/hover.mjs
+++ b/dist/es/gestures/hover.mjs
@@ -1,28 +1,31 @@
+import { addPointerEvent } from '../events/add-pointer-event.mjs';
+import { pipe } from '../utils/pipe.mjs';
+import { isDragActive } from './drag/utils/lock.mjs';
 import { Feature } from '../motion/features/Feature.mjs';
-import { hover } from 'motion-dom';
-import { extractEventInfo } from '../events/event-info.mjs';
 import { frame } from '../frameloop/frame.mjs';
 
-function handleHoverEvent(node, event, lifecycle) {
-    const { props } = node;
-    if (node.animationState && props.whileHover) {
-        node.animationState.setActive("whileHover", lifecycle === "Start");
-    }
-    const eventName = ("onHover" + lifecycle);
-    const callback = props[eventName];
-    if (callback) {
-        frame.postRender(() => callback(event, extractEventInfo(event)));
-    }
+function addHoverEvent(node, isActive) {
+    const eventName = isActive ? "pointerenter" : "pointerleave";
+    const callbackName = isActive ? "onHoverStart" : "onHoverEnd";
+    const handleEvent = (event, info) => {
+        if (event.pointerType === "touch" || isDragActive())
+            return;
+        const props = node.getProps();
+        if (node.animationState && props.whileHover) {
+            node.animationState.setActive("whileHover", isActive);
+        }
+        const callback = props[callbackName];
+        if (callback) {
+            frame.postRender(() => callback(event, info));
+        }
+    };
+    return addPointerEvent(node.current, eventName, handleEvent, {
+        passive: !node.getProps()[callbackName],
+    });
 }
 class HoverGesture extends Feature {
     mount() {
-        const { current } = this.node;
-        if (!current)
-            return;
-        this.unmount = hover(current, (startEvent) => {
-            handleHoverEvent(this.node, startEvent, "Start");
-            return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
-        });
+        this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
     }
     unmount() { }
 }
diff --git a/dist/es/gestures/pan/PanSession.mjs b/dist/es/gestures/pan/PanSession.mjs
index 84d3c52477cd8bb22046b4d72ce450e250a2f700..0f0c9793b4aea8cd1acb87a09b5bafdfcc776708 100644
--- a/dist/es/gestures/pan/PanSession.mjs
+++ b/dist/es/gestures/pan/PanSession.mjs
@@ -3,14 +3,14 @@ import { secondsToMilliseconds, millisecondsToSeconds } from '../../utils/time-c
 import { addPointerEvent } from '../../events/add-pointer-event.mjs';
 import { pipe } from '../../utils/pipe.mjs';
 import { distance2D } from '../../utils/distance.mjs';
-import { isPrimaryPointer } from 'motion-dom';
+import { isPrimaryPointer } from '../../events/utils/is-primary-pointer.mjs';
 import { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';
 
 /**
  * @internal
  */
 class PanSession {
-    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {
+    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
         /**
          * @internal
          */
diff --git a/dist/es/gestures/pan/index.mjs b/dist/es/gestures/pan/index.mjs
index a56b306e325c85ac684c0733debc4cddbc9416ac..0f373fcbe7d8ecfda7e58aacaf45aa30fa2aad3a 100644
--- a/dist/es/gestures/pan/index.mjs
+++ b/dist/es/gestures/pan/index.mjs
@@ -1,7 +1,7 @@
 import { PanSession } from './PanSession.mjs';
 import { addPointerEvent } from '../../events/add-pointer-event.mjs';
 import { Feature } from '../../motion/features/Feature.mjs';
-import { noop } from 'motion-utils';
+import { noop } from '../../utils/noop.mjs';
 import { getContextWindow } from '../../utils/get-context-window.mjs';
 import { frame } from '../../frameloop/frame.mjs';
 
diff --git a/dist/es/gestures/press.mjs b/dist/es/gestures/press.mjs
index d0c927c5a0cad7dcbe8711bd5761481978191848..a7474521940956a5594f022a118f81549e6dc45a 100644
--- a/dist/es/gestures/press.mjs
+++ b/dist/es/gestures/press.mjs
@@ -1,30 +1,130 @@
-import { Feature } from '../motion/features/Feature.mjs';
-import { press } from 'motion-dom';
 import { extractEventInfo } from '../events/event-info.mjs';
+import { addDomEvent } from '../events/add-dom-event.mjs';
+import { addPointerEvent } from '../events/add-pointer-event.mjs';
+import { Feature } from '../motion/features/Feature.mjs';
+import { pipe } from '../utils/pipe.mjs';
+import { isDragActive } from './drag/utils/lock.mjs';
+import { isNodeOrChild } from './utils/is-node-or-child.mjs';
+import { noop } from '../utils/noop.mjs';
 import { frame } from '../frameloop/frame.mjs';
 
-function handlePressEvent(node, event, lifecycle) {
-    const { props } = node;
-    if (node.animationState && props.whileTap) {
-        node.animationState.setActive("whileTap", lifecycle === "Start");
-    }
-    const eventName = ("onTap" + (lifecycle === "End" ? "" : lifecycle));
-    const callback = props[eventName];
-    if (callback) {
-        frame.postRender(() => callback(event, extractEventInfo(event)));
-    }
+function fireSyntheticPointerEvent(name, handler) {
+    if (!handler)
+        return;
+    const syntheticPointerEvent = new PointerEvent("pointer" + name);
+    handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
 }
 class PressGesture extends Feature {
-    mount() {
-        const { current } = this.node;
-        if (!current)
+    constructor() {
+        super(...arguments);
+        this.removeStartListeners = noop;
+        this.removeEndListeners = noop;
+        this.removeAccessibleListeners = noop;
+        this.startPointerPress = (startEvent, startInfo) => {
+            if (this.isPressing)
+                return;
+            this.removeEndListeners();
+            const props = this.node.getProps();
+            const endPointerPress = (endEvent, endInfo) => {
+                if (!this.checkPressEnd())
+                    return;
+                const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
+                /**
+                 * We only count this as a tap gesture if the event.target is the same
+                 * as, or a child of, this component's element
+                 */
+                const handler = !globalTapTarget &&
+                    !isNodeOrChild(this.node.current, endEvent.target)
+                    ? onTapCancel
+                    : onTap;
+                if (handler) {
+                    frame.update(() => handler(endEvent, endInfo));
+                }
+            };
+            const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, {
+                passive: !(props.onTap || props["onPointerUp"]),
+            });
+            const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), {
+                passive: !(props.onTapCancel ||
+                    props["onPointerCancel"]),
+            });
+            this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
+            this.startPress(startEvent, startInfo);
+        };
+        this.startAccessiblePress = () => {
+            const handleKeydown = (keydownEvent) => {
+                if (keydownEvent.key !== "Enter" || this.isPressing)
+                    return;
+                const handleKeyup = (keyupEvent) => {
+                    if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
+                        return;
+                    fireSyntheticPointerEvent("up", (event, info) => {
+                        const { onTap } = this.node.getProps();
+                        if (onTap) {
+                            frame.postRender(() => onTap(event, info));
+                        }
+                    });
+                };
+                this.removeEndListeners();
+                this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
+                fireSyntheticPointerEvent("down", (event, info) => {
+                    this.startPress(event, info);
+                });
+            };
+            const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
+            const handleBlur = () => {
+                if (!this.isPressing)
+                    return;
+                fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
+            };
+            const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
+            this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
+        };
+    }
+    startPress(event, info) {
+        this.isPressing = true;
+        const { onTapStart, whileTap } = this.node.getProps();
+        /**
+         * Ensure we trigger animations before firing event callback
+         */
+        if (whileTap && this.node.animationState) {
+            this.node.animationState.setActive("whileTap", true);
+        }
+        if (onTapStart) {
+            frame.postRender(() => onTapStart(event, info));
+        }
+    }
+    checkPressEnd() {
+        this.removeEndListeners();
+        this.isPressing = false;
+        const props = this.node.getProps();
+        if (props.whileTap && this.node.animationState) {
+            this.node.animationState.setActive("whileTap", false);
+        }
+        return !isDragActive();
+    }
+    cancelPress(event, info) {
+        if (!this.checkPressEnd())
             return;
-        this.unmount = press(current, (startEvent) => {
-            handlePressEvent(this.node, startEvent, "Start");
-            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
-        }, { useGlobalTarget: this.node.props.globalTapTarget });
+        const { onTapCancel } = this.node.getProps();
+        if (onTapCancel) {
+            frame.postRender(() => onTapCancel(event, info));
+        }
+    }
+    mount() {
+        const props = this.node.getProps();
+        const removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
+            passive: !(props.onTapStart ||
+                props["onPointerStart"]),
+        });
+        const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
+        this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
+    }
+    unmount() {
+        this.removeStartListeners();
+        this.removeEndListeners();
+        this.removeAccessibleListeners();
     }
-    unmount() { }
 }
 
 export { PressGesture };
diff --git a/dist/es/gestures/utils/is-node-or-child.mjs b/dist/es/gestures/utils/is-node-or-child.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..fac227f61b15ebea916e374817330fb7e38b71a3
--- /dev/null
+++ b/dist/es/gestures/utils/is-node-or-child.mjs
@@ -0,0 +1,20 @@
+/**
+ * Recursively traverse up the tree to check whether the provided child node
+ * is the parent or a descendant of it.
+ *
+ * @param parent - Element to find
+ * @param child - Element to test against parent
+ */
+const isNodeOrChild = (parent, child) => {
+    if (!child) {
+        return false;
+    }
+    else if (parent === child) {
+        return true;
+    }
+    else {
+        return isNodeOrChild(parent, child.parentElement);
+    }
+};
+
+export { isNodeOrChild };
diff --git a/dist/es/index.mjs b/dist/es/index.mjs
index efc0e60c0a8154f9acb7261645111be334a145bc..d15e69a89adf5617ebb536646a7937ce035983b0 100644
--- a/dist/es/index.mjs
+++ b/dist/es/index.mjs
@@ -67,8 +67,6 @@ export { AnimateSharedLayout } from './components/AnimateSharedLayout.mjs';
 export { delay } from './utils/delay.mjs';
 import * as namespace from './components/Reorder/namespace.mjs';
 export { namespace as Reorder };
-export { invariant, noop } from 'motion-utils';
-export { isDragActive } from 'motion-dom';
 export { MotionValue, motionValue } from './value/index.mjs';
 export { animate, createScopedAnimate } from './animation/animate/index.mjs';
 export { animateMini } from './animation/animators/waapi/animate-style.mjs';
@@ -84,7 +82,6 @@ export { mix } from './utils/mix/index.mjs';
 export { pipe } from './utils/pipe.mjs';
 export { progress } from './utils/progress.mjs';
 export { wrap } from './utils/wrap.mjs';
-export { time } from './frameloop/sync-time.mjs';
 export { cancelSync, sync } from './frameloop/index-legacy.mjs';
 export { anticipate } from './easing/anticipate.mjs';
 export { backIn, backInOut, backOut } from './easing/back.mjs';
@@ -95,6 +92,7 @@ export { steps } from './easing/steps.mjs';
 export { mirrorEasing } from './easing/modifiers/mirror.mjs';
 export { reverseEasing } from './easing/modifiers/reverse.mjs';
 export { distance, distance2D } from './utils/distance.mjs';
+export { invariant, warning } from './utils/errors.mjs';
 export { interpolate } from './utils/interpolate.mjs';
 export { cancelFrame, frame, frameData, frameSteps } from './frameloop/frame.mjs';
 export { animations } from './motion/features/animations.mjs';
@@ -102,6 +100,7 @@ export { createBox } from './projection/geometry/models.mjs';
 export { calcLength } from './projection/geometry/delta-calc.mjs';
 export { filterProps } from './render/dom/utils/filter-props.mjs';
 export { makeUseVisualState } from './motion/utils/use-visual-state.mjs';
+export { isDragActive } from './gestures/drag/utils/lock.mjs';
 export { addPointerEvent } from './events/add-pointer-event.mjs';
 export { addPointerInfo } from './events/event-info.mjs';
 export { isMotionValue } from './value/utils/is-motion-value.mjs';
diff --git a/dist/es/motion/index.mjs b/dist/es/motion/index.mjs
index 6683c17e97b8a3d2e9f09e0395b574c682542b4c..0728879b7ebabad44cab2105cf2f46381e2b8e45 100644
--- a/dist/es/motion/index.mjs
+++ b/dist/es/motion/index.mjs
@@ -11,7 +11,7 @@ import { isBrowser } from '../utils/is-browser.mjs';
 import { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';
 import { LazyContext } from '../context/LazyContext.mjs';
 import { motionComponentSymbol } from './utils/symbol.mjs';
-import { warning, invariant } from 'motion-utils';
+import { warning, invariant } from '../utils/errors.mjs';
 import { featureDefinitions } from './features/definitions.mjs';
 
 /**
diff --git a/dist/es/motion/utils/use-visual-element.mjs b/dist/es/motion/utils/use-visual-element.mjs
index 31693ce09c1df647042ff1a9b08b952ecbf5092c..cb62446c122e4497e05574a51102a45d188aac80 100644
--- a/dist/es/motion/utils/use-visual-element.mjs
+++ b/dist/es/motion/utils/use-visual-element.mjs
@@ -15,7 +15,7 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
     const lazyContext = useContext(LazyContext);
     const presenceContext = useContext(PresenceContext);
     const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;
-    const visualElementRef = useRef(null);
+    const visualElementRef = useRef();
     /**
      * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
      */
@@ -44,15 +44,8 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
         (visualElement.type === "html" || visualElement.type === "svg")) {
         createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
     }
-    const isMounted = useRef(false);
     useInsertionEffect(() => {
-        /**
-         * Check the component has already mounted before calling
-         * `update` unnecessarily. This ensures we skip the initial update.
-         */
-        if (visualElement && isMounted.current) {
-            visualElement.update(props, presenceContext);
-        }
+        visualElement && visualElement.update(props, presenceContext);
     });
     /**
      * Cache this value as we want to know whether HandoffAppearAnimations
@@ -65,7 +58,6 @@ function useVisualElement(Component, visualState, props, createVisualElement, Pr
     useIsomorphicLayoutEffect(() => {
         if (!visualElement)
             return;
-        isMounted.current = true;
         window.MotionIsMounted = true;
         visualElement.updateFeatures();
         microtask.render(visualElement.render);
diff --git a/dist/es/projection/animation/mix-values.mjs b/dist/es/projection/animation/mix-values.mjs
index 6be2be377d4a3e433926142270c44ce80d6d41ee..737373e6a827e621b319dac76b4f49aeb9464983 100644
--- a/dist/es/projection/animation/mix-values.mjs
+++ b/dist/es/projection/animation/mix-values.mjs
@@ -1,7 +1,7 @@
 import { circOut } from '../../easing/circ.mjs';
 import { progress } from '../../utils/progress.mjs';
 import { mixNumber } from '../../utils/mix/number.mjs';
-import { noop } from 'motion-utils';
+import { noop } from '../../utils/noop.mjs';
 import { percent, px } from '../../value/types/numbers/units.mjs';
 
 const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
diff --git a/dist/es/projection/node/create-projection-node.mjs b/dist/es/projection/node/create-projection-node.mjs
index a15a6eb4dfebc2ed40fb54aba36ff8f753c3a610..2825f57c4387734b19a25481ad47c9d2996ecef3 100644
--- a/dist/es/projection/node/create-projection-node.mjs
+++ b/dist/es/projection/node/create-projection-node.mjs
@@ -20,7 +20,7 @@ import { isSVGElement } from '../../render/dom/utils/is-svg-element.mjs';
 import { animateSingleValue } from '../../animation/animate/single-value.mjs';
 import { clamp } from '../../utils/clamp.mjs';
 import { cancelFrame, frameData, frameSteps, frame } from '../../frameloop/frame.mjs';
-import { noop } from 'motion-utils';
+import { noop } from '../../utils/noop.mjs';
 import { time } from '../../frameloop/sync-time.mjs';
 import { microtask } from '../../frameloop/microtask.mjs';
 import { getOptimisedAppearId } from '../../animation/optimized-appear/get-appear-id.mjs';
diff --git a/dist/es/render/dom/DOMVisualElement.mjs b/dist/es/render/dom/DOMVisualElement.mjs
index acca21813399ae09e9154de410a0c56b6acf445f..ea2b68223873a0b7c2addf0b5ab1d501920eba52 100644
--- a/dist/es/render/dom/DOMVisualElement.mjs
+++ b/dist/es/render/dom/DOMVisualElement.mjs
@@ -1,6 +1,5 @@
 import { VisualElement } from '../VisualElement.mjs';
 import { DOMKeyframesResolver } from './DOMKeyframesResolver.mjs';
-import { isMotionValue } from '../../value/utils/is-motion-value.mjs';
 
 class DOMVisualElement extends VisualElement {
     constructor() {
@@ -24,20 +23,6 @@ class DOMVisualElement extends VisualElement {
         delete vars[key];
         delete style[key];
     }
-    handleChildMotionValue() {
-        if (this.childSubscription) {
-            this.childSubscription();
-            delete this.childSubscription;
-        }
-        const { children } = this.props;
-        if (isMotionValue(children)) {
-            this.childSubscription = children.on("change", (latest) => {
-                if (this.current) {
-                    this.current.textContent = `${latest}`;
-                }
-            });
-        }
-    }
 }
 
 export { DOMVisualElement };
diff --git a/dist/es/render/dom/resize/handle-element.mjs b/dist/es/render/dom/resize/handle-element.mjs
index 5bf7bb069b291c78a1c244471fe5386e081d4581..1ac1ca3365374ef75a0b52a52741a5c2e6c384c4 100644
--- a/dist/es/render/dom/resize/handle-element.mjs
+++ b/dist/es/render/dom/resize/handle-element.mjs
@@ -1,4 +1,4 @@
-import { resolveElements } from 'motion-dom';
+import { resolveElements } from '../utils/resolve-element.mjs';
 
 const resizeHandlers = new WeakMap();
 let observer;
diff --git a/dist/es/render/dom/scroll/index.mjs b/dist/es/render/dom/scroll/index.mjs
index 2227f115642bcad688499a215d057348bc7bf613..2e2707cabfb506e896aeebf7745ef3469eea3b80 100644
--- a/dist/es/render/dom/scroll/index.mjs
+++ b/dist/es/render/dom/scroll/index.mjs
@@ -1,7 +1,6 @@
 import { scrollInfo } from './track.mjs';
 import { observeTimeline } from './observe.mjs';
 import { supportsScrollTimeline } from './supports.mjs';
-import { noop } from 'motion-utils';
 
 function scrollTimelineFallback({ source, container, axis = "y", }) {
     // Support legacy source argument. Deprecate later.
@@ -55,7 +54,6 @@ function scrollFunction(onScroll, options) {
     }
 }
 function scrollAnimation(animation, options) {
-    animation.flatten();
     if (needsElementTracking(options)) {
         animation.pause();
         return scrollInfo((info) => {
@@ -64,17 +62,12 @@ function scrollAnimation(animation, options) {
     }
     else {
         const timeline = getTimeline(options);
-        if (animation.attachTimeline) {
-            return animation.attachTimeline(timeline, (valueAnimation) => {
-                valueAnimation.pause();
-                return observeTimeline((progress) => {
-                    valueAnimation.time = valueAnimation.duration * progress;
-                }, timeline);
-            });
-        }
-        else {
-            return noop;
-        }
+        return animation.attachTimeline(timeline, (valueAnimation) => {
+            valueAnimation.pause();
+            return observeTimeline((progress) => {
+                valueAnimation.time = valueAnimation.duration * progress;
+            }, timeline);
+        });
     }
 }
 function scroll(onScroll, { axis = "y", ...options } = {}) {
diff --git a/dist/es/render/dom/utils/css-variables-conversion.mjs b/dist/es/render/dom/utils/css-variables-conversion.mjs
index 5ff2266e58f965d64b30f24dc8365de395c41cfc..c91527c21dd3086f77cc31f54c2e0c28fc8b98eb 100644
--- a/dist/es/render/dom/utils/css-variables-conversion.mjs
+++ b/dist/es/render/dom/utils/css-variables-conversion.mjs
@@ -1,4 +1,4 @@
-import { invariant } from 'motion-utils';
+import { invariant } from '../../../utils/errors.mjs';
 import { isNumericalString } from '../../../utils/is-numerical-string.mjs';
 import { isCSSVariableToken } from './is-css-variable.mjs';
 
diff --git a/dist/es/render/dom/utils/resolve-element.mjs b/dist/es/render/dom/utils/resolve-element.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..7a1761b43c535d9447d23792f79c67f008567ba3
--- /dev/null
+++ b/dist/es/render/dom/utils/resolve-element.mjs
@@ -0,0 +1,28 @@
+import { invariant } from '../../../utils/errors.mjs';
+
+function resolveElements(elements, scope, selectorCache) {
+    var _a;
+    if (typeof elements === "string") {
+        let root = document;
+        if (scope) {
+            invariant(Boolean(scope.current), "Scope provided, but no element detected.");
+            root = scope.current;
+        }
+        if (selectorCache) {
+            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));
+            elements = selectorCache[elements];
+        }
+        else {
+            elements = root.querySelectorAll(elements);
+        }
+    }
+    else if (elements instanceof Element) {
+        elements = [elements];
+    }
+    /**
+     * Return an empty array
+     */
+    return Array.from(elements || []);
+}
+
+export { resolveElements };
diff --git a/dist/es/render/dom/viewport/index.mjs b/dist/es/render/dom/viewport/index.mjs
index 5f8ae8bf48203da5e8b48c89912d0760651ed87c..73c01997841082d4d7cde37a3ec51ece2157d6fa 100644
--- a/dist/es/render/dom/viewport/index.mjs
+++ b/dist/es/render/dom/viewport/index.mjs
@@ -1,4 +1,4 @@
-import { resolveElements } from 'motion-dom';
+import { resolveElements } from '../utils/resolve-element.mjs';
 
 const thresholds = {
     some: 0,
diff --git a/dist/es/render/html/HTMLVisualElement.mjs b/dist/es/render/html/HTMLVisualElement.mjs
index 98486289791bc92395ef54af6dfc34e3a929af92..7a3d38d3104305cda55c8f5e65b10c1e8c6906fb 100644
--- a/dist/es/render/html/HTMLVisualElement.mjs
+++ b/dist/es/render/html/HTMLVisualElement.mjs
@@ -6,6 +6,7 @@ import { renderHTML } from './utils/render.mjs';
 import { getDefaultValueType } from '../dom/value-types/defaults.mjs';
 import { measureViewportBox } from '../../projection/utils/measure.mjs';
 import { DOMVisualElement } from '../dom/DOMVisualElement.mjs';
+import { isMotionValue } from '../../value/utils/is-motion-value.mjs';
 
 function getComputedStyle(element) {
     return window.getComputedStyle(element);
@@ -38,6 +39,19 @@ class HTMLVisualElement extends DOMVisualElement {
     scrapeMotionValuesFromProps(props, prevProps, visualElement) {
         return scrapeMotionValuesFromProps(props, prevProps, visualElement);
     }
+    handleChildMotionValue() {
+        if (this.childSubscription) {
+            this.childSubscription();
+            delete this.childSubscription;
+        }
+        const { children } = this.props;
+        if (isMotionValue(children)) {
+            this.childSubscription = children.on("change", (latest) => {
+                if (this.current)
+                    this.current.textContent = `${latest}`;
+            });
+        }
+    }
 }
 
 export { HTMLVisualElement, getComputedStyle };
diff --git a/dist/es/render/utils/motion-values.mjs b/dist/es/render/utils/motion-values.mjs
index 1df75eb0a6ace43f7c2ff266d6ba7832d6f10b38..a9d29e98f59b3aa6e7b2614b8113101936a2db75 100644
--- a/dist/es/render/utils/motion-values.mjs
+++ b/dist/es/render/utils/motion-values.mjs
@@ -17,7 +17,7 @@ function updateMotionValuesFromProps(element, next, prev) {
              * and warn against mismatches.
              */
             if (process.env.NODE_ENV === "development") {
-                warnOnce(nextValue.version === "11.15.0", `Attempting to mix Motion versions ${nextValue.version} with 11.15.0 may not work as expected.`);
+                warnOnce(nextValue.version === "11.11.10", `Attempting to mix Framer Motion versions ${nextValue.version} with 11.11.10 may not work as expected.`);
             }
         }
         else if (isMotionValue(prevValue)) {
diff --git a/dist/es/utils/errors.mjs b/dist/es/utils/errors.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..2c752f76c9497e487f78c051cf63dc05b2486513
--- /dev/null
+++ b/dist/es/utils/errors.mjs
@@ -0,0 +1,18 @@
+import { noop } from './noop.mjs';
+
+let warning = noop;
+let invariant = noop;
+if (process.env.NODE_ENV !== "production") {
+    warning = (check, message) => {
+        if (!check && typeof console !== "undefined") {
+            console.warn(message);
+        }
+    };
+    invariant = (check, message) => {
+        if (!check) {
+            throw new Error(message);
+        }
+    };
+}
+
+export { invariant, warning };
diff --git a/dist/es/utils/get-context-window.mjs b/dist/es/utils/get-context-window.mjs
index 5e38905003718657cac3320963bbd5c1409d92ad..5e8b1b5444eca00ea2a50f7d9f7f360c878dd82c 100644
--- a/dist/es/utils/get-context-window.mjs
+++ b/dist/es/utils/get-context-window.mjs
@@ -1,4 +1,4 @@
-// Fixes https://github.com/motiondivision/motion/issues/2270
+// Fixes https://github.com/framer/motion/issues/2270
 const getContextWindow = ({ current }) => {
     return current ? current.ownerDocument.defaultView : null;
 };
diff --git a/dist/es/utils/interpolate.mjs b/dist/es/utils/interpolate.mjs
index 8a8007320d6a759cbb1b3462e9dd449dbec27a3c..8409d17ad17e7652f4682029164d76380b4e21f2 100644
--- a/dist/es/utils/interpolate.mjs
+++ b/dist/es/utils/interpolate.mjs
@@ -1,7 +1,8 @@
+import { invariant } from './errors.mjs';
 import { clamp } from './clamp.mjs';
 import { pipe } from './pipe.mjs';
 import { progress } from './progress.mjs';
-import { invariant, noop } from 'motion-utils';
+import { noop } from './noop.mjs';
 import { mix } from './mix/index.mjs';
 
 function createMixers(output, ease, customMixer) {
diff --git a/dist/es/utils/mix/color.mjs b/dist/es/utils/mix/color.mjs
index 3aaf46651c3e4aa01e829e0510463ff26f89d4ec..1f67faf841ec8a5e8a86db608d71a06e610b30a7 100644
--- a/dist/es/utils/mix/color.mjs
+++ b/dist/es/utils/mix/color.mjs
@@ -1,5 +1,5 @@
 import { mixNumber } from './number.mjs';
-import { warning } from 'motion-utils';
+import { warning } from '../errors.mjs';
 import { hslaToRgba } from '../hsla-to-rgba.mjs';
 import { hex } from '../../value/types/color/hex.mjs';
 import { rgba } from '../../value/types/color/rgba.mjs';
@@ -23,7 +23,7 @@ function asRGBA(color) {
         return false;
     let model = type.parse(color);
     if (type === hsla) {
-        // TODO Remove this cast - needed since Motion's stricter typing
+        // TODO Remove this cast - needed since Framer Motion's stricter typing
         model = hslaToRgba(model);
     }
     return model;
diff --git a/dist/es/utils/mix/complex.mjs b/dist/es/utils/mix/complex.mjs
index 2d12e1f7518a96aaf2b334fd9b058ccbb5997d00..748ee1fe5dabad813ebef2492ac690962dce393a 100644
--- a/dist/es/utils/mix/complex.mjs
+++ b/dist/es/utils/mix/complex.mjs
@@ -1,7 +1,7 @@
 import { mixNumber as mixNumber$1 } from './number.mjs';
 import { mixColor } from './color.mjs';
 import { pipe } from '../pipe.mjs';
-import { warning } from 'motion-utils';
+import { warning } from '../errors.mjs';
 import { color } from '../../value/types/color/index.mjs';
 import { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';
 import { isCSSVariableToken } from '../../render/dom/utils/is-css-variable.mjs';
diff --git a/dist/es/utils/noop.mjs b/dist/es/utils/noop.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..8cf252bb2921b0607deef182eae1df5d66ea0533
--- /dev/null
+++ b/dist/es/utils/noop.mjs
@@ -0,0 +1,3 @@
+const noop = (any) => any;
+
+export { noop };
diff --git a/dist/es/utils/use-instant-transition.mjs b/dist/es/utils/use-instant-transition.mjs
index b08abf8343c583b4a2d643588f54d9ac6908935c..289874c2a6c1dcdfc3a6702ce3fd3740e382b576 100644
--- a/dist/es/utils/use-instant-transition.mjs
+++ b/dist/es/utils/use-instant-transition.mjs
@@ -7,7 +7,7 @@ import { frame } from '../frameloop/frame.mjs';
 function useInstantTransition() {
     const [forceUpdate, forcedRenderCount] = useForceUpdate();
     const startInstantLayoutTransition = useInstantLayoutTransition();
-    const unlockOnFrameRef = useRef(-1);
+    const unlockOnFrameRef = useRef();
     useEffect(() => {
         /**
          * Unblock after two animation frames, otherwise this will unblock too soon.
diff --git a/dist/es/value/index.mjs b/dist/es/value/index.mjs
index cb1335d5cfba24114b378b71f7008eb2656e304e..f7171ddd170f1c7a7997eda3553e9352658eaa39 100644
--- a/dist/es/value/index.mjs
+++ b/dist/es/value/index.mjs
@@ -34,7 +34,7 @@ class MotionValue {
          * This will be replaced by the build step with the latest version number.
          * When MotionValues are provided to motion components, warn if versions are mixed.
          */
-        this.version = "11.15.0";
+        this.version = "11.11.10";
         /**
          * Tracks whether this value can output a velocity. Currently this is only true
          * if the value is numerical, but we might be able to widen the scope here and support
diff --git a/dist/es/value/use-inverted-scale.mjs b/dist/es/value/use-inverted-scale.mjs
index 992298eb451d3358779ef2926b094d9cc2b80110..fa1cbd0c7c4cdef116fa25bded8b351d17f8fcc3 100644
--- a/dist/es/value/use-inverted-scale.mjs
+++ b/dist/es/value/use-inverted-scale.mjs
@@ -1,5 +1,5 @@
 import { useTransform } from './use-transform.mjs';
-import { invariant, warning } from 'motion-utils';
+import { invariant, warning } from '../utils/errors.mjs';
 import { useMotionValue } from './use-motion-value.mjs';
 import { MotionContext } from '../context/MotionContext/index.mjs';
 import { useContext } from 'react';
diff --git a/dist/es/value/use-scroll.mjs b/dist/es/value/use-scroll.mjs
index 6624afbbf6f05b6c47d6cbfb152bfc9ad41a9b77..f489316a59791b85156360f46592fa9b091dbcf9 100644
--- a/dist/es/value/use-scroll.mjs
+++ b/dist/es/value/use-scroll.mjs
@@ -1,7 +1,7 @@
 import { motionValue } from './index.mjs';
 import { useConstant } from '../utils/use-constant.mjs';
 import { useEffect } from 'react';
-import { warning } from 'motion-utils';
+import { warning } from '../utils/errors.mjs';
 import { scroll } from '../render/dom/scroll/index.mjs';
 import { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';
 
diff --git a/dist/framer-motion.dev.js b/dist/framer-motion.dev.js
index a5c3e31147d9415526aab029b7440351afad25fa..38a1e81780cb8daa0b021080a3bbd01f300c008b 100644
--- a/dist/framer-motion.dev.js
+++ b/dist/framer-motion.dev.js
@@ -252,21 +252,6 @@
 
     const noop = (any) => any;
 
-    let warning = noop;
-    exports.invariant = noop;
-    {
-        warning = (check, message) => {
-            if (!check && typeof console !== "undefined") {
-                console.warn(message);
-            }
-        };
-        exports.invariant = (check, message) => {
-            if (!check) {
-                throw new Error(message);
-            }
-        };
-    }
-
     function createRenderStep(runNextFrame) {
         /**
          * We create and reuse two queues, one to queue jobs for the current frame
@@ -332,11 +317,10 @@
                 }
                 isProcessing = true;
                 [thisFrame, nextFrame] = [nextFrame, thisFrame];
+                // Clear the next frame queue
+                nextFrame.clear();
                 // Execute this frame
                 thisFrame.forEach(triggerCallback);
-                // Clear the frame so no callbacks remain. This is to avoid
-                // memory leaks should this render step not run for a while.
-                thisFrame.clear();
                 isProcessing = false;
                 if (flushNextFrame) {
                     flushNextFrame = false;
@@ -502,6 +486,21 @@
         }
     }
 
+    exports.warning = noop;
+    exports.invariant = noop;
+    {
+        exports.warning = (check, message) => {
+            if (!check && typeof console !== "undefined") {
+                console.warn(message);
+            }
+        };
+        exports.invariant = (check, message) => {
+            if (!check) {
+                throw new Error(message);
+            }
+        };
+    }
+
     /**
      * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
      */
@@ -1430,7 +1429,7 @@
         const targetKeyframe = keyframes[keyframes.length - 1];
         const isOriginAnimatable = isAnimatable(originKeyframe, name);
         const isTargetAnimatable = isAnimatable(targetKeyframe, name);
-        warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
+        exports.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
         // Always skip if any of these are true
         if (!isOriginAnimatable || !isTargetAnimatable) {
             return false;
@@ -1538,10 +1537,6 @@
         then(resolve, reject) {
             return this.currentFinishedPromise.then(resolve, reject);
         }
-        flatten() {
-            this.options.type = "keyframes";
-            this.options.ease = "linear";
-        }
         updateFinishedPromise() {
             this.currentFinishedPromise = new Promise((resolve) => {
                 this.resolveFinishedPromise = resolve;
@@ -1549,34 +1544,6 @@
         }
     }
 
-    /*
-      Progress within given range
-
-      Given a lower limit and an upper limit, we return the progress
-      (expressed as a number 0-1) represented by the given value, and
-      limit that progress to within 0-1.
-
-      @param [number]: Lower limit
-      @param [number]: Upper limit
-      @param [number]: Value to find progress within given range
-      @return [number]: Progress of value within range as expressed 0-1
-    */
-    const progress = (from, to, value) => {
-        const toFromDifference = to - from;
-        return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
-    };
-
-    const generateLinearEasing = (easing, duration, // as milliseconds
-    resolution = 10 // as milliseconds
-    ) => {
-        let points = "";
-        const numPoints = Math.max(Math.round(duration / resolution), 2);
-        for (let i = 0; i < numPoints; i++) {
-            points += easing(progress(0, numPoints - 1, i)) + ", ";
-        }
-        return `linear(${points.substring(0, points.length - 2)})`;
-    };
-
     /*
       Convert velocity into velocity per second
 
@@ -1593,43 +1560,21 @@
         return velocityPerSecond(current - resolveValue(prevT), t - prevT);
     }
 
-    const springDefaults = {
-        // Default spring physics
-        stiffness: 100,
-        damping: 10,
-        mass: 1.0,
-        velocity: 0.0,
-        // Default duration/bounce-based options
-        duration: 800, // in ms
-        bounce: 0.3,
-        visualDuration: 0.3, // in seconds
-        // Rest thresholds
-        restSpeed: {
-            granular: 0.01,
-            default: 2,
-        },
-        restDelta: {
-            granular: 0.005,
-            default: 0.5,
-        },
-        // Limits
-        minDuration: 0.01, // in seconds
-        maxDuration: 10.0, // in seconds
-        minDamping: 0.05,
-        maxDamping: 1,
-    };
-
     const safeMin = 0.001;
-    function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {
+    const minDuration = 0.01;
+    const maxDuration$1 = 10.0;
+    const minDamping = 0.05;
+    const maxDamping = 1;
+    function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {
         let envelope;
         let derivative;
-        warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
+        exports.warning(duration <= secondsToMilliseconds(maxDuration$1), "Spring duration must be 10 seconds or less");
         let dampingRatio = 1 - bounce;
         /**
          * Restrict dampingRatio and duration to within acceptable ranges.
          */
-        dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
-        duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
+        dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
+        duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));
         if (dampingRatio < 1) {
             /**
              * Underdamped spring
@@ -1673,8 +1618,8 @@
         duration = secondsToMilliseconds(duration);
         if (isNaN(undampedFreq)) {
             return {
-                stiffness: springDefaults.stiffness,
-                damping: springDefaults.damping,
+                stiffness: 100,
+                damping: 10,
                 duration,
             };
         }
@@ -1699,22 +1644,6 @@
         return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
     }
 
-    /**
-     * Implement a practical max duration for keyframe generation
-     * to prevent infinite loops
-     */
-    const maxGeneratorDuration = 20000;
-    function calcGeneratorDuration(generator) {
-        let duration = 0;
-        const timeStep = 50;
-        let state = generator.next(duration);
-        while (!state.done && duration < maxGeneratorDuration) {
-            duration += timeStep;
-            state = generator.next(duration);
-        }
-        return duration >= maxGeneratorDuration ? Infinity : duration;
-    }
-
     const durationKeys = ["duration", "bounce"];
     const physicsKeys = ["stiffness", "damping", "mass"];
     function isSpringType(options, keys) {
@@ -1722,51 +1651,29 @@
     }
     function getSpringOptions(options) {
         let springOptions = {
-            velocity: springDefaults.velocity,
-            stiffness: springDefaults.stiffness,
-            damping: springDefaults.damping,
-            mass: springDefaults.mass,
+            velocity: 0.0,
+            stiffness: 100,
+            damping: 10,
+            mass: 1.0,
             isResolvedFromDuration: false,
             ...options,
         };
         // stiffness/damping/mass overrides duration/bounce
         if (!isSpringType(options, physicsKeys) &&
             isSpringType(options, durationKeys)) {
-            if (options.visualDuration) {
-                const visualDuration = options.visualDuration;
-                const root = (2 * Math.PI) / (visualDuration * 1.2);
-                const stiffness = root * root;
-                const damping = 2 * clamp(0.05, 1, 1 - options.bounce) * Math.sqrt(stiffness);
-                springOptions = {
-                    ...springOptions,
-                    mass: springDefaults.mass,
-                    stiffness,
-                    damping,
-                };
-            }
-            else {
-                const derived = findSpring(options);
-                springOptions = {
-                    ...springOptions,
-                    ...derived,
-                    mass: springDefaults.mass,
-                };
-                springOptions.isResolvedFromDuration = true;
-            }
+            const derived = findSpring(options);
+            springOptions = {
+                ...springOptions,
+                ...derived,
+                mass: 1.0,
+            };
+            springOptions.isResolvedFromDuration = true;
         }
         return springOptions;
     }
-    function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
-        const options = typeof optionsOrVisualDuration !== "object"
-            ? {
-                visualDuration: optionsOrVisualDuration,
-                keyframes: [0, 1],
-                bounce,
-            }
-            : optionsOrVisualDuration;
-        let { restSpeed, restDelta } = options;
-        const origin = options.keyframes[0];
-        const target = options.keyframes[options.keyframes.length - 1];
+    function spring({ keyframes, restDelta, restSpeed, ...options }) {
+        const origin = keyframes[0];
+        const target = keyframes[keyframes.length - 1];
         /**
          * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
          * to reduce GC during animation.
@@ -1788,12 +1695,8 @@
          * ratio between feeling good and finishing as soon as changes are imperceptible.
          */
         const isGranularScale = Math.abs(initialDelta) < 5;
-        restSpeed || (restSpeed = isGranularScale
-            ? springDefaults.restSpeed.granular
-            : springDefaults.restSpeed.default);
-        restDelta || (restDelta = isGranularScale
-            ? springDefaults.restDelta.granular
-            : springDefaults.restDelta.default);
+        restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
+        restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);
         let resolveSpring;
         if (dampingRatio < 1) {
             const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
@@ -1834,7 +1737,7 @@
                         dampedAngularFreq);
             };
         }
-        const generator = {
+        return {
             calculatedDuration: isResolvedFromDuration ? duration || null : null,
             next: (t) => {
                 const current = resolveSpring(t);
@@ -1862,13 +1765,7 @@
                 state.value = state.done ? target : current;
                 return state;
             },
-            toString: () => {
-                const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
-                const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);
-                return calculatedDuration + "ms " + easing;
-            },
         };
-        return generator;
     }
 
     function inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {
@@ -2002,6 +1899,23 @@
     const combineFunctions = (a, b) => (v) => b(a(v));
     const pipe = (...transformers) => transformers.reduce(combineFunctions);
 
+    /*
+      Progress within given range
+
+      Given a lower limit and an upper limit, we return the progress
+      (expressed as a number 0-1) represented by the given value, and
+      limit that progress to within 0-1.
+
+      @param [number]: Lower limit
+      @param [number]: Upper limit
+      @param [number]: Value to find progress within given range
+      @return [number]: Progress of value within range as expressed 0-1
+    */
+    const progress = (from, to, value) => {
+        const toFromDifference = to - from;
+        return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
+    };
+
     /*
       Value in range from progress
 
@@ -2084,12 +1998,12 @@
     const getColorType = (v) => colorTypes.find((type) => type.test(v));
     function asRGBA(color) {
         const type = getColorType(color);
-        warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);
+        exports.warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);
         if (!Boolean(type))
             return false;
         let model = type.parse(color);
         if (type === hsla) {
-            // TODO Remove this cast - needed since Motion's stricter typing
+            // TODO Remove this cast - needed since Framer Motion's stricter typing
             model = hslaToRgba(model);
         }
         return model;
@@ -2203,7 +2117,7 @@
             return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
         }
         else {
-            warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
+            exports.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
             return mixImmediate(origin, target);
         }
     };
@@ -2346,6 +2260,22 @@
         };
     }
 
+    /**
+     * Implement a practical max duration for keyframe generation
+     * to prevent infinite loops
+     */
+    const maxGeneratorDuration = 20000;
+    function calcGeneratorDuration(generator) {
+        let duration = 0;
+        const timeStep = 50;
+        let state = generator.next(duration);
+        while (!state.done && duration < maxGeneratorDuration) {
+            duration += timeStep;
+            state = generator.next(duration);
+        }
+        return duration >= maxGeneratorDuration ? Infinity : duration;
+    }
+
     const frameloopDriver = (update) => {
         const passTimestamp = ({ timestamp }) => update(timestamp);
         return {
@@ -2421,13 +2351,6 @@
             this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);
             this.resolver.scheduleResolve();
         }
-        flatten() {
-            super.flatten();
-            // If we've already resolved the animation, re-initialise it
-            if (this._resolved) {
-                Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
-            }
-        }
         initPlayback(keyframes$1) {
             const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;
             const generatorFactory = isGenerator(type)
@@ -2747,6 +2670,18 @@
         // "background-color"
     ]);
 
+    // Create a linear easing point for every 10 ms
+    const resolution = 10;
+    const generateLinearEasing = (easing, duration // as milliseconds
+    ) => {
+        let points = "";
+        const numPoints = Math.max(Math.round(duration / resolution), 2);
+        for (let i = 0; i < numPoints; i++) {
+            points += easing(progress(0, numPoints - 1, i)) + ", ";
+        }
+        return `linear(${points.substring(0, points.length - 2)})`;
+    };
+
     function memo(callback) {
         let result;
         return () => {
@@ -2820,7 +2755,7 @@
         }
     }
 
-    function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeInOut", times, } = {}) {
+    function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease, times, } = {}) {
         const keyframeOptions = { [valueName]: keyframes };
         if (times)
             keyframeOptions.offset = times;
@@ -3210,9 +3145,6 @@
         runAll(methodName) {
             this.animations.forEach((controls) => controls[methodName]());
         }
-        flatten() {
-            this.runAll("flatten");
-        }
         play() {
             this.runAll("play");
         }
@@ -3431,7 +3363,7 @@
              * This will be replaced by the build step with the latest version number.
              * When MotionValues are provided to motion components, warn if versions are mixed.
              */
-            this.version = "11.15.0";
+            this.version = "11.11.10";
             /**
              * Tracks whether this value can output a velocity. Currently this is only true
              * if the value is numerical, but we might be able to widen the scope here and support
@@ -4340,84 +4272,6 @@
         },
     };
 
-    const isDragging = {
-        x: false,
-        y: false,
-    };
-    function isDragActive() {
-        return isDragging.x || isDragging.y;
-    }
-
-    function resolveElements(elementOrSelector, scope, selectorCache) {
-        var _a;
-        if (elementOrSelector instanceof Element) {
-            return [elementOrSelector];
-        }
-        else if (typeof elementOrSelector === "string") {
-            let root = document;
-            if (scope) {
-                // TODO: Refactor to utils package
-                // invariant(
-                //     Boolean(scope.current),
-                //     "Scope provided, but no element detected."
-                // )
-                root = scope.current;
-            }
-            const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);
-            return elements ? Array.from(elements) : [];
-        }
-        return Array.from(elementOrSelector);
-    }
-
-    function setupGesture(elementOrSelector, options) {
-        const elements = resolveElements(elementOrSelector);
-        const gestureAbortController = new AbortController();
-        const eventOptions = {
-            passive: true,
-            ...options,
-            signal: gestureAbortController.signal,
-        };
-        const cancel = () => gestureAbortController.abort();
-        return [elements, eventOptions, cancel];
-    }
-
-    /**
-     * Filter out events that are not pointer events, or are triggering
-     * while a Motion gesture is active.
-     */
-    function filterEvents$1(callback) {
-        return (event) => {
-            if (event.pointerType === "touch" || isDragActive())
-                return;
-            callback(event);
-        };
-    }
-    /**
-     * Create a hover gesture. hover() is different to .addEventListener("pointerenter")
-     * in that it has an easier syntax, filters out polyfilled touch events, interoperates
-     * with drag gestures, and automatically removes the "pointerennd" event listener when the hover ends.
-     *
-     * @public
-     */
-    function hover(elementOrSelector, onHoverStart, options = {}) {
-        const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
-        const onPointerEnter = filterEvents$1((enterEvent) => {
-            const { target } = enterEvent;
-            const onHoverEnd = onHoverStart(enterEvent);
-            if (!onHoverEnd || !target)
-                return;
-            const onPointerLeave = filterEvents$1((leaveEvent) => {
-                onHoverEnd(leaveEvent);
-                target.removeEventListener("pointerleave", onPointerLeave);
-            });
-            target.addEventListener("pointerleave", onPointerLeave, eventOptions);
-        });
-        elements.forEach((element) => {
-            element.addEventListener("pointerenter", onPointerEnter, eventOptions);
-        });
-        return cancel;
-    }
-
     const isPrimaryPointer = (event) => {
         if (event.pointerType === "mouse") {
             return typeof event.button !== "number" || event.button <= 0;
@@ -4435,169 +4289,11 @@
         }
     };
 
-    const isPressing = new WeakSet();
-
-    /**
-     * Filter out events that are not "Enter" keys.
-     */
-    function filterEvents(callback) {
-        return (event) => {
-            if (event.key !== "Enter")
-                return;
-            callback(event);
-        };
-    }
-    function firePointerEvent(target, type) {
-        target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
-    }
-    const enableKeyboardPress = (focusEvent, eventOptions) => {
-        const element = focusEvent.currentTarget;
-        if (!element)
-            return;
-        const handleKeydown = filterEvents(() => {
-            if (isPressing.has(element))
-                return;
-            firePointerEvent(element, "down");
-            const handleKeyup = filterEvents(() => {
-                firePointerEvent(element, "up");
-            });
-            const handleBlur = () => firePointerEvent(element, "cancel");
-            element.addEventListener("keyup", handleKeyup, eventOptions);
-            element.addEventListener("blur", handleBlur, eventOptions);
-        });
-        element.addEventListener("keydown", handleKeydown, eventOptions);
-        /**
-         * Add an event listener that fires on blur to remove the keydown events.
-         */
-        element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
-    };
-
-    const focusableElements = new Set([
-        "BUTTON",
-        "INPUT",
-        "SELECT",
-        "TEXTAREA",
-        "A",
-    ]);
-    function isElementKeyboardAccessible(element) {
-        return focusableElements.has(element.tagName) || element.tabIndex !== -1;
-    }
-
-    /**
-     * Recursively traverse up the tree to check whether the provided child node
-     * is the parent or a descendant of it.
-     *
-     * @param parent - Element to find
-     * @param child - Element to test against parent
-     */
-    const isNodeOrChild = (parent, child) => {
-        if (!child) {
-            return false;
-        }
-        else if (parent === child) {
-            return true;
-        }
-        else {
-            return isNodeOrChild(parent, child.parentElement);
-        }
-    };
-
-    /**
-     * Filter out events that are not primary pointer events, or are triggering
-     * while a Motion gesture is active.
-     */
-    function isValidPressEvent(event) {
-        return isPrimaryPointer(event) && !isDragActive();
-    }
-    /**
-     * Create a press gesture.
-     *
-     * Press is different to `"pointerdown"`, `"pointerup"` in that it
-     * automatically filters out secondary pointer events like right
-     * click and multitouch.
-     *
-     * It also adds accessibility support for keyboards, where
-     * an element with a press gesture will receive focus and
-     *  trigger on Enter `"keydown"` and `"keyup"` events.
-     *
-     * This is different to a browser's `"click"` event, which does
-     * respond to keyboards but only for the `"click"` itself, rather
-     * than the press start and end/cancel. The element also needs
-     * to be focusable for this to work, whereas a press gesture will
-     * make an element focusable by default.
-     *
-     * @public
-     */
-    function press(elementOrSelector, onPressStart, options = {}) {
-        const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);
-        const startPress = (startEvent) => {
-            const element = startEvent.currentTarget;
-            if (!isValidPressEvent(startEvent) || isPressing.has(element))
-                return;
-            isPressing.add(element);
-            const onPressEnd = onPressStart(startEvent);
-            const onPointerEnd = (endEvent, success) => {
-                window.removeEventListener("pointerup", onPointerUp);
-                window.removeEventListener("pointercancel", onPointerCancel);
-                if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {
-                    return;
-                }
-                isPressing.delete(element);
-                if (onPressEnd) {
-                    onPressEnd(endEvent, { success });
-                }
-            };
-            const onPointerUp = (upEvent) => {
-                onPointerEnd(upEvent, options.useGlobalTarget ||
-                    isNodeOrChild(element, upEvent.target));
-            };
-            const onPointerCancel = (cancelEvent) => {
-                onPointerEnd(cancelEvent, false);
-            };
-            window.addEventListener("pointerup", onPointerUp, eventOptions);
-            window.addEventListener("pointercancel", onPointerCancel, eventOptions);
-        };
-        elements.forEach((element) => {
-            if (!isElementKeyboardAccessible(element)) {
-                element.tabIndex = 0;
-            }
-            const target = options.useGlobalTarget ? window : element;
-            target.addEventListener("pointerdown", startPress, eventOptions);
-            element.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions), eventOptions);
-        });
-        return cancelEvents;
-    }
-
-    function setDragLock(axis) {
-        if (axis === "x" || axis === "y") {
-            if (isDragging[axis]) {
-                return null;
-            }
-            else {
-                isDragging[axis] = true;
-                return () => {
-                    isDragging[axis] = false;
-                };
-            }
-        }
-        else {
-            if (isDragging.x || isDragging.y) {
-                return null;
-            }
-            else {
-                isDragging.x = isDragging.y = true;
-                return () => {
-                    isDragging.x = isDragging.y = false;
-                };
-            }
-        }
-    }
-
-    function extractEventInfo(event) {
+    function extractEventInfo(event, pointType = "page") {
         return {
             point: {
-                x: event.pageX,
-                y: event.pageY,
+                x: event[`${pointType}X`],
+                y: event[`${pointType}Y`],
             },
         };
     }
@@ -4626,7 +4322,7 @@
      * @internal
      */
     class PanSession {
-        constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {
+        constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
             /**
              * @internal
              */
@@ -4769,6 +4465,58 @@
         return currentVelocity;
     }
 
+    function createLock(name) {
+        let lock = null;
+        return () => {
+            const openLock = () => {
+                lock = null;
+            };
+            if (lock === null) {
+                lock = name;
+                return openLock;
+            }
+            return false;
+        };
+    }
+    const globalHorizontalLock = createLock("dragHorizontal");
+    const globalVerticalLock = createLock("dragVertical");
+    function getGlobalLock(drag) {
+        let lock = false;
+        if (drag === "y") {
+            lock = globalVerticalLock();
+        }
+        else if (drag === "x") {
+            lock = globalHorizontalLock();
+        }
+        else {
+            const openHorizontal = globalHorizontalLock();
+            const openVertical = globalVerticalLock();
+            if (openHorizontal && openVertical) {
+                lock = () => {
+                    openHorizontal();
+                    openVertical();
+                };
+            }
+            else {
+                // Release the locks because we don't use them
+                if (openHorizontal)
+                    openHorizontal();
+                if (openVertical)
+                    openVertical();
+            }
+        }
+        return lock;
+    }
+    function isDragActive() {
+        // Check the gesture lock - if we get it, it means no drag gesture is active
+        // and we can safely fire the tap gesture.
+        const openGestureLock = getGlobalLock(true);
+        if (!openGestureLock)
+            return true;
+        openGestureLock();
+        return false;
+    }
+
     function isRefObject(ref) {
         return (ref &&
             typeof ref === "object" &&
@@ -5152,7 +4900,7 @@
         return viewportBox;
     }
 
-    // Fixes https://github.com/motiondivision/motion/issues/2270
+    // Fixes https://github.com/framer/motion/issues/2270
     const getContextWindow = ({ current }) => {
         return current ? current.ownerDocument.defaultView : null;
     };
@@ -5164,7 +4912,10 @@
     // let latestPointerEvent: PointerEvent
     class VisualElementDragControls {
         constructor(visualElement) {
-            this.openDragLock = null;
+            // This is a reference to the global drag gesture lock, ensuring only one component
+            // can "capture" the drag of one or both axes.
+            // TODO: Look into moving this into pansession?
+            this.openGlobalLock = null;
             this.isDragging = false;
             this.currentDirection = null;
             this.originPoint = { x: 0, y: 0 };
@@ -5192,18 +4943,18 @@
                 // the component.
                 dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();
                 if (snapToCursor) {
-                    this.snapToCursor(extractEventInfo(event).point);
+                    this.snapToCursor(extractEventInfo(event, "page").point);
                 }
             };
             const onStart = (event, info) => {
                 // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
                 const { drag, dragPropagation, onDragStart } = this.getProps();
                 if (drag && !dragPropagation) {
-                    if (this.openDragLock)
-                        this.openDragLock();
-                    this.openDragLock = setDragLock(drag);
+                    if (this.openGlobalLock)
+                        this.openGlobalLock();
+                    this.openGlobalLock = getGlobalLock(drag);
                     // If we don 't have the lock, don't start dragging
-                    if (!this.openDragLock)
+                    if (!this.openGlobalLock)
                         return;
                 }
                 this.isDragging = true;
@@ -5245,7 +4996,7 @@
                 // latestPointerEvent = event
                 const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();
                 // If we didn't successfully receive the gesture lock, early return.
-                if (!dragPropagation && !this.openDragLock)
+                if (!dragPropagation && !this.openGlobalLock)
                     return;
                 const { offset } = info;
                 // Attempt to detect drag direction if directionLock is true
@@ -5313,9 +5064,9 @@
             this.panSession && this.panSession.end();
             this.panSession = undefined;
             const { dragPropagation } = this.getProps();
-            if (!dragPropagation && this.openDragLock) {
-                this.openDragLock();
-                this.openDragLock = null;
+            if (!dragPropagation && this.openGlobalLock) {
+                this.openGlobalLock();
+                this.openGlobalLock = null;
             }
             animationState && animationState.setActive("whileDrag", false);
         }
@@ -6120,6 +5871,31 @@
         };
     }
 
+    function resolveElements(elements, scope, selectorCache) {
+        var _a;
+        if (typeof elements === "string") {
+            let root = document;
+            if (scope) {
+                exports.invariant(Boolean(scope.current), "Scope provided, but no element detected.");
+                root = scope.current;
+            }
+            if (selectorCache) {
+                (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));
+                elements = selectorCache[elements];
+            }
+            else {
+                elements = root.querySelectorAll(elements);
+            }
+        }
+        else if (elements instanceof Element) {
+            elements = [elements];
+        }
+        /**
+         * Return an empty array
+         */
+        return Array.from(elements || []);
+    }
+
     function isDOMKeyframes(keyframes) {
         return typeof keyframes === "object" && !Array.isArray(keyframes);
     }
@@ -6207,24 +5983,7 @@
         }
     }
 
-    /**
-     * Take an array of times that represent repeated keyframes. For instance
-     * if we have original times of [0, 0.5, 1] then our repeated times will
-     * be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back
-     * down to a 0-1 scale.
-     */
-    function normalizeTimes(times, repeat) {
-        for (let i = 0; i < times.length; i++) {
-            times[i] = times[i] / (repeat + 1);
-        }
-    }
-
-    function calculateRepeatDuration(duration, repeat, _repeatDelay) {
-        return duration * (repeat + 1);
-    }
-
     const defaultSegmentEasing = "easeInOut";
-    const MAX_REPEAT = 20;
     function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {
         const defaultDuration = defaultTransition.duration || 0.3;
         const animationDefinitions = new Map();
@@ -6267,7 +6026,7 @@
             let maxDuration = 0;
             const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
                 const valueKeyframesAsList = keyframesAsList(valueKeyframes);
-                const { delay = 0, times = defaultOffset$1(valueKeyframesAsList), type = "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;
+                const { delay = 0, times = defaultOffset$1(valueKeyframesAsList), type = "keyframes", ...remainingTransition } = valueTransition;
                 let { ease = defaultTransition.ease || "easeOut", duration } = valueTransition;
                 /**
                  * Resolve stagger() if defined.
@@ -6305,6 +6064,7 @@
                 }
                 duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);
                 const startTime = currentTime + calculatedDelay;
+                const targetTime = startTime + duration;
                 /**
                  * If there's only one time offset of 0, fill in a second with length 1
                  */
@@ -6323,28 +6083,6 @@
                  */
                 valueKeyframesAsList.length === 1 &&
                     valueKeyframesAsList.unshift(null);
-                /**
-                 * Handle repeat options
-                 */
-                if (repeat) {
-                    exports.invariant(repeat < MAX_REPEAT, "Repeat count too high, must be less than 20");
-                    duration = calculateRepeatDuration(duration, repeat);
-                    const originalKeyframes = [...valueKeyframesAsList];
-                    const originalTimes = [...times];
-                    ease = Array.isArray(ease) ? [...ease] : [ease];
-                    const originalEase = [...ease];
-                    for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
-                        valueKeyframesAsList.push(...originalKeyframes);
-                        for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {
-                            times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));
-                            ease.push(keyframeIndex === 0
-                                ? "linear"
-                                : getEasingForSegment(originalEase, keyframeIndex - 1));
-                        }
-                    }
-                    normalizeTimes(times, repeat);
-                }
-                const targetTime = startTime + duration;
                 /**
                  * Add keyframes, mapping offsets to absolute time.
                  */
@@ -6549,7 +6287,7 @@
                  * and warn against mismatches.
                  */
                 {
-                    warnOnce(nextValue.version === "11.15.0", `Attempting to mix Motion versions ${nextValue.version} with 11.15.0 may not work as expected.`);
+                    warnOnce(nextValue.version === "11.11.10", `Attempting to mix Framer Motion versions ${nextValue.version} with 11.11.10 may not work as expected.`);
                 }
             }
             else if (isMotionValue(prevValue)) {
@@ -7100,20 +6838,6 @@
             delete vars[key];
             delete style[key];
         }
-        handleChildMotionValue() {
-            if (this.childSubscription) {
-                this.childSubscription();
-                delete this.childSubscription;
-            }
-            const { children } = this.props;
-            if (isMotionValue(children)) {
-                this.childSubscription = children.on("change", (latest) => {
-                    if (this.current) {
-                        this.current.textContent = `${latest}`;
-                    }
-                });
-            }
-        }
     }
 
     /**
@@ -7441,6 +7165,19 @@
         scrapeMotionValuesFromProps(props, prevProps, visualElement) {
             return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
         }
+        handleChildMotionValue() {
+            if (this.childSubscription) {
+                this.childSubscription();
+                delete this.childSubscription;
+            }
+            const { children } = this.props;
+            if (isMotionValue(children)) {
+                this.childSubscription = children.on("change", (latest) => {
+                    if (this.current)
+                        this.current.textContent = `${latest}`;
+                });
+            }
+        }
     }
 
     function isObjectKey(key, object) {
@@ -7659,7 +7396,6 @@
                 valueKeyframes = [valueKeyframes];
             }
             hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe);
-            // TODO: Replace this with toString()?
             if (isGenerator(options.type)) {
                 const generatorOptions = createGeneratorEasing(options, 100, options.type);
                 options.ease = supportsLinearEasing()
@@ -7721,12 +7457,6 @@
         get startTime() {
             return this.animation ? this.animation.startTime : null;
         }
-        flatten() {
-            var _a;
-            if (!this.animation)
-                return;
-            (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: "linear" });
-        }
         play() {
             if (this.state === "finished") {
                 this.updateFinishedPromise();
@@ -7798,7 +7528,7 @@
             for (const valueName in keyframes) {
                 const valueKeyframes = keyframes[valueName];
                 const valueOptions = {
-                    ...getValueTransition$1(elementTransition, valueName),
+                    ...getValueTransition$1(options, valueName),
                 };
                 valueOptions.duration = valueOptions.duration
                     ? secondsToMilliseconds(valueOptions.duration)
@@ -8343,7 +8073,6 @@
         }
     }
     function scrollAnimation(animation, options) {
-        animation.flatten();
         if (needsElementTracking(options)) {
             animation.pause();
             return scrollInfo((info) => {
@@ -8352,17 +8081,12 @@
         }
         else {
             const timeline = getTimeline(options);
-            if (animation.attachTimeline) {
-                return animation.attachTimeline(timeline, (valueAnimation) => {
-                    valueAnimation.pause();
-                    return observeTimeline((progress) => {
-                        valueAnimation.time = valueAnimation.duration * progress;
-                    }, timeline);
-                });
-            }
-            else {
-                return noop;
-            }
+            return animation.attachTimeline(timeline, (valueAnimation) => {
+                valueAnimation.pause();
+                return observeTimeline((progress) => {
+                    valueAnimation.time = valueAnimation.duration * progress;
+                }, timeline);
+            });
         }
     }
     function scroll(onScroll, { axis = "y", ...options } = {}) {
@@ -10399,26 +10123,28 @@
         },
     };
 
-    function handleHoverEvent(node, event, lifecycle) {
-        const { props } = node;
-        if (node.animationState && props.whileHover) {
-            node.animationState.setActive("whileHover", lifecycle === "Start");
-        }
-        const eventName = ("onHover" + lifecycle);
-        const callback = props[eventName];
-        if (callback) {
-            frame.postRender(() => callback(event, extractEventInfo(event)));
-        }
+    function addHoverEvent(node, isActive) {
+        const eventName = isActive ? "pointerenter" : "pointerleave";
+        const callbackName = isActive ? "onHoverStart" : "onHoverEnd";
+        const handleEvent = (event, info) => {
+            if (event.pointerType === "touch" || isDragActive())
+                return;
+            const props = node.getProps();
+            if (node.animationState && props.whileHover) {
+                node.animationState.setActive("whileHover", isActive);
+            }
+            const callback = props[callbackName];
+            if (callback) {
+                frame.postRender(() => callback(event, info));
+            }
+        };
+        return addPointerEvent(node.current, eventName, handleEvent, {
+            passive: !node.getProps()[callbackName],
+        });
     }
     class HoverGesture extends Feature {
         mount() {
-            const { current } = this.node;
-            if (!current)
-                return;
-            this.unmount = hover(current, (startEvent) => {
-                handleHoverEvent(this.node, startEvent, "Start");
-                return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
-            });
+            this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
         }
         unmount() { }
     }
@@ -10459,28 +10185,142 @@
         unmount() { }
     }
 
-    function handlePressEvent(node, event, lifecycle) {
-        const { props } = node;
-        if (node.animationState && props.whileTap) {
-            node.animationState.setActive("whileTap", lifecycle === "Start");
+    /**
+     * Recursively traverse up the tree to check whether the provided child node
+     * is the parent or a descendant of it.
+     *
+     * @param parent - Element to find
+     * @param child - Element to test against parent
+     */
+    const isNodeOrChild = (parent, child) => {
+        if (!child) {
+            return false;
+        }
+        else if (parent === child) {
+            return true;
         }
-        const eventName = ("onTap" + (lifecycle === "End" ? "" : lifecycle));
-        const callback = props[eventName];
-        if (callback) {
-            frame.postRender(() => callback(event, extractEventInfo(event)));
+        else {
+            return isNodeOrChild(parent, child.parentElement);
         }
+    };
+
+    function fireSyntheticPointerEvent(name, handler) {
+        if (!handler)
+            return;
+        const syntheticPointerEvent = new PointerEvent("pointer" + name);
+        handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
     }
     class PressGesture extends Feature {
-        mount() {
-            const { current } = this.node;
-            if (!current)
+        constructor() {
+            super(...arguments);
+            this.removeStartListeners = noop;
+            this.removeEndListeners = noop;
+            this.removeAccessibleListeners = noop;
+            this.startPointerPress = (startEvent, startInfo) => {
+                if (this.isPressing)
+                    return;
+                this.removeEndListeners();
+                const props = this.node.getProps();
+                const endPointerPress = (endEvent, endInfo) => {
+                    if (!this.checkPressEnd())
+                        return;
+                    const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
+                    /**
+                     * We only count this as a tap gesture if the event.target is the same
+                     * as, or a child of, this component's element
+                     */
+                    const handler = !globalTapTarget &&
+                        !isNodeOrChild(this.node.current, endEvent.target)
+                        ? onTapCancel
+                        : onTap;
+                    if (handler) {
+                        frame.update(() => handler(endEvent, endInfo));
+                    }
+                };
+                const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, {
+                    passive: !(props.onTap || props["onPointerUp"]),
+                });
+                const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), {
+                    passive: !(props.onTapCancel ||
+                        props["onPointerCancel"]),
+                });
+                this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
+                this.startPress(startEvent, startInfo);
+            };
+            this.startAccessiblePress = () => {
+                const handleKeydown = (keydownEvent) => {
+                    if (keydownEvent.key !== "Enter" || this.isPressing)
+                        return;
+                    const handleKeyup = (keyupEvent) => {
+                        if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
+                            return;
+                        fireSyntheticPointerEvent("up", (event, info) => {
+                            const { onTap } = this.node.getProps();
+                            if (onTap) {
+                                frame.postRender(() => onTap(event, info));
+                            }
+                        });
+                    };
+                    this.removeEndListeners();
+                    this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
+                    fireSyntheticPointerEvent("down", (event, info) => {
+                        this.startPress(event, info);
+                    });
+                };
+                const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
+                const handleBlur = () => {
+                    if (!this.isPressing)
+                        return;
+                    fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
+                };
+                const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
+                this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
+            };
+        }
+        startPress(event, info) {
+            this.isPressing = true;
+            const { onTapStart, whileTap } = this.node.getProps();
+            /**
+             * Ensure we trigger animations before firing event callback
+             */
+            if (whileTap && this.node.animationState) {
+                this.node.animationState.setActive("whileTap", true);
+            }
+            if (onTapStart) {
+                frame.postRender(() => onTapStart(event, info));
+            }
+        }
+        checkPressEnd() {
+            this.removeEndListeners();
+            this.isPressing = false;
+            const props = this.node.getProps();
+            if (props.whileTap && this.node.animationState) {
+                this.node.animationState.setActive("whileTap", false);
+            }
+            return !isDragActive();
+        }
+        cancelPress(event, info) {
+            if (!this.checkPressEnd())
                 return;
-            this.unmount = press(current, (startEvent) => {
-                handlePressEvent(this.node, startEvent, "Start");
-                return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
-            }, { useGlobalTarget: this.node.props.globalTapTarget });
+            const { onTapCancel } = this.node.getProps();
+            if (onTapCancel) {
+                frame.postRender(() => onTapCancel(event, info));
+            }
+        }
+        mount() {
+            const props = this.node.getProps();
+            const removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
+                passive: !(props.onTapStart ||
+                    props["onPointerStart"]),
+            });
+            const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
+            this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
+        }
+        unmount() {
+            this.removeStartListeners();
+            this.removeEndListeners();
+            this.removeAccessibleListeners();
         }
-        unmount() { }
     }
 
     /**
@@ -10642,7 +10482,7 @@
         const lazyContext = React$1.useContext(LazyContext);
         const presenceContext = React$1.useContext(PresenceContext);
         const reducedMotionConfig = React$1.useContext(MotionConfigContext).reducedMotion;
-        const visualElementRef = React$1.useRef(null);
+        const visualElementRef = React$1.useRef();
         /**
          * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
          */
@@ -10671,15 +10511,8 @@
             (visualElement.type === "html" || visualElement.type === "svg")) {
             createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
         }
-        const isMounted = React$1.useRef(false);
         React$1.useInsertionEffect(() => {
-            /**
-             * Check the component has already mounted before calling
-             * `update` unnecessarily. This ensures we skip the initial update.
-             */
-            if (visualElement && isMounted.current) {
-                visualElement.update(props, presenceContext);
-            }
+            visualElement && visualElement.update(props, presenceContext);
         });
         /**
          * Cache this value as we want to know whether HandoffAppearAnimations
@@ -10692,7 +10525,6 @@
         useIsomorphicLayoutEffect(() => {
             if (!visualElement)
                 return;
-            isMounted.current = true;
             window.MotionIsMounted = true;
             visualElement.updateFeatures();
             microtask.render(visualElement.render);
@@ -10885,7 +10717,7 @@
             isStrict) {
             const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
             configAndProps.ignoreStrict
-                ? warning(false, strictMessage)
+                ? exports.warning(false, strictMessage)
                 : exports.invariant(false, strictMessage);
         }
     }
@@ -11364,7 +11196,7 @@
             return this.props.children;
         }
     }
-    function PopChild({ children, isPresent }) {
+    function PopChild({ children, isPresent, parentDom }) {
         const id = React$1.useId();
         const ref = React$1.useRef(null);
         const size = React$1.useRef({
@@ -11391,7 +11223,8 @@
             const style = document.createElement("style");
             if (nonce)
                 style.nonce = nonce;
-            document.head.appendChild(style);
+            const parent = parentDom !== null && parentDom !== void 0 ? parentDom : document.head;
+            parent.appendChild(style);
             if (style.sheet) {
                 style.sheet.insertRule(`
           [data-motion-pop-id="${id}"] {
@@ -11404,13 +11237,13 @@
         `);
             }
             return () => {
-                document.head.removeChild(style);
+                parent.removeChild(style);
             };
         }, [isPresent]);
         return (jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React__namespace.cloneElement(children, { ref }) }));
     }
 
-    const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, }) => {
+    const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, parentDom }) => {
         const presenceChildren = useConstant(newChildrenMap);
         const id = React$1.useId();
         const memoizedOnExitComplete = React$1.useCallback((childId) => {
@@ -11454,7 +11287,7 @@
                 onExitComplete();
         }, [isPresent]);
         if (mode === "popLayout") {
-            children = jsx(PopChild, { isPresent: isPresent, children: children });
+            children = jsx(PopChild, { isPresent: isPresent, parentDom: parentDom, children: children });
         }
         return (jsx(PresenceContext.Provider, { value: context, children: children }));
     };
@@ -11535,7 +11368,7 @@
      *
      * @public
      */
-    const AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", }) => {
+    const AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", parentDom, }) => {
         exports.invariant(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
         /**
          * Filter any children that aren't ReactElements. We can only track components
@@ -11649,7 +11482,7 @@
                 };
                 return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial
                         ? undefined
-                        : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, children: child }, key));
+                        : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, parentDom: parentDom, onExitComplete: isPresent ? undefined : onExit, children: child }, key));
             }) }));
     };
 
@@ -12163,7 +11996,7 @@
     }
 
     function refWarning(name, ref) {
-        warning(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`);
+        exports.warning(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`);
     }
     const createScrollMotionValues = () => ({
         scrollX: motionValue(0),
@@ -12668,7 +12501,7 @@
     function useInstantTransition() {
         const [forceUpdate, forcedRenderCount] = useForceUpdate();
         const startInstantLayoutTransition = useInstantLayoutTransition();
-        const unlockOnFrameRef = React$1.useRef(-1);
+        const unlockOnFrameRef = React$1.useRef();
         React$1.useEffect(() => {
             /**
              * Unblock after two animation frames, otherwise this will unblock too soon.
@@ -13003,7 +12836,7 @@
         let parentScaleY = useMotionValue(1);
         const { visualElement } = React$1.useContext(MotionContext);
         exports.invariant(!!(scale || visualElement), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
-        warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
+        exports.warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
         hasWarned = true;
         if (scale) {
             parentScaleX = scale.scaleX || parentScaleX;
@@ -13101,7 +12934,6 @@
     exports.mix = mix;
     exports.motion = motion;
     exports.motionValue = motionValue;
-    exports.noop = noop;
     exports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;
     exports.pipe = pipe;
     exports.progress = progress;
@@ -13115,7 +12947,6 @@
     exports.startOptimizedAppearAnimation = startOptimizedAppearAnimation;
     exports.steps = steps;
     exports.sync = sync;
-    exports.time = time;
     exports.transform = transform;
     exports.unwrapMotionComponent = unwrapMotionComponent;
     exports.useAnimate = useAnimate;
diff --git a/dist/framer-motion.js b/dist/framer-motion.js
index 9b53a421be882660766e2ba8ba97b9c9fa503b26..d8e26fb5b32f8ed53bbd35586cd7bf23132e46e1 100644
--- a/dist/framer-motion.js
+++ b/dist/framer-motion.js
@@ -1 +1 @@
-!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Motion={},t.React)}(this,(function(t,e){"use strict";function n(t){var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var i=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,i.get?i:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var i=n(e);function s(t){if("undefined"==typeof Proxy)return t;const e=new Map;return new Proxy((...e)=>t(...e),{get:(n,i)=>"create"===i?t:(e.has(i)||e.set(i,t(i)),e.get(i))})}function o(t){return null!==t&&"object"==typeof t&&"function"==typeof t.start}const r=t=>Array.isArray(t);function a(t,e){if(!Array.isArray(e))return!1;const n=e.length;if(n!==t.length)return!1;for(let i=0;i<n;i++)if(e[i]!==t[i])return!1;return!0}function l(t){return"string"==typeof t||Array.isArray(t)}function u(t){const e=[{},{}];return null==t||t.values.forEach((t,n)=>{e[0][n]=t.get(),e[1][n]=t.getVelocity()}),e}function c(t,e,n,i){if("function"==typeof e){const[s,o]=u(i);e=e(void 0!==n?n:t.custom,s,o)}if("string"==typeof e&&(e=t.variants&&t.variants[e]),"function"==typeof e){const[s,o]=u(i);e=e(void 0!==n?n:t.custom,s,o)}return e}function h(t,e,n){const i=t.getProps();return c(i,e,void 0!==n?n:i.custom,t)}const d=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],p=["initial",...d],m=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],f=new Set(m),g=t=>1e3*t,y=t=>t/1e3,v={type:"spring",stiffness:500,damping:25,restSpeed:10},x={type:"keyframes",duration:.8},w={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},P=(t,{keyframes:e})=>e.length>2?x:f.has(t)?t.startsWith("scale")?{type:"spring",stiffness:550,damping:0===e[1]?2*Math.sqrt(550):30,restSpeed:10}:v:w;function T(t,e){return t?t[e]||t.default||t:void 0}const S={skipAnimations:!1,useManualTiming:!1},b={current:!1},A=t=>null!==t;function E(t,{repeat:e,repeatType:n="loop"},i){const s=t.filter(A),o=e&&"loop"!==n&&e%2==1?0:s.length-1;return o&&void 0!==i?i:s[o]}const M=t=>t;let C=M,V=M;const R=["read","resolveKeyframes","update","preRender","render","postRender"];function D(t,e){let n=!1,i=!0;const s={delta:0,timestamp:0,isProcessing:!1},o=()=>n=!0,r=R.reduce((t,e)=>(t[e]=function(t){let e=new Set,n=new Set,i=!1,s=!1;const o=new WeakSet;let r={delta:0,timestamp:0,isProcessing:!1};function a(e){o.has(e)&&(l.schedule(e),t()),e(r)}const l={schedule:(t,s=!1,r=!1)=>{const a=r&&i?e:n;return s&&o.add(t),a.has(t)||a.add(t),t},cancel:t=>{n.delete(t),o.delete(t)},process:t=>{r=t,i?s=!0:(i=!0,[e,n]=[n,e],e.forEach(a),e.clear(),i=!1,s&&(s=!1,l.process(t)))}};return l}(o),t),{}),{read:a,resolveKeyframes:l,update:u,preRender:c,render:h,postRender:d}=r,p=()=>{const o=S.useManualTiming?s.timestamp:performance.now();n=!1,s.delta=i?1e3/60:Math.max(Math.min(o-s.timestamp,40),1),s.timestamp=o,s.isProcessing=!0,a.process(s),l.process(s),u.process(s),c.process(s),h.process(s),d.process(s),s.isProcessing=!1,n&&e&&(i=!1,t(p))};return{schedule:R.reduce((e,o)=>{const a=r[o];return e[o]=(e,o=!1,r=!1)=>(n||(n=!0,i=!0,s.isProcessing||t(p)),a.schedule(e,o,r)),e},{}),cancel:t=>{for(let e=0;e<R.length;e++)r[R[e]].cancel(t)},state:s,steps:r}}const{schedule:k,cancel:L,state:B,steps:F}=D("undefined"!=typeof requestAnimationFrame?requestAnimationFrame:M,!0),j=(t,e,n)=>(((1-3*n+3*e)*t+(3*n-6*e))*t+3*e)*t;function O(t,e,n,i){if(t===e&&n===i)return M;const s=e=>function(t,e,n,i,s){let o,r,a=0;do{r=e+(n-e)/2,o=j(r,i,s)-t,o>0?n=r:e=r}while(Math.abs(o)>1e-7&&++a<12);return r}(e,0,1,t,n);return t=>0===t||1===t?t:j(s(t),e,i)}const I=t=>e=>e<=.5?t(2*e)/2:(2-t(2*(1-e)))/2,U=t=>e=>1-t(1-e),W=O(.33,1.53,.69,.99),N=U(W),z=I(N),$=t=>(t*=2)<1?.5*N(t):.5*(2-Math.pow(2,-10*(t-1))),H=t=>1-Math.sin(Math.acos(t)),Y=U(H),X=I(H),K=t=>/^0[^.\s]+$/u.test(t);const G=t=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),_=t=>e=>"string"==typeof e&&e.startsWith(t),q=_("--"),Z=_("var(--"),J=t=>!!Z(t)&&Q.test(t.split("/*")[0].trim()),Q=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,tt=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function et(t,e,n=1){const[i,s]=function(t){const e=tt.exec(t);if(!e)return[,];const[,n,i,s]=e;return["--"+(null!=n?n:i),s]}(t);if(!i)return;const o=window.getComputedStyle(e).getPropertyValue(i);if(o){const t=o.trim();return G(t)?parseFloat(t):t}return J(s)?et(s,e,n+1):s}const nt=(t,e,n)=>n>e?e:n<t?t:n,it={test:t=>"number"==typeof t,parse:parseFloat,transform:t=>t},st={...it,transform:t=>nt(0,1,t)},ot={...it,default:1},rt=t=>({test:e=>"string"==typeof e&&e.endsWith(t)&&1===e.split(" ").length,parse:parseFloat,transform:e=>`${e}${t}`}),at=rt("deg"),lt=rt("%"),ut=rt("px"),ct=rt("vh"),ht=rt("vw"),dt={...lt,parse:t=>lt.parse(t)/100,transform:t=>lt.transform(100*t)},pt=new Set(["width","height","top","left","right","bottom","x","y","translateX","translateY"]),mt=t=>t===it||t===ut,ft=(t,e)=>parseFloat(t.split(", ")[e]),gt=(t,e)=>(n,{transform:i})=>{if("none"===i||!i)return 0;const s=i.match(/^matrix3d\((.+)\)$/u);if(s)return ft(s[1],e);{const e=i.match(/^matrix\((.+)\)$/u);return e?ft(e[1],t):0}},yt=new Set(["x","y","z"]),vt=m.filter(t=>!yt.has(t));const xt={width:({x:t},{paddingLeft:e="0",paddingRight:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),height:({y:t},{paddingTop:e="0",paddingBottom:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),top:(t,{top:e})=>parseFloat(e),left:(t,{left:e})=>parseFloat(e),bottom:({y:t},{top:e})=>parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=>parseFloat(e)+(t.max-t.min),x:gt(4,13),y:gt(5,14)};xt.translateX=xt.x,xt.translateY=xt.y;const wt=t=>e=>e.test(t),Pt=[it,ut,lt,at,ht,ct,{test:t=>"auto"===t,parse:t=>t}],Tt=t=>Pt.find(wt(t)),St=new Set;let bt=!1,At=!1;function Et(){if(At){const t=Array.from(St).filter(t=>t.needsMeasurement),e=new Set(t.map(t=>t.element)),n=new Map;e.forEach(t=>{const e=function(t){const e=[];return vt.forEach(n=>{const i=t.getValue(n);void 0!==i&&(e.push([n,i.get()]),i.set(n.startsWith("scale")?1:0))}),e}(t);e.length&&(n.set(t,e),t.render())}),t.forEach(t=>t.measureInitialState()),e.forEach(t=>{t.render();const e=n.get(t);e&&e.forEach(([e,n])=>{var i;null===(i=t.getValue(e))||void 0===i||i.set(n)})}),t.forEach(t=>t.measureEndState()),t.forEach(t=>{void 0!==t.suspendedScrollY&&window.scrollTo(0,t.suspendedScrollY)})}At=!1,bt=!1,St.forEach(t=>t.complete()),St.clear()}function Mt(){St.forEach(t=>{t.readKeyframes(),t.needsMeasurement&&(At=!0)})}class Ct{constructor(t,e,n,i,s,o=!1){this.isComplete=!1,this.isAsync=!1,this.needsMeasurement=!1,this.isScheduled=!1,this.unresolvedKeyframes=[...t],this.onComplete=e,this.name=n,this.motionValue=i,this.element=s,this.isAsync=o}scheduleResolve(){this.isScheduled=!0,this.isAsync?(St.add(this),bt||(bt=!0,k.read(Mt),k.resolveKeyframes(Et))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:t,name:e,element:n,motionValue:i}=this;for(let s=0;s<t.length;s++)if(null===t[s])if(0===s){const s=null==i?void 0:i.get(),o=t[t.length-1];if(void 0!==s)t[0]=s;else if(n&&e){const i=n.readValue(e,o);null!=i&&(t[0]=i)}void 0===t[0]&&(t[0]=o),i&&void 0===s&&i.set(t[0])}else t[s]=t[s-1]}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(){this.isComplete=!0,this.onComplete(this.unresolvedKeyframes,this.finalKeyframe),St.delete(this)}cancel(){this.isComplete||(this.isScheduled=!1,St.delete(this))}resume(){this.isComplete||this.scheduleResolve()}}const Vt=t=>Math.round(1e5*t)/1e5,Rt=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;const Dt=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,kt=(t,e)=>n=>Boolean("string"==typeof n&&Dt.test(n)&&n.startsWith(t)||e&&!function(t){return null==t}(n)&&Object.prototype.hasOwnProperty.call(n,e)),Lt=(t,e,n)=>i=>{if("string"!=typeof i)return i;const[s,o,r,a]=i.match(Rt);return{[t]:parseFloat(s),[e]:parseFloat(o),[n]:parseFloat(r),alpha:void 0!==a?parseFloat(a):1}},Bt={...it,transform:t=>Math.round((t=>nt(0,255,t))(t))},Ft={test:kt("rgb","red"),parse:Lt("red","green","blue"),transform:({red:t,green:e,blue:n,alpha:i=1})=>"rgba("+Bt.transform(t)+", "+Bt.transform(e)+", "+Bt.transform(n)+", "+Vt(st.transform(i))+")"};const jt={test:kt("#"),parse:function(t){let e="",n="",i="",s="";return t.length>5?(e=t.substring(1,3),n=t.substring(3,5),i=t.substring(5,7),s=t.substring(7,9)):(e=t.substring(1,2),n=t.substring(2,3),i=t.substring(3,4),s=t.substring(4,5),e+=e,n+=n,i+=i,s+=s),{red:parseInt(e,16),green:parseInt(n,16),blue:parseInt(i,16),alpha:s?parseInt(s,16)/255:1}},transform:Ft.transform},Ot={test:kt("hsl","hue"),parse:Lt("hue","saturation","lightness"),transform:({hue:t,saturation:e,lightness:n,alpha:i=1})=>"hsla("+Math.round(t)+", "+lt.transform(Vt(e))+", "+lt.transform(Vt(n))+", "+Vt(st.transform(i))+")"},It={test:t=>Ft.test(t)||jt.test(t)||Ot.test(t),parse:t=>Ft.test(t)?Ft.parse(t):Ot.test(t)?Ot.parse(t):jt.parse(t),transform:t=>"string"==typeof t?t:t.hasOwnProperty("red")?Ft.transform(t):Ot.transform(t)},Ut=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;const Wt=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function Nt(t){const e=t.toString(),n=[],i={color:[],number:[],var:[]},s=[];let o=0;const r=e.replace(Wt,t=>(It.test(t)?(i.color.push(o),s.push("color"),n.push(It.parse(t))):t.startsWith("var(")?(i.var.push(o),s.push("var"),n.push(t)):(i.number.push(o),s.push("number"),n.push(parseFloat(t))),++o,"${}")).split("${}");return{values:n,split:r,indexes:i,types:s}}function zt(t){return Nt(t).values}function $t(t){const{split:e,types:n}=Nt(t),i=e.length;return t=>{let s="";for(let o=0;o<i;o++)if(s+=e[o],void 0!==t[o]){const e=n[o];s+="number"===e?Vt(t[o]):"color"===e?It.transform(t[o]):t[o]}return s}}const Ht=t=>"number"==typeof t?0:t;const Yt={test:function(t){var e,n;return isNaN(t)&&"string"==typeof t&&((null===(e=t.match(Rt))||void 0===e?void 0:e.length)||0)+((null===(n=t.match(Ut))||void 0===n?void 0:n.length)||0)>0},parse:zt,createTransformer:$t,getAnimatableNone:function(t){const e=zt(t);return $t(t)(e.map(Ht))}},Xt=new Set(["brightness","contrast","saturate","opacity"]);function Kt(t){const[e,n]=t.slice(0,-1).split("(");if("drop-shadow"===e)return t;const[i]=n.match(Rt)||[];if(!i)return t;const s=n.replace(i,"");let o=Xt.has(e)?1:0;return i!==n&&(o*=100),e+"("+o+s+")"}const Gt=/\b([a-z-]*)\(.*?\)/gu,_t={...Yt,getAnimatableNone:t=>{const e=t.match(Gt);return e?e.map(Kt).join(" "):t}},qt={borderWidth:ut,borderTopWidth:ut,borderRightWidth:ut,borderBottomWidth:ut,borderLeftWidth:ut,borderRadius:ut,radius:ut,borderTopLeftRadius:ut,borderTopRightRadius:ut,borderBottomRightRadius:ut,borderBottomLeftRadius:ut,width:ut,maxWidth:ut,height:ut,maxHeight:ut,top:ut,right:ut,bottom:ut,left:ut,padding:ut,paddingTop:ut,paddingRight:ut,paddingBottom:ut,paddingLeft:ut,margin:ut,marginTop:ut,marginRight:ut,marginBottom:ut,marginLeft:ut,backgroundPositionX:ut,backgroundPositionY:ut},Zt={rotate:at,rotateX:at,rotateY:at,rotateZ:at,scale:ot,scaleX:ot,scaleY:ot,scaleZ:ot,skew:at,skewX:at,skewY:at,distance:ut,translateX:ut,translateY:ut,translateZ:ut,x:ut,y:ut,z:ut,perspective:ut,transformPerspective:ut,opacity:st,originX:dt,originY:dt,originZ:ut},Jt={...it,transform:Math.round},Qt={...qt,...Zt,zIndex:Jt,size:ut,fillOpacity:st,strokeOpacity:st,numOctaves:Jt},te={...Qt,color:It,backgroundColor:It,outlineColor:It,fill:It,stroke:It,borderColor:It,borderTopColor:It,borderRightColor:It,borderBottomColor:It,borderLeftColor:It,filter:_t,WebkitFilter:_t},ee=t=>te[t];function ne(t,e){let n=ee(t);return n!==_t&&(n=Yt),n.getAnimatableNone?n.getAnimatableNone(e):void 0}const ie=new Set(["auto","none","0"]);class se extends Ct{constructor(t,e,n,i,s){super(t,e,n,i,s,!0)}readKeyframes(){const{unresolvedKeyframes:t,element:e,name:n}=this;if(!e||!e.current)return;super.readKeyframes();for(let n=0;n<t.length;n++){let i=t[n];if("string"==typeof i&&(i=i.trim(),J(i))){const s=et(i,e.current);void 0!==s&&(t[n]=s),n===t.length-1&&(this.finalKeyframe=i)}}if(this.resolveNoneKeyframes(),!pt.has(n)||2!==t.length)return;const[i,s]=t,o=Tt(i),r=Tt(s);if(o!==r)if(mt(o)&&mt(r))for(let e=0;e<t.length;e++){const n=t[e];"string"==typeof n&&(t[e]=parseFloat(n))}else this.needsMeasurement=!0}resolveNoneKeyframes(){const{unresolvedKeyframes:t,name:e}=this,n=[];for(let e=0;e<t.length;e++)("number"==typeof(i=t[e])?0===i:null===i||"none"===i||"0"===i||K(i))&&n.push(e);var i;n.length&&function(t,e,n){let i=0,s=void 0;for(;i<t.length&&!s;){const e=t[i];"string"==typeof e&&!ie.has(e)&&Nt(e).values.length&&(s=t[i]),i++}if(s&&n)for(const i of e)t[i]=ne(n,s)}(t,n,e)}measureInitialState(){const{element:t,unresolvedKeyframes:e,name:n}=this;if(!t||!t.current)return;"height"===n&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=xt[n](t.measureViewportBox(),window.getComputedStyle(t.current)),e[0]=this.measuredOrigin;const i=e[e.length-1];void 0!==i&&t.getValue(n,i).jump(i,!1)}measureEndState(){var t;const{element:e,name:n,unresolvedKeyframes:i}=this;if(!e||!e.current)return;const s=e.getValue(n);s&&s.jump(this.measuredOrigin,!1);const o=i.length-1,r=i[o];i[o]=xt[n](e.measureViewportBox(),window.getComputedStyle(e.current)),null!==r&&void 0===this.finalKeyframe&&(this.finalKeyframe=r),(null===(t=this.removedTransforms)||void 0===t?void 0:t.length)&&this.removedTransforms.forEach(([t,n])=>{e.getValue(t).set(n)}),this.resolveNoneKeyframes()}}function oe(t){return"function"==typeof t}let re;function ae(){re=void 0}const le={now:()=>(void 0===re&&le.set(B.isProcessing||S.useManualTiming?B.timestamp:performance.now()),re),set:t=>{re=t,queueMicrotask(ae)}},ue=(t,e)=>"zIndex"!==e&&(!("number"!=typeof t&&!Array.isArray(t))||!("string"!=typeof t||!Yt.test(t)&&"0"!==t||t.startsWith("url(")));function ce(t,e,n,i){const s=t[0];if(null===s)return!1;if("display"===e||"visibility"===e)return!0;const o=t[t.length-1],r=ue(s,e),a=ue(o,e);return!(!r||!a)&&(function(t){const e=t[0];if(1===t.length)return!0;for(let n=0;n<t.length;n++)if(t[n]!==e)return!0}(t)||("spring"===n||oe(n))&&i)}class he{constructor({autoplay:t=!0,delay:e=0,type:n="keyframes",repeat:i=0,repeatDelay:s=0,repeatType:o="loop",...r}){this.isStopped=!1,this.hasAttemptedResolve=!1,this.createdAt=le.now(),this.options={autoplay:t,delay:e,type:n,repeat:i,repeatDelay:s,repeatType:o,...r},this.updateFinishedPromise()}calcStartTime(){return this.resolvedAt&&this.resolvedAt-this.createdAt>40?this.resolvedAt:this.createdAt}get resolved(){return this._resolved||this.hasAttemptedResolve||(Mt(),Et()),this._resolved}onKeyframesResolved(t,e){this.resolvedAt=le.now(),this.hasAttemptedResolve=!0;const{name:n,type:i,velocity:s,delay:o,onComplete:r,onUpdate:a,isGenerator:l}=this.options;if(!l&&!ce(t,n,i,s)){if(b.current||!o)return null==a||a(E(t,this.options,e)),null==r||r(),void this.resolveFinishedPromise();this.options.duration=0}const u=this.initPlayback(t,e);!1!==u&&(this._resolved={keyframes:t,finalKeyframe:e,...u},this.onPostResolved())}onPostResolved(){}then(t,e){return this.currentFinishedPromise.then(t,e)}flatten(){this.options.type="keyframes",this.options.ease="linear"}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}}const de=(t,e,n)=>{const i=e-t;return 0===i?1:(n-t)/i},pe=(t,e,n=10)=>{let i="";const s=Math.max(Math.round(e/n),2);for(let e=0;e<s;e++)i+=t(de(0,s-1,e))+", ";return`linear(${i.substring(0,i.length-2)})`};function me(t,e){return e?t*(1e3/e):0}function fe(t,e,n){const i=Math.max(e-5,0);return me(n-t(i),e-i)}const ge=100,ye=10,ve=1,xe=0,we=800,Pe=.3,Te=.3,Se={granular:.01,default:2},be={granular:.005,default:.5},Ae=.01,Ee=10,Me=.05,Ce=1;function Ve({duration:t=we,bounce:e=Pe,velocity:n=xe,mass:i=ve}){let s,o,r=1-e;r=nt(Me,Ce,r),t=nt(Ae,Ee,y(t)),r<1?(s=e=>{const i=e*r,s=i*t;return.001-(i-n)/Re(e,r)*Math.exp(-s)},o=e=>{const i=e*r*t,o=i*n+n,a=Math.pow(r,2)*Math.pow(e,2)*t,l=Math.exp(-i),u=Re(Math.pow(e,2),r);return(.001-s(e)>0?-1:1)*((o-a)*l)/u}):(s=e=>Math.exp(-e*t)*((e-n)*t+1)-.001,o=e=>Math.exp(-e*t)*(t*t*(n-e)));const a=function(t,e,n){let i=n;for(let n=1;n<12;n++)i-=t(i)/e(i);return i}(s,o,5/t);if(t=g(t),isNaN(a))return{stiffness:ge,damping:ye,duration:t};{const e=Math.pow(a,2)*i;return{stiffness:e,damping:2*r*Math.sqrt(i*e),duration:t}}}function Re(t,e){return t*Math.sqrt(1-e*e)}function De(t){let e=0;let n=t.next(e);for(;!n.done&&e<2e4;)e+=50,n=t.next(e);return e>=2e4?1/0:e}const ke=["duration","bounce"],Le=["stiffness","damping","mass"];function Be(t,e){return e.some(e=>void 0!==t[e])}function Fe(t=Te,e=Pe){const n="object"!=typeof t?{visualDuration:t,keyframes:[0,1],bounce:e}:t;let{restSpeed:i,restDelta:s}=n;const o=n.keyframes[0],r=n.keyframes[n.keyframes.length-1],a={done:!1,value:o},{stiffness:l,damping:u,mass:c,duration:h,velocity:d,isResolvedFromDuration:p}=function(t){let e={velocity:xe,stiffness:ge,damping:ye,mass:ve,isResolvedFromDuration:!1,...t};if(!Be(t,Le)&&Be(t,ke))if(t.visualDuration){const n=t.visualDuration,i=2*Math.PI/(1.2*n),s=i*i,o=2*nt(.05,1,1-t.bounce)*Math.sqrt(s);e={...e,mass:ve,stiffness:s,damping:o}}else{const n=Ve(t);e={...e,...n,mass:ve},e.isResolvedFromDuration=!0}return e}({...n,velocity:-y(n.velocity||0)}),m=d||0,f=u/(2*Math.sqrt(l*c)),v=r-o,x=y(Math.sqrt(l/c)),w=Math.abs(v)<5;let P;if(i||(i=w?Se.granular:Se.default),s||(s=w?be.granular:be.default),f<1){const t=Re(x,f);P=e=>{const n=Math.exp(-f*x*e);return r-n*((m+f*x*v)/t*Math.sin(t*e)+v*Math.cos(t*e))}}else if(1===f)P=t=>r-Math.exp(-x*t)*(v+(m+x*v)*t);else{const t=x*Math.sqrt(f*f-1);P=e=>{const n=Math.exp(-f*x*e),i=Math.min(t*e,300);return r-n*((m+f*x*v)*Math.sinh(i)+t*v*Math.cosh(i))/t}}const T={calculatedDuration:p&&h||null,next:t=>{const e=P(t);if(p)a.done=t>=h;else{let n=0;f<1&&(n=0===t?g(m):fe(P,t,e));const o=Math.abs(n)<=i,l=Math.abs(r-e)<=s;a.done=o&&l}return a.value=a.done?r:e,a},toString:()=>{const t=Math.min(De(T),2e4),e=pe(e=>T.next(t*e).value,t,30);return t+"ms "+e}};return T}function je({keyframes:t,velocity:e=0,power:n=.8,timeConstant:i=325,bounceDamping:s=10,bounceStiffness:o=500,modifyTarget:r,min:a,max:l,restDelta:u=.5,restSpeed:c}){const h=t[0],d={done:!1,value:h},p=t=>void 0===a?l:void 0===l||Math.abs(a-t)<Math.abs(l-t)?a:l;let m=n*e;const f=h+m,g=void 0===r?f:r(f);g!==f&&(m=g-h);const y=t=>-m*Math.exp(-t/i),v=t=>g+y(t),x=t=>{const e=y(t),n=v(t);d.done=Math.abs(e)<=u,d.value=d.done?g:n};let w,P;const T=t=>{var e;(e=d.value,void 0!==a&&e<a||void 0!==l&&e>l)&&(w=t,P=Fe({keyframes:[d.value,p(d.value)],velocity:fe(v,t,d.value),damping:s,stiffness:o,restDelta:u,restSpeed:c}))};return T(0),{calculatedDuration:null,next:t=>{let e=!1;return P||void 0!==w||(e=!0,x(t),T(t)),void 0!==w&&t>=w?P.next(t-w):(!e&&x(t),d)}}}const Oe=O(.42,0,1,1),Ie=O(0,0,.58,1),Ue=O(.42,0,.58,1),We=t=>Array.isArray(t)&&"number"!=typeof t[0],Ne=t=>Array.isArray(t)&&"number"==typeof t[0],ze={linear:M,easeIn:Oe,easeInOut:Ue,easeOut:Ie,circIn:H,circInOut:X,circOut:Y,backIn:N,backInOut:z,backOut:W,anticipate:$},$e=t=>{if(Ne(t)){V(4===t.length);const[e,n,i,s]=t;return O(e,n,i,s)}return"string"==typeof t?ze[t]:t},He=(t,e)=>n=>e(t(n)),Ye=(...t)=>t.reduce(He),Xe=(t,e,n)=>t+(e-t)*n;function Ke(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+(e-t)*(2/3-n)*6:t}function Ge(t,e){return n=>n>0?e:t}const _e=(t,e,n)=>{const i=t*t,s=n*(e*e-i)+i;return s<0?0:Math.sqrt(s)},qe=[jt,Ft,Ot];function Ze(t){const e=(n=t,qe.find(t=>t.test(n)));var n;if(!Boolean(e))return!1;let i=e.parse(t);return e===Ot&&(i=function({hue:t,saturation:e,lightness:n,alpha:i}){t/=360,n/=100;let s=0,o=0,r=0;if(e/=100){const i=n<.5?n*(1+e):n+e-n*e,a=2*n-i;s=Ke(a,i,t+1/3),o=Ke(a,i,t),r=Ke(a,i,t-1/3)}else s=o=r=n;return{red:Math.round(255*s),green:Math.round(255*o),blue:Math.round(255*r),alpha:i}}(i)),i}const Je=(t,e)=>{const n=Ze(t),i=Ze(e);if(!n||!i)return Ge(t,e);const s={...n};return t=>(s.red=_e(n.red,i.red,t),s.green=_e(n.green,i.green,t),s.blue=_e(n.blue,i.blue,t),s.alpha=Xe(n.alpha,i.alpha,t),Ft.transform(s))},Qe=new Set(["none","hidden"]);function tn(t,e){return n=>Xe(t,e,n)}function en(t){return"number"==typeof t?tn:"string"==typeof t?J(t)?Ge:It.test(t)?Je:on:Array.isArray(t)?nn:"object"==typeof t?It.test(t)?Je:sn:Ge}function nn(t,e){const n=[...t],i=n.length,s=t.map((t,n)=>en(t)(t,e[n]));return t=>{for(let e=0;e<i;e++)n[e]=s[e](t);return n}}function sn(t,e){const n={...t,...e},i={};for(const s in n)void 0!==t[s]&&void 0!==e[s]&&(i[s]=en(t[s])(t[s],e[s]));return t=>{for(const e in i)n[e]=i[e](t);return n}}const on=(t,e)=>{const n=Yt.createTransformer(e),i=Nt(t),s=Nt(e);return i.indexes.var.length===s.indexes.var.length&&i.indexes.color.length===s.indexes.color.length&&i.indexes.number.length>=s.indexes.number.length?Qe.has(t)&&!s.values.length||Qe.has(e)&&!i.values.length?function(t,e){return Qe.has(t)?n=>n<=0?t:e:n=>n>=1?e:t}(t,e):Ye(nn(function(t,e){var n;const i=[],s={color:0,var:0,number:0};for(let o=0;o<e.values.length;o++){const r=e.types[o],a=t.indexes[r][s[r]],l=null!==(n=t.values[a])&&void 0!==n?n:0;i[o]=l,s[r]++}return i}(i,s),s.values),n):Ge(t,e)};function rn(t,e,n){if("number"==typeof t&&"number"==typeof e&&"number"==typeof n)return Xe(t,e,n);return en(t)(t,e)}function an(t,e,{clamp:n=!0,ease:i,mixer:s}={}){const o=t.length;if(V(o===e.length),1===o)return()=>e[0];if(2===o&&t[0]===t[1])return()=>e[1];t[0]>t[o-1]&&(t=[...t].reverse(),e=[...e].reverse());const r=function(t,e,n){const i=[],s=n||rn,o=t.length-1;for(let n=0;n<o;n++){let o=s(t[n],t[n+1]);if(e){const t=Array.isArray(e)?e[n]||M:e;o=Ye(t,o)}i.push(o)}return i}(e,i,s),a=r.length,l=e=>{let n=0;if(a>1)for(;n<t.length-2&&!(e<t[n+1]);n++);const i=de(t[n],t[n+1],e);return r[n](i)};return n?e=>l(nt(t[0],t[o-1],e)):l}function ln(t,e){const n=t[t.length-1];for(let i=1;i<=e;i++){const s=de(0,e,i);t.push(Xe(n,1,s))}}function un(t){const e=[0];return ln(e,t.length-1),e}function cn({duration:t=300,keyframes:e,times:n,ease:i="easeInOut"}){const s=We(i)?i.map($e):$e(i),o={done:!1,value:e[0]},r=an(function(t,e){return t.map(t=>t*e)}(n&&n.length===e.length?n:un(e),t),e,{ease:Array.isArray(s)?s:(a=e,l=s,a.map(()=>l||Ue).splice(0,a.length-1))});var a,l;return{calculatedDuration:t,next:e=>(o.value=r(e),o.done=e>=t,o)}}const hn=t=>{const e=({timestamp:e})=>t(e);return{start:()=>k.update(e,!0),stop:()=>L(e),now:()=>B.isProcessing?B.timestamp:le.now()}},dn={decay:je,inertia:je,tween:cn,keyframes:cn,spring:Fe},pn=t=>t/100;class mn extends he{constructor(t){super(t),this.holdTime=null,this.cancelTime=null,this.currentTime=0,this.playbackSpeed=1,this.pendingPlayState="running",this.startTime=null,this.state="idle",this.stop=()=>{if(this.resolver.cancel(),this.isStopped=!0,"idle"===this.state)return;this.teardown();const{onStop:t}=this.options;t&&t()};const{name:e,motionValue:n,element:i,keyframes:s}=this.options,o=(null==i?void 0:i.KeyframeResolver)||Ct;this.resolver=new o(s,(t,e)=>this.onKeyframesResolved(t,e),e,n,i),this.resolver.scheduleResolve()}flatten(){super.flatten(),this._resolved&&Object.assign(this._resolved,this.initPlayback(this._resolved.keyframes))}initPlayback(t){const{type:e="keyframes",repeat:n=0,repeatDelay:i=0,repeatType:s,velocity:o=0}=this.options,r=oe(e)?e:dn[e]||cn;let a,l;r!==cn&&"number"!=typeof t[0]&&(a=Ye(pn,rn(t[0],t[1])),t=[0,100]);const u=r({...this.options,keyframes:t});"mirror"===s&&(l=r({...this.options,keyframes:[...t].reverse(),velocity:-o})),null===u.calculatedDuration&&(u.calculatedDuration=De(u));const{calculatedDuration:c}=u,h=c+i;return{generator:u,mirroredGenerator:l,mapPercentToKeyframes:a,calculatedDuration:c,resolvedDuration:h,totalDuration:h*(n+1)-i}}onPostResolved(){const{autoplay:t=!0}=this.options;this.play(),"paused"!==this.pendingPlayState&&t?this.state=this.pendingPlayState:this.pause()}tick(t,e=!1){const{resolved:n}=this;if(!n){const{keyframes:t}=this.options;return{done:!0,value:t[t.length-1]}}const{finalKeyframe:i,generator:s,mirroredGenerator:o,mapPercentToKeyframes:r,keyframes:a,calculatedDuration:l,totalDuration:u,resolvedDuration:c}=n;if(null===this.startTime)return s.next(0);const{delay:h,repeat:d,repeatType:p,repeatDelay:m,onUpdate:f}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,t):this.speed<0&&(this.startTime=Math.min(t-u/this.speed,this.startTime)),e?this.currentTime=t:null!==this.holdTime?this.currentTime=this.holdTime:this.currentTime=Math.round(t-this.startTime)*this.speed;const g=this.currentTime-h*(this.speed>=0?1:-1),y=this.speed>=0?g<0:g>u;this.currentTime=Math.max(g,0),"finished"===this.state&&null===this.holdTime&&(this.currentTime=u);let v=this.currentTime,x=s;if(d){const t=Math.min(this.currentTime,u)/c;let e=Math.floor(t),n=t%1;!n&&t>=1&&(n=1),1===n&&e--,e=Math.min(e,d+1);Boolean(e%2)&&("reverse"===p?(n=1-n,m&&(n-=m/c)):"mirror"===p&&(x=o)),v=nt(0,1,n)*c}const w=y?{done:!1,value:a[0]}:x.next(v);r&&(w.value=r(w.value));let{done:P}=w;y||null===l||(P=this.speed>=0?this.currentTime>=u:this.currentTime<=0);const T=null===this.holdTime&&("finished"===this.state||"running"===this.state&&P);return T&&void 0!==i&&(w.value=E(a,this.options,i)),f&&f(w.value),T&&this.finish(),w}get duration(){const{resolved:t}=this;return t?y(t.calculatedDuration):0}get time(){return y(this.currentTime)}set time(t){t=g(t),this.currentTime=t,null!==this.holdTime||0===this.speed?this.holdTime=t:this.driver&&(this.startTime=this.driver.now()-t/this.speed)}get speed(){return this.playbackSpeed}set speed(t){const e=this.playbackSpeed!==t;this.playbackSpeed=t,e&&(this.time=y(this.currentTime))}play(){if(this.resolver.isScheduled||this.resolver.resume(),!this._resolved)return void(this.pendingPlayState="running");if(this.isStopped)return;const{driver:t=hn,onPlay:e,startTime:n}=this.options;this.driver||(this.driver=t(t=>this.tick(t))),e&&e();const i=this.driver.now();null!==this.holdTime?this.startTime=i-this.holdTime:this.startTime?"finished"===this.state&&(this.startTime=i):this.startTime=null!=n?n:this.calcStartTime(),"finished"===this.state&&this.updateFinishedPromise(),this.cancelTime=this.startTime,this.holdTime=null,this.state="running",this.driver.start()}pause(){var t;this._resolved?(this.state="paused",this.holdTime=null!==(t=this.currentTime)&&void 0!==t?t:0):this.pendingPlayState="paused"}complete(){"running"!==this.state&&this.play(),this.pendingPlayState=this.state="finished",this.holdTime=null}finish(){this.teardown(),this.state="finished";const{onComplete:t}=this.options;t&&t()}cancel(){null!==this.cancelTime&&this.tick(this.cancelTime),this.teardown(),this.updateFinishedPromise()}teardown(){this.state="idle",this.stopDriver(),this.resolveFinishedPromise(),this.updateFinishedPromise(),this.startTime=this.cancelTime=null,this.resolver.cancel()}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(t){return this.startTime=0,this.tick(t,!0)}}function fn(t){return new mn(t)}const gn=new Set(["opacity","clipPath","filter","transform"]);function yn(t){let e;return()=>(void 0===e&&(e=t()),e)}const vn={linearEasing:void 0};function xn(t,e){const n=yn(t);return()=>{var t;return null!==(t=vn[e])&&void 0!==t?t:n()}}const wn=xn(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch(t){return!1}return!0},"linearEasing");function Pn(t){return Boolean("function"==typeof t&&wn()||!t||"string"==typeof t&&(t in Sn||wn())||Ne(t)||Array.isArray(t)&&t.every(Pn))}const Tn=([t,e,n,i])=>`cubic-bezier(${t}, ${e}, ${n}, ${i})`,Sn={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:Tn([0,.65,.55,1]),circOut:Tn([.55,0,1,.45]),backIn:Tn([.31,.01,.66,-.59]),backOut:Tn([.33,1.53,.69,.99])};function bn(t,e,n,{delay:i=0,duration:s=300,repeat:o=0,repeatType:r="loop",ease:a="easeInOut",times:l}={}){const u={[e]:n};l&&(u.offset=l);const c=function t(e,n){return e?"function"==typeof e&&wn()?pe(e,n):Ne(e)?Tn(e):Array.isArray(e)?e.map(e=>t(e,n)||Sn.easeOut):Sn[e]:void 0}(a,s);return Array.isArray(c)&&(u.easing=c),t.animate(u,{delay:i,duration:s,easing:Array.isArray(c)?"linear":c,fill:"both",iterations:o+1,direction:"reverse"===r?"alternate":"normal"})}function An(t,e){t.timeline=e,t.onfinish=null}const En=yn(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));const Mn={anticipate:$,backInOut:z,circInOut:X};class Cn extends he{constructor(t){super(t);const{name:e,motionValue:n,element:i,keyframes:s}=this.options;this.resolver=new se(s,(t,e)=>this.onKeyframesResolved(t,e),e,n,i),this.resolver.scheduleResolve()}initPlayback(t,e){var n;let{duration:i=300,times:s,ease:o,type:r,motionValue:a,name:l,startTime:u}=this.options;if(!(null===(n=a.owner)||void 0===n?void 0:n.current))return!1;var c;if("string"==typeof o&&wn()&&o in Mn&&(o=Mn[o]),oe((c=this.options).type)||"spring"===c.type||!Pn(c.ease)){const{onComplete:e,onUpdate:n,motionValue:a,element:l,...u}=this.options,c=function(t,e){const n=new mn({...e,keyframes:t,repeat:0,delay:0,isGenerator:!0});let i={done:!1,value:t[0]};const s=[];let o=0;for(;!i.done&&o<2e4;)i=n.sample(o),s.push(i.value),o+=10;return{times:void 0,keyframes:s,duration:o-10,ease:"linear"}}(t,u);1===(t=c.keyframes).length&&(t[1]=t[0]),i=c.duration,s=c.times,o=c.ease,r="keyframes"}const h=bn(a.owner.current,l,t,{...this.options,duration:i,times:s,ease:o});return h.startTime=null!=u?u:this.calcStartTime(),this.pendingTimeline?(An(h,this.pendingTimeline),this.pendingTimeline=void 0):h.onfinish=()=>{const{onComplete:n}=this.options;a.set(E(t,this.options,e)),n&&n(),this.cancel(),this.resolveFinishedPromise()},{animation:h,duration:i,times:s,type:r,ease:o,keyframes:t}}get duration(){const{resolved:t}=this;if(!t)return 0;const{duration:e}=t;return y(e)}get time(){const{resolved:t}=this;if(!t)return 0;const{animation:e}=t;return y(e.currentTime||0)}set time(t){const{resolved:e}=this;if(!e)return;const{animation:n}=e;n.currentTime=g(t)}get speed(){const{resolved:t}=this;if(!t)return 1;const{animation:e}=t;return e.playbackRate}set speed(t){const{resolved:e}=this;if(!e)return;const{animation:n}=e;n.playbackRate=t}get state(){const{resolved:t}=this;if(!t)return"idle";const{animation:e}=t;return e.playState}get startTime(){const{resolved:t}=this;if(!t)return null;const{animation:e}=t;return e.startTime}attachTimeline(t){if(this._resolved){const{resolved:e}=this;if(!e)return M;const{animation:n}=e;An(n,t)}else this.pendingTimeline=t;return M}play(){if(this.isStopped)return;const{resolved:t}=this;if(!t)return;const{animation:e}=t;"finished"===e.playState&&this.updateFinishedPromise(),e.play()}pause(){const{resolved:t}=this;if(!t)return;const{animation:e}=t;e.pause()}stop(){if(this.resolver.cancel(),this.isStopped=!0,"idle"===this.state)return;this.resolveFinishedPromise(),this.updateFinishedPromise();const{resolved:t}=this;if(!t)return;const{animation:e,keyframes:n,duration:i,type:s,ease:o,times:r}=t;if("idle"===e.playState||"finished"===e.playState)return;if(this.time){const{motionValue:t,onUpdate:e,onComplete:a,element:l,...u}=this.options,c=new mn({...u,keyframes:n,duration:i,type:s,ease:o,times:r,isGenerator:!0}),h=g(this.time);t.setWithVelocity(c.sample(h-10).value,c.sample(h).value,10)}const{onStop:a}=this.options;a&&a(),this.cancel()}complete(){const{resolved:t}=this;t&&t.animation.finish()}cancel(){const{resolved:t}=this;t&&t.animation.cancel()}static supports(t){const{motionValue:e,name:n,repeatDelay:i,repeatType:s,damping:o,type:r}=t;return En()&&n&&gn.has(n)&&e&&e.owner&&e.owner.current instanceof HTMLElement&&!e.owner.getProps().onUpdate&&!i&&"mirror"!==s&&0!==o&&"inertia"!==r}}const Vn=yn(()=>void 0!==window.ScrollTimeline);class Rn{constructor(t){this.stop=()=>this.runAll("stop"),this.animations=t.filter(Boolean)}then(t,e){return Promise.all(this.animations).then(t).catch(e)}getAll(t){return this.animations[0][t]}setAll(t,e){for(let n=0;n<this.animations.length;n++)this.animations[n][t]=e}attachTimeline(t,e){const n=this.animations.map(n=>Vn()&&n.attachTimeline?n.attachTimeline(t):e(n));return()=>{n.forEach((t,e)=>{t&&t(),this.animations[e].stop()})}}get time(){return this.getAll("time")}set time(t){this.setAll("time",t)}get speed(){return this.getAll("speed")}set speed(t){this.setAll("speed",t)}get startTime(){return this.getAll("startTime")}get duration(){let t=0;for(let e=0;e<this.animations.length;e++)t=Math.max(t,this.animations[e].duration);return t}runAll(t){this.animations.forEach(e=>e[t]())}flatten(){this.runAll("flatten")}play(){this.runAll("play")}pause(){this.runAll("pause")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}const Dn=(t,e,n,i={},s,o)=>r=>{const a=T(i,t)||{},l=a.delay||i.delay||0;let{elapsed:u=0}=i;u-=g(l);let c={keyframes:Array.isArray(n)?n:[null,n],ease:"easeOut",velocity:e.getVelocity(),...a,delay:-u,onUpdate:t=>{e.set(t),a.onUpdate&&a.onUpdate(t)},onComplete:()=>{r(),a.onComplete&&a.onComplete()},name:t,motionValue:e,element:o?void 0:s};(function({when:t,delay:e,delayChildren:n,staggerChildren:i,staggerDirection:s,repeat:o,repeatType:r,repeatDelay:a,from:l,elapsed:u,...c}){return!!Object.keys(c).length})(a)||(c={...c,...P(t,c)}),c.duration&&(c.duration=g(c.duration)),c.repeatDelay&&(c.repeatDelay=g(c.repeatDelay)),void 0!==c.from&&(c.keyframes[0]=c.from);let h=!1;if((!1===c.type||0===c.duration&&!c.repeatDelay)&&(c.duration=0,0===c.delay&&(h=!0)),(b.current||S.skipAnimations)&&(h=!0,c.duration=0,c.delay=0),h&&!o&&void 0!==e.get()){const t=E(c.keyframes,a);if(void 0!==t)return k.update(()=>{c.onUpdate(t),c.onComplete()}),new Rn([])}return!o&&Cn.supports(c)?new Cn(c):new mn(c)};function kn(t,e){-1===t.indexOf(e)&&t.push(e)}function Ln(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class Bn{constructor(){this.subscriptions=[]}add(t){return kn(this.subscriptions,t),()=>Ln(this.subscriptions,t)}notify(t,e,n){const i=this.subscriptions.length;if(i)if(1===i)this.subscriptions[0](t,e,n);else for(let s=0;s<i;s++){const i=this.subscriptions[s];i&&i(t,e,n)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const Fn={current:void 0};class jn{constructor(t,e={}){this.version="11.15.0",this.canTrackVelocity=null,this.events={},this.updateAndNotify=(t,e=!0)=>{const n=le.now();this.updatedAt!==n&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(t),this.current!==this.prev&&this.events.change&&this.events.change.notify(this.current),e&&this.events.renderRequest&&this.events.renderRequest.notify(this.current)},this.hasAnimated=!1,this.setCurrent(t),this.owner=e.owner}setCurrent(t){var e;this.current=t,this.updatedAt=le.now(),null===this.canTrackVelocity&&void 0!==t&&(this.canTrackVelocity=(e=this.current,!isNaN(parseFloat(e))))}setPrevFrameValue(t=this.current){this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt}onChange(t){return this.on("change",t)}on(t,e){this.events[t]||(this.events[t]=new Bn);const n=this.events[t].add(e);return"change"===t?()=>{n(),k.read(()=>{this.events.change.getSize()||this.stop()})}:n}clearListeners(){for(const t in this.events)this.events[t].clear()}attach(t,e){this.passiveEffect=t,this.stopPassiveEffect=e}set(t,e=!0){e&&this.passiveEffect?this.passiveEffect(t,this.updateAndNotify):this.updateAndNotify(t,e)}setWithVelocity(t,e,n){this.set(e),this.prev=void 0,this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt-n}jump(t,e=!0){this.updateAndNotify(t),this.prev=t,this.prevUpdatedAt=this.prevFrameValue=void 0,e&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return Fn.current&&Fn.current.push(this),this.current}getPrevious(){return this.prev}getVelocity(){const t=le.now();if(!this.canTrackVelocity||void 0===this.prevFrameValue||t-this.updatedAt>30)return 0;const e=Math.min(this.updatedAt-this.prevUpdatedAt,30);return me(parseFloat(this.current)-parseFloat(this.prevFrameValue),e)}start(t){return this.stop(),new Promise(e=>{this.hasAnimated=!0,this.animation=t(e),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function On(t,e){return new jn(t,e)}function In(t,e,n){t.hasValue(e)?t.getValue(e).set(n):t.addValue(e,On(n))}function Un(t,e){const n=h(t,e);let{transitionEnd:i={},transition:s={},...o}=n||{};o={...o,...i};for(const e in o){In(t,e,(a=o[e],r(a)?a[a.length-1]||0:a))}var a}const Wn=t=>t.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),Nn="data-"+Wn("framerAppearId");function zn(t){return t.props[Nn]}const $n=t=>Boolean(t&&t.getVelocity);function Hn(t,e){const n=t.getValue("willChange");if(i=n,Boolean($n(i)&&i.add))return n.add(e);var i}function Yn({protectedKeys:t,needsAnimating:e},n){const i=t.hasOwnProperty(n)&&!0!==e[n];return e[n]=!1,i}function Xn(t,e,{delay:n=0,transitionOverride:i,type:s}={}){var o;let{transition:r=t.getDefaultTransition(),transitionEnd:a,...l}=e;i&&(r=i);const u=[],c=s&&t.animationState&&t.animationState.getState()[s];for(const e in l){const i=t.getValue(e,null!==(o=t.latestValues[e])&&void 0!==o?o:null),s=l[e];if(void 0===s||c&&Yn(c,e))continue;const a={delay:n,...T(r||{},e)};let h=!1;if(window.MotionHandoffAnimation){const n=zn(t);if(n){const t=window.MotionHandoffAnimation(n,e,k);null!==t&&(a.startTime=t,h=!0)}}Hn(t,e),i.start(Dn(e,i,s,t.shouldReduceMotion&&f.has(e)?{type:!1}:a,t,h));const d=i.animation;d&&u.push(d)}return a&&Promise.all(u).then(()=>{k.update(()=>{a&&Un(t,a)})}),u}function Kn(t,e,n={}){var i;const s=h(t,e,"exit"===n.type?null===(i=t.presenceContext)||void 0===i?void 0:i.custom:void 0);let{transition:o=t.getDefaultTransition()||{}}=s||{};n.transitionOverride&&(o=n.transitionOverride);const r=s?()=>Promise.all(Xn(t,s,n)):()=>Promise.resolve(),a=t.variantChildren&&t.variantChildren.size?(i=0)=>{const{delayChildren:s=0,staggerChildren:r,staggerDirection:a}=o;return function(t,e,n=0,i=0,s=1,o){const r=[],a=(t.variantChildren.size-1)*i,l=1===s?(t=0)=>t*i:(t=0)=>a-t*i;return Array.from(t.variantChildren).sort(Gn).forEach((t,i)=>{t.notify("AnimationStart",e),r.push(Kn(t,e,{...o,delay:n+l(i)}).then(()=>t.notify("AnimationComplete",e)))}),Promise.all(r)}(t,e,s+i,r,a,n)}:()=>Promise.resolve(),{when:l}=o;if(l){const[t,e]="beforeChildren"===l?[r,a]:[a,r];return t().then(()=>e())}return Promise.all([r(),a(n.delay)])}function Gn(t,e){return t.sortNodePosition(e)}function _n(t,e,n={}){let i;if(t.notify("AnimationStart",e),Array.isArray(e)){const s=e.map(e=>Kn(t,e,n));i=Promise.all(s)}else if("string"==typeof e)i=Kn(t,e,n);else{const s="function"==typeof e?h(t,e,n.custom):e;i=Promise.all(Xn(t,s,n))}return i.then(()=>{t.notify("AnimationComplete",e)})}const qn=p.length;const Zn=[...d].reverse(),Jn=d.length;function Qn(t){let e=function(t){return e=>Promise.all(e.map(({animation:e,options:n})=>_n(t,e,n)))}(t),n=ni(),i=!0;const s=e=>(n,i)=>{var s;const o=h(t,i,"exit"===e?null===(s=t.presenceContext)||void 0===s?void 0:s.custom:void 0);if(o){const{transition:t,transitionEnd:e,...i}=o;n={...n,...i,...e}}return n};function u(u){const{props:c}=t,h=function t(e){if(!e)return;if(!e.isControllingVariants){const n=e.parent&&t(e.parent)||{};return void 0!==e.props.initial&&(n.initial=e.props.initial),n}const n={};for(let t=0;t<qn;t++){const i=p[t],s=e.props[i];(l(s)||!1===s)&&(n[i]=s)}return n}(t.parent)||{},d=[],m=new Set;let f={},g=1/0;for(let e=0;e<Jn;e++){const p=Zn[e],y=n[p],v=void 0!==c[p]?c[p]:h[p],x=l(v),w=p===u?y.isActive:null;!1===w&&(g=e);let P=v===h[p]&&v!==c[p]&&x;if(P&&i&&t.manuallyAnimateOnMount&&(P=!1),y.protectedKeys={...f},!y.isActive&&null===w||!v&&!y.prevProp||o(v)||"boolean"==typeof v)continue;const T=ti(y.prevProp,v);let S=T||p===u&&y.isActive&&!P&&x||e>g&&x,b=!1;const A=Array.isArray(v)?v:[v];let E=A.reduce(s(p),{});!1===w&&(E={});const{prevResolvedValues:M={}}=y,C={...M,...E},V=e=>{S=!0,m.has(e)&&(b=!0,m.delete(e)),y.needsAnimating[e]=!0;const n=t.getValue(e);n&&(n.liveStyle=!1)};for(const t in C){const e=E[t],n=M[t];if(f.hasOwnProperty(t))continue;let i=!1;i=r(e)&&r(n)?!a(e,n):e!==n,i?null!=e?V(t):m.add(t):void 0!==e&&m.has(t)?V(t):y.protectedKeys[t]=!0}y.prevProp=v,y.prevResolvedValues=E,y.isActive&&(f={...f,...E}),i&&t.blockInitialAnimation&&(S=!1);const R=!(P&&T)||b;S&&R&&d.push(...A.map(t=>({animation:t,options:{type:p}})))}if(m.size){const e={};m.forEach(n=>{const i=t.getBaseTarget(n),s=t.getValue(n);s&&(s.liveStyle=!0),e[n]=null!=i?i:null}),d.push({animation:e})}let y=Boolean(d.length);return!i||!1!==c.initial&&c.initial!==c.animate||t.manuallyAnimateOnMount||(y=!1),i=!1,y?e(d):Promise.resolve()}return{animateChanges:u,setActive:function(e,i){var s;if(n[e].isActive===i)return Promise.resolve();null===(s=t.variantChildren)||void 0===s||s.forEach(t=>{var n;return null===(n=t.animationState)||void 0===n?void 0:n.setActive(e,i)}),n[e].isActive=i;const o=u(e);for(const t in n)n[t].protectedKeys={};return o},setAnimateFunction:function(n){e=n(t)},getState:()=>n,reset:()=>{n=ni(),i=!0}}}function ti(t,e){return"string"==typeof e?e!==t:!!Array.isArray(e)&&!a(e,t)}function ei(t=!1){return{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function ni(){return{animate:ei(!0),whileInView:ei(),whileHover:ei(),whileTap:ei(),whileDrag:ei(),whileFocus:ei(),exit:ei()}}class ii{constructor(t){this.isMounted=!1,this.node=t}update(){}}let si=0;const oi={animation:{Feature:class extends ii{constructor(t){super(t),t.animationState||(t.animationState=Qn(t))}updateAnimationControlsSubscription(){const{animate:t}=this.node.getProps();o(t)&&(this.unmountControls=t.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:t}=this.node.getProps(),{animate:e}=this.node.prevProps||{};t!==e&&this.updateAnimationControlsSubscription()}unmount(){var t;this.node.animationState.reset(),null===(t=this.unmountControls)||void 0===t||t.call(this)}}},exit:{Feature:class extends ii{constructor(){super(...arguments),this.id=si++}update(){if(!this.node.presenceContext)return;const{isPresent:t,onExitComplete:e}=this.node.presenceContext,{isPresent:n}=this.node.prevPresenceContext||{};if(!this.node.animationState||t===n)return;const i=this.node.animationState.setActive("exit",!t);e&&!t&&i.then(()=>e(this.id))}mount(){const{register:t}=this.node.presenceContext||{};t&&(this.unmount=t(this.id))}unmount(){}}}},ri={x:!1,y:!1};function ai(){return ri.x||ri.y}function li(t,e,n){var i;if(t instanceof Element)return[t];if("string"==typeof t){let s=document;e&&(s=e.current);const o=null!==(i=null==n?void 0:n[t])&&void 0!==i?i:s.querySelectorAll(t);return o?Array.from(o):[]}return Array.from(t)}function ui(t,e){const n=li(t),i=new AbortController;return[n,{passive:!0,...e,signal:i.signal},()=>i.abort()]}function ci(t){return e=>{"touch"===e.pointerType||ai()||t(e)}}const hi=t=>"mouse"===t.pointerType?"number"!=typeof t.button||t.button<=0:!1!==t.isPrimary,di=new WeakSet;function pi(t){return e=>{"Enter"===e.key&&t(e)}}function mi(t,e){t.dispatchEvent(new PointerEvent("pointer"+e,{isPrimary:!0,bubbles:!0}))}const fi=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);const gi=(t,e)=>!!e&&(t===e||gi(t,e.parentElement));function yi(t){return hi(t)&&!ai()}function vi(t,e,n={}){const[i,s,o]=ui(t,n),r=t=>{const i=t.currentTarget;if(!yi(t)||di.has(i))return;di.add(i);const o=e(t),r=(t,e)=>{window.removeEventListener("pointerup",a),window.removeEventListener("pointercancel",l),yi(t)&&di.has(i)&&(di.delete(i),o&&o(t,{success:e}))},a=t=>{r(t,n.useGlobalTarget||gi(i,t.target))},l=t=>{r(t,!1)};window.addEventListener("pointerup",a,s),window.addEventListener("pointercancel",l,s)};return i.forEach(t=>{(function(t){return fi.has(t.tagName)||-1!==t.tabIndex})(t)||(t.tabIndex=0);(n.useGlobalTarget?window:t).addEventListener("pointerdown",r,s),t.addEventListener("focus",t=>((t,e)=>{const n=t.currentTarget;if(!n)return;const i=pi(()=>{if(di.has(n))return;mi(n,"down");const t=pi(()=>{mi(n,"up")});n.addEventListener("keyup",t,e),n.addEventListener("blur",()=>mi(n,"cancel"),e)});n.addEventListener("keydown",i,e),n.addEventListener("blur",()=>n.removeEventListener("keydown",i),e)})(t,s),s)}),o}function xi(t){return{point:{x:t.pageX,y:t.pageY}}}const wi=t=>e=>hi(e)&&t(e,xi(e));function Pi(t,e,n,i={passive:!0}){return t.addEventListener(e,n,i),()=>t.removeEventListener(e,n)}function Ti(t,e,n,i){return Pi(t,e,wi(n),i)}const Si=(t,e)=>Math.abs(t-e);function bi(t,e){const n=Si(t.x,e.x),i=Si(t.y,e.y);return Math.sqrt(n**2+i**2)}class Ai{constructor(t,e,{transformPagePoint:n,contextWindow:i,dragSnapToOrigin:s=!1}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!this.lastMoveEvent||!this.lastMoveEventInfo)return;const t=Ci(this.lastMoveEventInfo,this.history),e=null!==this.startEvent,n=bi(t.offset,{x:0,y:0})>=3;if(!e&&!n)return;const{point:i}=t,{timestamp:s}=B;this.history.push({...i,timestamp:s});const{onStart:o,onMove:r}=this.handlers;e||(o&&o(this.lastMoveEvent,t),this.startEvent=this.lastMoveEvent),r&&r(this.lastMoveEvent,t)},this.handlePointerMove=(t,e)=>{this.lastMoveEvent=t,this.lastMoveEventInfo=Ei(e,this.transformPagePoint),k.update(this.updatePoint,!0)},this.handlePointerUp=(t,e)=>{this.end();const{onEnd:n,onSessionEnd:i,resumeAnimation:s}=this.handlers;if(this.dragSnapToOrigin&&s&&s(),!this.lastMoveEvent||!this.lastMoveEventInfo)return;const o=Ci("pointercancel"===t.type?this.lastMoveEventInfo:Ei(e,this.transformPagePoint),this.history);this.startEvent&&n&&n(t,o),i&&i(t,o)},!hi(t))return;this.dragSnapToOrigin=s,this.handlers=e,this.transformPagePoint=n,this.contextWindow=i||window;const o=Ei(xi(t),this.transformPagePoint),{point:r}=o,{timestamp:a}=B;this.history=[{...r,timestamp:a}];const{onSessionStart:l}=e;l&&l(t,Ci(o,this.history)),this.removeListeners=Ye(Ti(this.contextWindow,"pointermove",this.handlePointerMove),Ti(this.contextWindow,"pointerup",this.handlePointerUp),Ti(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(t){this.handlers=t}end(){this.removeListeners&&this.removeListeners(),L(this.updatePoint)}}function Ei(t,e){return e?{point:e(t.point)}:t}function Mi(t,e){return{x:t.x-e.x,y:t.y-e.y}}function Ci({point:t},e){return{point:t,delta:Mi(t,Ri(e)),offset:Mi(t,Vi(e)),velocity:Di(e,.1)}}function Vi(t){return t[0]}function Ri(t){return t[t.length-1]}function Di(t,e){if(t.length<2)return{x:0,y:0};let n=t.length-1,i=null;const s=Ri(t);for(;n>=0&&(i=t[n],!(s.timestamp-i.timestamp>g(e)));)n--;if(!i)return{x:0,y:0};const o=y(s.timestamp-i.timestamp);if(0===o)return{x:0,y:0};const r={x:(s.x-i.x)/o,y:(s.y-i.y)/o};return r.x===1/0&&(r.x=0),r.y===1/0&&(r.y=0),r}function ki(t){return t&&"object"==typeof t&&Object.prototype.hasOwnProperty.call(t,"current")}function Li(t){return t.max-t.min}function Bi(t,e,n,i=.5){t.origin=i,t.originPoint=Xe(e.min,e.max,t.origin),t.scale=Li(n)/Li(e),t.translate=Xe(n.min,n.max,t.origin)-t.originPoint,(t.scale>=.9999&&t.scale<=1.0001||isNaN(t.scale))&&(t.scale=1),(t.translate>=-.01&&t.translate<=.01||isNaN(t.translate))&&(t.translate=0)}function Fi(t,e,n,i){Bi(t.x,e.x,n.x,i?i.originX:void 0),Bi(t.y,e.y,n.y,i?i.originY:void 0)}function ji(t,e,n){t.min=n.min+e.min,t.max=t.min+Li(e)}function Oi(t,e,n){t.min=e.min-n.min,t.max=t.min+Li(e)}function Ii(t,e,n){Oi(t.x,e.x,n.x),Oi(t.y,e.y,n.y)}function Ui(t,e,n){return{min:void 0!==e?t.min+e:void 0,max:void 0!==n?t.max+n-(t.max-t.min):void 0}}function Wi(t,e){let n=e.min-t.min,i=e.max-t.max;return e.max-e.min<t.max-t.min&&([n,i]=[i,n]),{min:n,max:i}}const Ni=.35;function zi(t,e,n){return{min:$i(t,e),max:$i(t,n)}}function $i(t,e){return"number"==typeof t?t:t[e]||0}const Hi=()=>({x:{min:0,max:0},y:{min:0,max:0}});function Yi(t){return[t("x"),t("y")]}function Xi({top:t,left:e,right:n,bottom:i}){return{x:{min:e,max:n},y:{min:t,max:i}}}function Ki(t){return void 0===t||1===t}function Gi({scale:t,scaleX:e,scaleY:n}){return!Ki(t)||!Ki(e)||!Ki(n)}function _i(t){return Gi(t)||qi(t)||t.z||t.rotate||t.rotateX||t.rotateY||t.skewX||t.skewY}function qi(t){return Zi(t.x)||Zi(t.y)}function Zi(t){return t&&"0%"!==t}function Ji(t,e,n){return n+e*(t-n)}function Qi(t,e,n,i,s){return void 0!==s&&(t=Ji(t,s,i)),Ji(t,n,i)+e}function ts(t,e=0,n=1,i,s){t.min=Qi(t.min,e,n,i,s),t.max=Qi(t.max,e,n,i,s)}function es(t,{x:e,y:n}){ts(t.x,e.translate,e.scale,e.originPoint),ts(t.y,n.translate,n.scale,n.originPoint)}function ns(t,e){t.min=t.min+e,t.max=t.max+e}function is(t,e,n,i,s=.5){ts(t,e,n,Xe(t.min,t.max,s),i)}function ss(t,e){is(t.x,e.x,e.scaleX,e.scale,e.originX),is(t.y,e.y,e.scaleY,e.scale,e.originY)}function os(t,e){return Xi(function(t,e){if(!e)return t;const n=e({x:t.left,y:t.top}),i=e({x:t.right,y:t.bottom});return{top:n.y,left:n.x,bottom:i.y,right:i.x}}(t.getBoundingClientRect(),e))}const rs=({current:t})=>t?t.ownerDocument.defaultView:null,as=new WeakMap;class ls{constructor(t){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic={x:{min:0,max:0},y:{min:0,max:0}},this.visualElement=t}start(t,{snapToCursor:e=!1}={}){const{presenceContext:n}=this.visualElement;if(n&&!1===n.isPresent)return;const{dragSnapToOrigin:i}=this.getProps();this.panSession=new Ai(t,{onSessionStart:t=>{const{dragSnapToOrigin:n}=this.getProps();n?this.pauseAnimation():this.stopAnimation(),e&&this.snapToCursor(xi(t).point)},onStart:(t,e)=>{const{drag:n,dragPropagation:i,onDragStart:s}=this.getProps();if(n&&!i&&(this.openDragLock&&this.openDragLock(),this.openDragLock="x"===(o=n)||"y"===o?ri[o]?null:(ri[o]=!0,()=>{ri[o]=!1}):ri.x||ri.y?null:(ri.x=ri.y=!0,()=>{ri.x=ri.y=!1}),!this.openDragLock))return;var o;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),Yi(t=>{let e=this.getAxisMotionValue(t).get()||0;if(lt.test(e)){const{projection:n}=this.visualElement;if(n&&n.layout){const i=n.layout.layoutBox[t];if(i){e=Li(i)*(parseFloat(e)/100)}}}this.originPoint[t]=e}),s&&k.postRender(()=>s(t,e)),Hn(this.visualElement,"transform");const{animationState:r}=this.visualElement;r&&r.setActive("whileDrag",!0)},onMove:(t,e)=>{const{dragPropagation:n,dragDirectionLock:i,onDirectionLock:s,onDrag:o}=this.getProps();if(!n&&!this.openDragLock)return;const{offset:r}=e;if(i&&null===this.currentDirection)return this.currentDirection=function(t,e=10){let n=null;Math.abs(t.y)>e?n="y":Math.abs(t.x)>e&&(n="x");return n}(r),void(null!==this.currentDirection&&s&&s(this.currentDirection));this.updateAxis("x",e.point,r),this.updateAxis("y",e.point,r),this.visualElement.render(),o&&o(t,e)},onSessionEnd:(t,e)=>this.stop(t,e),resumeAnimation:()=>Yi(t=>{var e;return"paused"===this.getAnimationState(t)&&(null===(e=this.getAxisMotionValue(t).animation)||void 0===e?void 0:e.play())})},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:i,contextWindow:rs(this.visualElement)})}stop(t,e){const n=this.isDragging;if(this.cancel(),!n)return;const{velocity:i}=e;this.startAnimation(i);const{onDragEnd:s}=this.getProps();s&&k.postRender(()=>s(t,e))}cancel(){this.isDragging=!1;const{projection:t,animationState:e}=this.visualElement;t&&(t.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:n}=this.getProps();!n&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),e&&e.setActive("whileDrag",!1)}updateAxis(t,e,n){const{drag:i}=this.getProps();if(!n||!us(t,i,this.currentDirection))return;const s=this.getAxisMotionValue(t);let o=this.originPoint[t]+n[t];this.constraints&&this.constraints[t]&&(o=function(t,{min:e,max:n},i){return void 0!==e&&t<e?t=i?Xe(e,t,i.min):Math.max(t,e):void 0!==n&&t>n&&(t=i?Xe(n,t,i.max):Math.min(t,n)),t}(o,this.constraints[t],this.elastic[t])),s.set(o)}resolveConstraints(){var t;const{dragConstraints:e,dragElastic:n}=this.getProps(),i=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):null===(t=this.visualElement.projection)||void 0===t?void 0:t.layout,s=this.constraints;e&&ki(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):this.constraints=!(!e||!i)&&function(t,{top:e,left:n,bottom:i,right:s}){return{x:Ui(t.x,n,s),y:Ui(t.y,e,i)}}(i.layoutBox,e),this.elastic=function(t=Ni){return!1===t?t=0:!0===t&&(t=Ni),{x:zi(t,"left","right"),y:zi(t,"top","bottom")}}(n),s!==this.constraints&&i&&this.constraints&&!this.hasMutatedConstraints&&Yi(t=>{!1!==this.constraints&&this.getAxisMotionValue(t)&&(this.constraints[t]=function(t,e){const n={};return void 0!==e.min&&(n.min=e.min-t.min),void 0!==e.max&&(n.max=e.max-t.min),n}(i.layoutBox[t],this.constraints[t]))})}resolveRefConstraints(){const{dragConstraints:t,onMeasureDragConstraints:e}=this.getProps();if(!t||!ki(t))return!1;const n=t.current,{projection:i}=this.visualElement;if(!i||!i.layout)return!1;const s=function(t,e,n){const i=os(t,n),{scroll:s}=e;return s&&(ns(i.x,s.offset.x),ns(i.y,s.offset.y)),i}(n,i.root,this.visualElement.getTransformPagePoint());let o=function(t,e){return{x:Wi(t.x,e.x),y:Wi(t.y,e.y)}}(i.layout.layoutBox,s);if(e){const t=e(function({x:t,y:e}){return{top:e.min,right:t.max,bottom:e.max,left:t.min}}(o));this.hasMutatedConstraints=!!t,t&&(o=Xi(t))}return o}startAnimation(t){const{drag:e,dragMomentum:n,dragElastic:i,dragTransition:s,dragSnapToOrigin:o,onDragTransitionEnd:r}=this.getProps(),a=this.constraints||{},l=Yi(r=>{if(!us(r,e,this.currentDirection))return;let l=a&&a[r]||{};o&&(l={min:0,max:0});const u=i?200:1e6,c=i?40:1e7,h={type:"inertia",velocity:n?t[r]:0,bounceStiffness:u,bounceDamping:c,timeConstant:750,restDelta:1,restSpeed:10,...s,...l};return this.startAxisValueAnimation(r,h)});return Promise.all(l).then(r)}startAxisValueAnimation(t,e){const n=this.getAxisMotionValue(t);return Hn(this.visualElement,t),n.start(Dn(t,n,0,e,this.visualElement,!1))}stopAnimation(){Yi(t=>this.getAxisMotionValue(t).stop())}pauseAnimation(){Yi(t=>{var e;return null===(e=this.getAxisMotionValue(t).animation)||void 0===e?void 0:e.pause()})}getAnimationState(t){var e;return null===(e=this.getAxisMotionValue(t).animation)||void 0===e?void 0:e.state}getAxisMotionValue(t){const e="_drag"+t.toUpperCase(),n=this.visualElement.getProps(),i=n[e];return i||this.visualElement.getValue(t,(n.initial?n.initial[t]:void 0)||0)}snapToCursor(t){Yi(e=>{const{drag:n}=this.getProps();if(!us(e,n,this.currentDirection))return;const{projection:i}=this.visualElement,s=this.getAxisMotionValue(e);if(i&&i.layout){const{min:n,max:o}=i.layout.layoutBox[e];s.set(t[e]-Xe(n,o,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:t,dragConstraints:e}=this.getProps(),{projection:n}=this.visualElement;if(!ki(e)||!n||!this.constraints)return;this.stopAnimation();const i={x:0,y:0};Yi(t=>{const e=this.getAxisMotionValue(t);if(e&&!1!==this.constraints){const n=e.get();i[t]=function(t,e){let n=.5;const i=Li(t),s=Li(e);return s>i?n=de(e.min,e.max-i,t.min):i>s&&(n=de(t.min,t.max-s,e.min)),nt(0,1,n)}({min:n,max:n},this.constraints[t])}});const{transformTemplate:s}=this.visualElement.getProps();this.visualElement.current.style.transform=s?s({},""):"none",n.root&&n.root.updateScroll(),n.updateLayout(),this.resolveConstraints(),Yi(e=>{if(!us(e,t,null))return;const n=this.getAxisMotionValue(e),{min:s,max:o}=this.constraints[e];n.set(Xe(s,o,i[e]))})}addListeners(){if(!this.visualElement.current)return;as.set(this.visualElement,this);const t=Ti(this.visualElement.current,"pointerdown",t=>{const{drag:e,dragListener:n=!0}=this.getProps();e&&n&&this.start(t)}),e=()=>{const{dragConstraints:t}=this.getProps();ki(t)&&t.current&&(this.constraints=this.resolveRefConstraints())},{projection:n}=this.visualElement,i=n.addEventListener("measure",e);n&&!n.layout&&(n.root&&n.root.updateScroll(),n.updateLayout()),k.read(e);const s=Pi(window,"resize",()=>this.scalePositionWithinConstraints()),o=n.addEventListener("didUpdate",({delta:t,hasLayoutChanged:e})=>{this.isDragging&&e&&(Yi(e=>{const n=this.getAxisMotionValue(e);n&&(this.originPoint[e]+=t[e].translate,n.set(n.get()+t[e].translate))}),this.visualElement.render())});return()=>{s(),t(),i(),o&&o()}}getProps(){const t=this.visualElement.getProps(),{drag:e=!1,dragDirectionLock:n=!1,dragPropagation:i=!1,dragConstraints:s=!1,dragElastic:o=Ni,dragMomentum:r=!0}=t;return{...t,drag:e,dragDirectionLock:n,dragPropagation:i,dragConstraints:s,dragElastic:o,dragMomentum:r}}}function us(t,e,n){return!(!0!==e&&e!==t||null!==n&&n!==t)}const cs=t=>(e,n)=>{t&&k.postRender(()=>t(e,n))};const hs=["TopLeft","TopRight","BottomLeft","BottomRight"],ds=hs.length,ps=t=>"string"==typeof t?parseFloat(t):t,ms=t=>"number"==typeof t||ut.test(t);function fs(t,e){return void 0!==t[e]?t[e]:t.borderRadius}const gs=vs(0,.5,Y),ys=vs(.5,.95,M);function vs(t,e,n){return i=>i<t?0:i>e?1:n(de(t,e,i))}function xs(t,e){t.min=e.min,t.max=e.max}function ws(t,e){xs(t.x,e.x),xs(t.y,e.y)}function Ps(t,e){t.translate=e.translate,t.scale=e.scale,t.originPoint=e.originPoint,t.origin=e.origin}function Ts(t,e,n,i,s){return t=Ji(t-=e,1/n,i),void 0!==s&&(t=Ji(t,1/s,i)),t}function Ss(t,e,[n,i,s],o,r){!function(t,e=0,n=1,i=.5,s,o=t,r=t){if(lt.test(e)){e=parseFloat(e);e=Xe(r.min,r.max,e/100)-r.min}if("number"!=typeof e)return;let a=Xe(o.min,o.max,i);t===o&&(a-=e),t.min=Ts(t.min,e,n,a,s),t.max=Ts(t.max,e,n,a,s)}(t,e[n],e[i],e[s],e.scale,o,r)}const bs=["x","scaleX","originX"],As=["y","scaleY","originY"];function Es(t,e,n,i){Ss(t.x,e,bs,n?n.x:void 0,i?i.x:void 0),Ss(t.y,e,As,n?n.y:void 0,i?i.y:void 0)}function Ms(t){return 0===t.translate&&1===t.scale}function Cs(t){return Ms(t.x)&&Ms(t.y)}function Vs(t,e){return t.min===e.min&&t.max===e.max}function Rs(t,e){return Math.round(t.min)===Math.round(e.min)&&Math.round(t.max)===Math.round(e.max)}function Ds(t,e){return Rs(t.x,e.x)&&Rs(t.y,e.y)}function ks(t){return Li(t.x)/Li(t.y)}function Ls(t,e){return t.translate===e.translate&&t.scale===e.scale&&t.originPoint===e.originPoint}class Bs{constructor(){this.members=[]}add(t){kn(this.members,t),t.scheduleRender()}remove(t){if(Ln(this.members,t),t===this.prevLead&&(this.prevLead=void 0),t===this.lead){const t=this.members[this.members.length-1];t&&this.promote(t)}}relegate(t){const e=this.members.findIndex(e=>t===e);if(0===e)return!1;let n;for(let t=e;t>=0;t--){const e=this.members[t];if(!1!==e.isPresent){n=e;break}}return!!n&&(this.promote(n),!0)}promote(t,e){const n=this.lead;if(t!==n&&(this.prevLead=n,this.lead=t,t.show(),n)){n.instance&&n.scheduleRender(),t.scheduleRender(),t.resumeFrom=n,e&&(t.resumeFrom.preserveOpacity=!0),n.snapshot&&(t.snapshot=n.snapshot,t.snapshot.latestValues=n.animationValues||n.latestValues),t.root&&t.root.isUpdating&&(t.isLayoutDirty=!0);const{crossfade:i}=t.options;!1===i&&n.hide()}}exitAnimationComplete(){this.members.forEach(t=>{const{options:e,resumingFrom:n}=t;e.onExitComplete&&e.onExitComplete(),n&&n.options.onExitComplete&&n.options.onExitComplete()})}scheduleRender(){this.members.forEach(t=>{t.instance&&t.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}const Fs={};function js(t){Object.assign(Fs,t)}const Os=(t,e)=>t.depth-e.depth;class Is{constructor(){this.children=[],this.isDirty=!1}add(t){kn(this.children,t),this.isDirty=!0}remove(t){Ln(this.children,t),this.isDirty=!0}forEach(t){this.isDirty&&this.children.sort(Os),this.isDirty=!1,this.children.forEach(t)}}function Us(t){const e=$n(t)?t.get():t;return n=e,Boolean(n&&"object"==typeof n&&n.mix&&n.toValue)?e.toValue():e;var n}const Ws={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function Ns(t,e){const n=le.now(),i=({timestamp:s})=>{const o=s-n;o>=e&&(L(i),t(o-e))};return k.read(i,!0),()=>L(i)}function zs(t,e=100,n){const i=n({...t,keyframes:[0,e]}),s=Math.min(De(i),2e4);return{type:"keyframes",ease:t=>i.next(s*t).value/e,duration:y(s)}}function $s(t){return"object"==typeof t&&!Array.isArray(t)}function Hs(t,e,n,i){return"string"==typeof t&&$s(e)?li(t,n,i):t instanceof NodeList?Array.from(t):Array.isArray(t)?t:[t]}function Ys(t,e,n,i){var s;return"number"==typeof e?e:e.startsWith("-")||e.startsWith("+")?Math.max(0,t+parseFloat(e)):"<"===e?n:null!==(s=i.get(e))&&void 0!==s?s:t}const Xs=(t,e,n)=>{const i=e-t;return((n-t)%i+i)%i+t};function Ks(t,e){return We(t)?t[Xs(0,t.length,e)]:t}function Gs(t,e,n,i,s,o){!function(t,e,n){for(let i=0;i<t.length;i++){const s=t[i];s.at>e&&s.at<n&&(Ln(t,s),i--)}}(t,s,o);for(let r=0;r<e.length;r++)t.push({value:e[r],at:Xe(s,o,i[r]),easing:Ks(n,r)})}function _s(t,e){return t.at===e.at?null===t.value?1:null===e.value?-1:0:t.at-e.at}function qs(t,e){for(let n=0;n<t.length;n++)t[n]=t[n]/(e+1)}function Zs(t,e,n){return t*(e+1)}function Js(t,e){return!e.has(t)&&e.set(t,{}),e.get(t)}function Qs(t,e){return e[t]||(e[t]=[]),e[t]}function to(t){return Array.isArray(t)?t:[t]}function eo(t,e){return t&&t[e]?{...t,...t[e]}:{...t}}const no=t=>"number"==typeof t,io=t=>t.every(no),so=new WeakMap;function oo(t){return t instanceof SVGElement&&"svg"!==t.tagName}function ro(t,{layout:e,layoutId:n}){return f.has(t)||t.startsWith("origin")||(e||void 0!==n)&&(!!Fs[t]||"opacity"===t)}function ao(t,e,n){var i;const{style:s}=t,o={};for(const r in s)($n(s[r])||e.style&&$n(e.style[r])||ro(r,t)||void 0!==(null===(i=null==n?void 0:n.getValue(r))||void 0===i?void 0:i.liveStyle))&&(o[r]=s[r]);return o}function lo(t,e,n){const i=ao(t,e,n);for(const n in t)if($n(t[n])||$n(e[n])){i[-1!==m.indexOf(n)?"attr"+n.charAt(0).toUpperCase()+n.substring(1):n]=t[n]}return i}const uo="undefined"!=typeof window,co={current:null},ho={current:!1};function po(){if(ho.current=!0,uo)if(window.matchMedia){const t=window.matchMedia("(prefers-reduced-motion)"),e=()=>co.current=t.matches;t.addListener(e),e()}else co.current=!1}function mo(t){return o(t.animate)||p.some(e=>l(t[e]))}function fo(t){return Boolean(mo(t)||t.variants)}const go={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},yo={};for(const t in go)yo[t]={isEnabled:e=>go[t].some(t=>!!e[t])};const vo=[...Pt,It,Yt],xo=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class wo{scrapeMotionValuesFromProps(t,e,n){return{}}constructor({parent:t,props:e,presenceContext:n,reducedMotionConfig:i,blockInitialAnimation:s,visualState:o},r={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=Ct,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const t=le.now();this.renderScheduledAt<t&&(this.renderScheduledAt=t,k.render(this.render,!1,!0))};const{latestValues:a,renderState:l}=o;this.latestValues=a,this.baseTarget={...a},this.initialValues=e.initial?{...a}:{},this.renderState=l,this.parent=t,this.props=e,this.presenceContext=n,this.depth=t?t.depth+1:0,this.reducedMotionConfig=i,this.options=r,this.blockInitialAnimation=Boolean(s),this.isControllingVariants=mo(e),this.isVariantNode=fo(e),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=Boolean(t&&t.current);const{willChange:u,...c}=this.scrapeMotionValuesFromProps(e,{},this);for(const t in c){const e=c[t];void 0!==a[t]&&$n(e)&&e.set(a[t],!1)}}mount(t){this.current=t,so.set(t,this),this.projection&&!this.projection.instance&&this.projection.mount(t),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((t,e)=>this.bindToMotionValue(e,t)),ho.current||po(),this.shouldReduceMotion="never"!==this.reducedMotionConfig&&("always"===this.reducedMotionConfig||co.current),this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){so.delete(this.current),this.projection&&this.projection.unmount(),L(this.notifyUpdate),L(this.render),this.valueSubscriptions.forEach(t=>t()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const t in this.events)this.events[t].clear();for(const t in this.features){const e=this.features[t];e&&(e.unmount(),e.isMounted=!1)}this.current=null}bindToMotionValue(t,e){this.valueSubscriptions.has(t)&&this.valueSubscriptions.get(t)();const n=f.has(t),i=e.on("change",e=>{this.latestValues[t]=e,this.props.onUpdate&&k.preRender(this.notifyUpdate),n&&this.projection&&(this.projection.isTransformDirty=!0)}),s=e.on("renderRequest",this.scheduleRender);let o;window.MotionCheckAppearSync&&(o=window.MotionCheckAppearSync(this,t,e)),this.valueSubscriptions.set(t,()=>{i(),s(),o&&o(),e.owner&&e.stop()})}sortNodePosition(t){return this.current&&this.sortInstanceNodePosition&&this.type===t.type?this.sortInstanceNodePosition(this.current,t.current):0}updateFeatures(){let t="animation";for(t in yo){const e=yo[t];if(!e)continue;const{isEnabled:n,Feature:i}=e;if(!this.features[t]&&i&&n(this.props)&&(this.features[t]=new i(this)),this.features[t]){const e=this.features[t];e.isMounted?e.update():(e.mount(),e.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):{x:{min:0,max:0},y:{min:0,max:0}}}getStaticValue(t){return this.latestValues[t]}setStaticValue(t,e){this.latestValues[t]=e}update(t,e){(t.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=t,this.prevPresenceContext=this.presenceContext,this.presenceContext=e;for(let e=0;e<xo.length;e++){const n=xo[e];this.propEventSubscriptions[n]&&(this.propEventSubscriptions[n](),delete this.propEventSubscriptions[n]);const i=t["on"+n];i&&(this.propEventSubscriptions[n]=this.on(n,i))}this.prevMotionValues=function(t,e,n){for(const i in e){const s=e[i],o=n[i];if($n(s))t.addValue(i,s);else if($n(o))t.addValue(i,On(s,{owner:t}));else if(o!==s)if(t.hasValue(i)){const e=t.getValue(i);!0===e.liveStyle?e.jump(s):e.hasAnimated||e.set(s)}else{const e=t.getStaticValue(i);t.addValue(i,On(void 0!==e?e:s,{owner:t}))}}for(const i in n)void 0===e[i]&&t.removeValue(i);return e}(this,this.scrapeMotionValuesFromProps(t,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(t){return this.props.variants?this.props.variants[t]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(t){const e=this.getClosestVariantNode();if(e)return e.variantChildren&&e.variantChildren.add(t),()=>e.variantChildren.delete(t)}addValue(t,e){const n=this.values.get(t);e!==n&&(n&&this.removeValue(t),this.bindToMotionValue(t,e),this.values.set(t,e),this.latestValues[t]=e.get())}removeValue(t){this.values.delete(t);const e=this.valueSubscriptions.get(t);e&&(e(),this.valueSubscriptions.delete(t)),delete this.latestValues[t],this.removeValueFromRenderState(t,this.renderState)}hasValue(t){return this.values.has(t)}getValue(t,e){if(this.props.values&&this.props.values[t])return this.props.values[t];let n=this.values.get(t);return void 0===n&&void 0!==e&&(n=On(null===e?void 0:e,{owner:this}),this.addValue(t,n)),n}readValue(t,e){var n;let i=void 0===this.latestValues[t]&&this.current?null!==(n=this.getBaseTargetFromProps(this.props,t))&&void 0!==n?n:this.readValueFromInstance(this.current,t,this.options):this.latestValues[t];var s;return null!=i&&("string"==typeof i&&(G(i)||K(i))?i=parseFloat(i):(s=i,!vo.find(wt(s))&&Yt.test(e)&&(i=ne(t,e))),this.setBaseTarget(t,$n(i)?i.get():i)),$n(i)?i.get():i}setBaseTarget(t,e){this.baseTarget[t]=e}getBaseTarget(t){var e;const{initial:n}=this.props;let i;if("string"==typeof n||"object"==typeof n){const s=c(this.props,n,null===(e=this.presenceContext)||void 0===e?void 0:e.custom);s&&(i=s[t])}if(n&&void 0!==i)return i;const s=this.getBaseTargetFromProps(this.props,t);return void 0===s||$n(s)?void 0!==this.initialValues[t]&&void 0===i?void 0:this.baseTarget[t]:s}on(t,e){return this.events[t]||(this.events[t]=new Bn),this.events[t].add(e)}notify(t,...e){this.events[t]&&this.events[t].notify(...e)}}class Po extends wo{constructor(){super(...arguments),this.KeyframeResolver=se}sortInstanceNodePosition(t,e){return 2&t.compareDocumentPosition(e)?1:-1}getBaseTargetFromProps(t,e){return t.style?t.style[e]:void 0}removeValueFromRenderState(t,{vars:e,style:n}){delete e[t],delete n[t]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:t}=this.props;$n(t)&&(this.childSubscription=t.on("change",t=>{this.current&&(this.current.textContent=""+t)}))}}const To=(t,e)=>e&&"number"==typeof t?e.transform(t):t,So={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},bo=m.length;function Ao(t,e,n){let i="",s=!0;for(let o=0;o<bo;o++){const r=m[o],a=t[r];if(void 0===a)continue;let l=!0;if(l="number"==typeof a?a===(r.startsWith("scale")?1:0):0===parseFloat(a),!l||n){const t=To(a,Qt[r]);if(!l){s=!1;i+=`${So[r]||r}(${t}) `}n&&(e[r]=t)}}return i=i.trim(),n?i=n(e,s?"":i):s&&(i="none"),i}function Eo(t,e,n){const{style:i,vars:s,transformOrigin:o}=t;let r=!1,a=!1;for(const t in e){const n=e[t];if(f.has(t))r=!0;else if(q(t))s[t]=n;else{const e=To(n,Qt[t]);t.startsWith("origin")?(a=!0,o[t]=e):i[t]=e}}if(e.transform||(r||n?i.transform=Ao(e,t.transform,n):i.transform&&(i.transform="none")),a){const{originX:t="50%",originY:e="50%",originZ:n=0}=o;i.transformOrigin=`${t} ${e} ${n}`}}function Mo(t,e,n){return"string"==typeof t?t:ut.transform(e+n*t)}const Co={offset:"stroke-dashoffset",array:"stroke-dasharray"},Vo={offset:"strokeDashoffset",array:"strokeDasharray"};function Ro(t,{attrX:e,attrY:n,attrScale:i,originX:s,originY:o,pathLength:r,pathSpacing:a=1,pathOffset:l=0,...u},c,h){if(Eo(t,u,h),c)return void(t.style.viewBox&&(t.attrs.viewBox=t.style.viewBox));t.attrs=t.style,t.style={};const{attrs:d,style:p,dimensions:m}=t;d.transform&&(m&&(p.transform=d.transform),delete d.transform),m&&(void 0!==s||void 0!==o||p.transform)&&(p.transformOrigin=function(t,e,n){return`${Mo(e,t.x,t.width)} ${Mo(n,t.y,t.height)}`}(m,void 0!==s?s:.5,void 0!==o?o:.5)),void 0!==e&&(d.x=e),void 0!==n&&(d.y=n),void 0!==i&&(d.scale=i),void 0!==r&&function(t,e,n=1,i=0,s=!0){t.pathLength=1;const o=s?Co:Vo;t[o.offset]=ut.transform(-i);const r=ut.transform(e),a=ut.transform(n);t[o.array]=`${r} ${a}`}(d,r,a,l,!1)}const Do=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function ko(t,{style:e,vars:n},i,s){Object.assign(t.style,e,s&&s.getProjectionStyles(i));for(const e in n)t.style.setProperty(e,n[e])}function Lo(t,e,n,i){ko(t,e,void 0,i);for(const n in e.attrs)t.setAttribute(Do.has(n)?n:Wn(n),e.attrs[n])}const Bo=t=>"string"==typeof t&&"svg"===t.toLowerCase();class Fo extends Po{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=Hi}getBaseTargetFromProps(t,e){return t[e]}readValueFromInstance(t,e){if(f.has(e)){const t=ee(e);return t&&t.default||0}return e=Do.has(e)?e:Wn(e),t.getAttribute(e)}scrapeMotionValuesFromProps(t,e,n){return lo(t,e,n)}build(t,e,n){Ro(t,e,this.isSVGTag,n.transformTemplate)}renderInstance(t,e,n,i){Lo(t,e,0,i)}mount(t){this.isSVGTag=Bo(t.tagName),super.mount(t)}}class jo extends Po{constructor(){super(...arguments),this.type="html",this.renderInstance=ko}readValueFromInstance(t,e){if(f.has(e)){const t=ee(e);return t&&t.default||0}{const i=(n=t,window.getComputedStyle(n)),s=(q(e)?i.getPropertyValue(e):i[e])||0;return"string"==typeof s?s.trim():s}var n}measureInstanceViewportBox(t,{transformPagePoint:e}){return os(t,e)}build(t,e,n){Eo(t,e,n.transformTemplate)}scrapeMotionValuesFromProps(t,e,n){return ao(t,e,n)}}class Oo extends wo{constructor(){super(...arguments),this.type="object"}readValueFromInstance(t,e){if(function(t,e){return t in e}(e,t)){const n=t[e];if("string"==typeof n||"number"==typeof n)return n}}getBaseTargetFromProps(){}removeValueFromRenderState(t,e){delete e.output[t]}measureInstanceViewportBox(){return{x:{min:0,max:0},y:{min:0,max:0}}}build(t,e){Object.assign(t.output,e)}renderInstance(t,{output:e}){Object.assign(t,e)}sortInstanceNodePosition(){return 0}}function Io(t){const e={presenceContext:null,props:{},visualState:{renderState:{transform:{},transformOrigin:{},style:{},vars:{},attrs:{}},latestValues:{}}},n=oo(t)?new Fo(e):new jo(e);n.mount(t),so.set(t,n)}function Uo(t){const e=new Oo({presenceContext:null,props:{},visualState:{renderState:{output:{}},latestValues:{}}});e.mount(t),so.set(t,e)}function Wo(t,e,n){const i=$n(t)?t:On(t);return i.start(Dn("",i,e,n)),i.animation}function No(t,e,n,i){const s=[];if(function(t,e){return $n(t)||"number"==typeof t||"string"==typeof t&&!$s(e)}(t,e))s.push(Wo(t,$s(e)&&e.default||e,n&&n.default||n));else{const o=Hs(t,e,i),r=o.length;for(let t=0;t<r;t++){const i=o[t],a=i instanceof Element?Io:Uo;so.has(i)||a(i);const l=so.get(i),u={...n};"delay"in u&&"function"==typeof u.delay&&(u.delay=u.delay(t,r)),s.push(...Xn(l,{...e,transition:u},{}))}}return s}function zo(t,e,n){const i=[];return function(t,{defaultTransition:e={},...n}={},i,s){const o=e.duration||.3,r=new Map,a=new Map,l={},u=new Map;let c=0,h=0,d=0;for(let n=0;n<t.length;n++){const r=t[n];if("string"==typeof r){u.set(r,h);continue}if(!Array.isArray(r)){u.set(r.name,Ys(h,r.at,c,u));continue}let[p,m,f={}]=r;void 0!==f.at&&(h=Ys(h,f.at,c,u));let y=0;const v=(t,n,i,r=0,a=0)=>{const l=to(t),{delay:u=0,times:c=un(l),type:p="keyframes",repeat:m,repeatType:f,repeatDelay:v=0,...x}=n;let{ease:w=e.ease||"easeOut",duration:P}=n;const T="function"==typeof u?u(r,a):u,S=l.length,b=oe(p)?p:null==s?void 0:s[p];if(S<=2&&b){let t=100;if(2===S&&io(l)){const e=l[1]-l[0];t=Math.abs(e)}const e={...x};void 0!==P&&(e.duration=g(P));const n=zs(e,t,b);w=n.ease,P=n.duration}null!=P||(P=o);const A=h+T;1===c.length&&0===c[0]&&(c[1]=1);const E=c.length-l.length;if(E>0&&ln(c,E),1===l.length&&l.unshift(null),m){P=Zs(P,m);const t=[...l],e=[...c];w=Array.isArray(w)?[...w]:[w];const n=[...w];for(let i=0;i<m;i++){l.push(...t);for(let s=0;s<t.length;s++)c.push(e[s]+(i+1)),w.push(0===s?"linear":Ks(n,s-1))}qs(c,m)}const M=A+P;Gs(i,l,w,c,A,M),y=Math.max(T+P,y),d=Math.max(M,d)};if($n(p)){v(m,f,Qs("default",Js(p,a)))}else{const t=Hs(p,m,i,l),e=t.length;for(let n=0;n<e;n++){m=m,f=f;const i=Js(t[n],a);for(const t in m)v(m[t],eo(f,t),Qs(t,i),n,e)}}c=h,h+=y}return a.forEach((t,i)=>{for(const s in t){const o=t[s];o.sort(_s);const a=[],l=[],u=[];for(let t=0;t<o.length;t++){const{at:e,value:n,easing:i}=o[t];a.push(n),l.push(de(0,d,e)),u.push(i||"easeOut")}0!==l[0]&&(l.unshift(0),a.unshift(a[0]),u.unshift("easeInOut")),1!==l[l.length-1]&&(l.push(1),a.push(null)),r.has(i)||r.set(i,{keyframes:{},transition:{}});const c=r.get(i);c.keyframes[s]=a,c.transition[s]={...e,duration:d,ease:u,times:l,...n}}}),r}(t,e,n,{spring:Fe}).forEach(({keyframes:t,transition:e},n)=>{i.push(...No(n,t,e))}),i}function $o(t){return function(e,n,i){let s=[];var o;o=e,s=Array.isArray(o)&&Array.isArray(o[0])?zo(e,n,t):No(e,n,i,t);const r=new Rn(s);return t&&t.animations.push(r),r}}const Ho=$o();function Yo(t,e,n){t.style.setProperty("--"+e,n)}function Xo(t,e,n){t.style[e]=n}const Ko=yn(()=>{try{document.createElement("div").animate({opacity:[1]})}catch(t){return!1}return!0}),Go=new WeakMap;function _o(t){const e=Go.get(t)||new Map;return Go.set(t,e),Go.get(t)}class qo{constructor(t,e,n,i){const s=e.startsWith("--");this.setValue=s?Yo:Xo,this.options=i,this.updateFinishedPromise(),V("string"!=typeof i.type);const o=_o(t).get(e);o&&o.stop();if(Array.isArray(n)||(n=[n]),function(t,e,n){for(let i=0;i<e.length;i++)null===e[i]&&(e[i]=0===i?n():e[i-1]),"number"==typeof e[i]&&qt[t]&&(e[i]=qt[t].transform(e[i]));!Ko()&&e.length<2&&e.unshift(n())}(e,n,()=>e.startsWith("--")?t.style.getPropertyValue(e):window.getComputedStyle(t)[e]),oe(i.type)){const t=zs(i,100,i.type);i.ease=wn()?t.ease:"easeOut",i.duration=g(t.duration),i.type="keyframes"}else i.ease=i.ease||"easeOut";this.removeAnimation=()=>{var n;return null===(n=Go.get(t))||void 0===n?void 0:n.delete(e)};const r=()=>{this.setValue(t,e,E(n,this.options)),this.cancel(),this.resolveFinishedPromise()};En()?(this.animation=bn(t,e,n,i),!1===i.autoplay&&this.animation.pause(),this.animation.onfinish=r,this.pendingTimeline&&An(this.animation,this.pendingTimeline),_o(t).set(e,this)):r()}get duration(){return y(this.options.duration||300)}get time(){var t;return this.animation?y((null===(t=this.animation)||void 0===t?void 0:t.currentTime)||0):0}set time(t){this.animation&&(this.animation.currentTime=g(t))}get speed(){return this.animation?this.animation.playbackRate:1}set speed(t){this.animation&&(this.animation.playbackRate=t)}get state(){return this.animation?this.animation.playState:"finished"}get startTime(){return this.animation?this.animation.startTime:null}flatten(){var t;this.animation&&(null===(t=this.animation.effect)||void 0===t||t.updateTiming({easing:"linear"}))}play(){"finished"===this.state&&this.updateFinishedPromise(),this.animation&&this.animation.play()}pause(){this.animation&&this.animation.pause()}stop(){this.animation&&"idle"!==this.state&&"finished"!==this.state&&(this.animation.commitStyles&&this.animation.commitStyles(),this.cancel())}complete(){this.animation&&this.animation.finish()}cancel(){this.removeAnimation();try{this.animation&&this.animation.cancel()}catch(t){}}then(t,e){return this.currentFinishedPromise.then(t,e)}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}attachTimeline(t){return this.animation?An(this.animation,t):this.pendingTimeline=t,M}}const Zo=t=>function(e,n,i){return new Rn(function(t,e,n,i){const s=li(t,i),o=s.length,r=[];for(let t=0;t<o;t++){const i=s[t],a={...n};"function"==typeof a.delay&&(a.delay=a.delay(t,o));for(const t in e){const n=e[t],s={...T(a,t)};s.duration=s.duration?g(s.duration):s.duration,s.delay=g(s.delay||0),r.push(new qo(i,t,n,s))}}return r}(e,n,i,t))},Jo=Zo(),Qo=new WeakMap;let tr;function er({target:t,contentRect:e,borderBoxSize:n}){var i;null===(i=Qo.get(t))||void 0===i||i.forEach(i=>{i({target:t,contentSize:e,get size(){return function(t,e){if(e){const{inlineSize:t,blockSize:n}=e[0];return{width:t,height:n}}return t instanceof SVGElement&&"getBBox"in t?t.getBBox():{width:t.offsetWidth,height:t.offsetHeight}}(t,n)}})})}function nr(t){t.forEach(er)}function ir(t,e){tr||"undefined"!=typeof ResizeObserver&&(tr=new ResizeObserver(nr));const n=li(t);return n.forEach(t=>{let n=Qo.get(t);n||(n=new Set,Qo.set(t,n)),n.add(e),null==tr||tr.observe(t)}),()=>{n.forEach(t=>{const n=Qo.get(t);null==n||n.delete(e),(null==n?void 0:n.size)||null==tr||tr.unobserve(t)})}}const sr=new Set;let or;function rr(t){return sr.add(t),or||(or=()=>{const t={width:window.innerWidth,height:window.innerHeight},e={target:window,size:t,contentSize:t};sr.forEach(t=>t(e))},window.addEventListener("resize",or)),()=>{sr.delete(t),!sr.size&&or&&(or=void 0)}}const ar={x:{length:"Width",position:"Left"},y:{length:"Height",position:"Top"}};function lr(t,e,n,i){const s=n[e],{length:o,position:r}=ar[e],a=s.current,l=n.time;s.current=t["scroll"+r],s.scrollLength=t["scroll"+o]-t["client"+o],s.offset.length=0,s.offset[0]=0,s.offset[1]=s.scrollLength,s.progress=de(0,s.scrollLength,s.current);const u=i-l;s.velocity=u>50?0:me(s.current-a,u)}const ur={Enter:[[0,1],[1,1]],Exit:[[0,0],[1,0]],Any:[[1,0],[0,1]],All:[[0,0],[1,1]]},cr={start:0,center:.5,end:1};function hr(t,e,n=0){let i=0;if(t in cr&&(t=cr[t]),"string"==typeof t){const e=parseFloat(t);t.endsWith("px")?i=e:t.endsWith("%")?t=e/100:t.endsWith("vw")?i=e/100*document.documentElement.clientWidth:t.endsWith("vh")?i=e/100*document.documentElement.clientHeight:t=e}return"number"==typeof t&&(i=e*t),n+i}const dr=[0,0];function pr(t,e,n,i){let s=Array.isArray(t)?t:dr,o=0,r=0;return"number"==typeof t?s=[t,t]:"string"==typeof t&&(s=(t=t.trim()).includes(" ")?t.split(" "):[t,cr[t]?t:"0"]),o=hr(s[0],n,i),r=hr(s[1],e),o-r}const mr={x:0,y:0};function fr(t,e,n){const{offset:i=ur.All}=n,{target:s=t,axis:o="y"}=n,r="y"===o?"height":"width",a=s!==t?function(t,e){const n={x:0,y:0};let i=t;for(;i&&i!==e;)if(i instanceof HTMLElement)n.x+=i.offsetLeft,n.y+=i.offsetTop,i=i.offsetParent;else if("svg"===i.tagName){const t=i.getBoundingClientRect();i=i.parentElement;const e=i.getBoundingClientRect();n.x+=t.left-e.left,n.y+=t.top-e.top}else{if(!(i instanceof SVGGraphicsElement))break;{const{x:t,y:e}=i.getBBox();n.x+=t,n.y+=e;let s=null,o=i.parentNode;for(;!s;)"svg"===o.tagName&&(s=o),o=i.parentNode;i=s}}return n}(s,t):mr,l=s===t?{width:t.scrollWidth,height:t.scrollHeight}:function(t){return"getBBox"in t&&"svg"!==t.tagName?t.getBBox():{width:t.clientWidth,height:t.clientHeight}}(s),u={width:t.clientWidth,height:t.clientHeight};e[o].offset.length=0;let c=!e[o].interpolate;const h=i.length;for(let t=0;t<h;t++){const n=pr(i[t],u[r],l[r],a[o]);c||n===e[o].interpolatorOffsets[t]||(c=!0),e[o].offset[t]=n}c&&(e[o].interpolate=an(e[o].offset,un(i)),e[o].interpolatorOffsets=[...e[o].offset]),e[o].progress=e[o].interpolate(e[o].current)}function gr(t,e,n,i={}){return{measure:()=>function(t,e=t,n){if(n.x.targetOffset=0,n.y.targetOffset=0,e!==t){let i=e;for(;i&&i!==t;)n.x.targetOffset+=i.offsetLeft,n.y.targetOffset+=i.offsetTop,i=i.offsetParent}n.x.targetLength=e===t?e.scrollWidth:e.clientWidth,n.y.targetLength=e===t?e.scrollHeight:e.clientHeight,n.x.containerLength=t.clientWidth,n.y.containerLength=t.clientHeight}(t,i.target,n),update:e=>{!function(t,e,n){lr(t,"x",e,n),lr(t,"y",e,n),e.time=n}(t,n,e),(i.offset||i.target)&&fr(t,n,i)},notify:()=>e(n)}}const yr=new WeakMap,vr=new WeakMap,xr=new WeakMap,wr=t=>t===document.documentElement?window:t;function Pr(t,{container:e=document.documentElement,...n}={}){let i=xr.get(e);i||(i=new Set,xr.set(e,i));const s=gr(e,t,{time:0,x:{current:0,offset:[],progress:0,scrollLength:0,targetOffset:0,targetLength:0,containerLength:0,velocity:0},y:{current:0,offset:[],progress:0,scrollLength:0,targetOffset:0,targetLength:0,containerLength:0,velocity:0}},n);if(i.add(s),!yr.has(e)){const t=()=>{for(const t of i)t.measure()},n=()=>{for(const t of i)t.update(B.timestamp)},s=()=>{for(const t of i)t.notify()},a=()=>{k.read(t,!1,!0),k.read(n,!1,!0),k.update(s,!1,!0)};yr.set(e,a);const l=wr(e);window.addEventListener("resize",a,{passive:!0}),e!==document.documentElement&&vr.set(e,(r=a,"function"==typeof(o=e)?rr(o):ir(o,r))),l.addEventListener("scroll",a,{passive:!0})}var o,r;const a=yr.get(e);return k.read(a,!1,!0),()=>{var t;L(a);const n=xr.get(e);if(!n)return;if(n.delete(s),n.size)return;const i=yr.get(e);yr.delete(e),i&&(wr(e).removeEventListener("scroll",i),null===(t=vr.get(e))||void 0===t||t(),window.removeEventListener("resize",i))}}function Tr(t,e){let n;const i=()=>{const{currentTime:i}=e,s=(null===i?0:i.value)/100;n!==s&&t(s),n=s};return k.update(i,!0),()=>L(i)}const Sr=new Map;function br({source:t,container:e=document.documentElement,axis:n="y"}={}){t&&(e=t),Sr.has(e)||Sr.set(e,{});const i=Sr.get(e);return i[n]||(i[n]=Vn()?new ScrollTimeline({source:e,axis:n}):function({source:t,container:e,axis:n="y"}){t&&(e=t);const i={value:0},s=Pr(t=>{i.value=100*t[n].progress},{container:e,axis:n});return{currentTime:i,cancel:s}}({source:e,axis:n})),i[n]}function Ar(t){return t&&(t.target||t.offset)}function Er(t,{axis:e="y",...n}={}){const i={axis:e,...n};return"function"==typeof t?function(t,e){return function(t){return 2===t.length}(t)||Ar(e)?Pr(n=>{t(n[e.axis].progress,n)},e):Tr(t,br(e))}(t,i):function(t,e){if(t.flatten(),Ar(e))return t.pause(),Pr(n=>{t.time=t.duration*n[e.axis].progress},e);{const n=br(e);return t.attachTimeline?t.attachTimeline(n,t=>(t.pause(),Tr(e=>{t.time=t.duration*e},n))):M}}(t,i)}const Mr={some:0,all:1};function Cr(t,e,{root:n,margin:i,amount:s="some"}={}){const o=li(t),r=new WeakMap,a=new IntersectionObserver(t=>{t.forEach(t=>{const n=r.get(t.target);if(t.isIntersecting!==Boolean(n))if(t.isIntersecting){const n=e(t);"function"==typeof n?r.set(t.target,n):a.unobserve(t.target)}else n&&(n(t),r.delete(t.target))})},{root:n,rootMargin:i,threshold:"number"==typeof s?s:Mr[s]});return o.forEach(t=>a.observe(t)),()=>a.disconnect()}function Vr(...t){const e=!Array.isArray(t[0]),n=e?0:-1,i=t[0+n],s=t[1+n],o=t[2+n],r=t[3+n],a=an(s,o,{mixer:(l=o[0],(t=>t&&"object"==typeof t&&t.mix)(l)?l.mix:void 0),...r});var l;return e?a(i):a}const Rr=k,Dr=R.reduce((t,e)=>(t[e]=t=>L(t),t),{}),{schedule:kr,cancel:Lr}=D(queueMicrotask,!1),Br={type:"projectionFrame",totalNodes:0,resolvedTargetDeltas:0,recalculatedProjection:0},Fr="undefined"!=typeof window&&void 0!==window.MotionDebug,jr=["","X","Y","Z"],Or={visibility:"hidden"};let Ir=0;function Ur(t,e,n,i){const{latestValues:s}=e;s[t]&&(n[t]=s[t],e.setStaticValue(t,0),i&&(i[t]=0))}function Wr({attachResizeListener:t,defaultParent:e,measureScroll:n,checkIsScrollRoot:i,resetTransform:s}){return class{constructor(t={},n=(null==e?void 0:e())){this.id=Ir++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,Fr&&(Br.totalNodes=Br.resolvedTargetDeltas=Br.recalculatedProjection=0),this.nodes.forEach($r),this.nodes.forEach(qr),this.nodes.forEach(Zr),this.nodes.forEach(Hr),Fr&&window.MotionDebug.record(Br)},this.resolvedRelativeTargetAt=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=t,this.root=n?n.root||n:this,this.path=n?[...n.path,n]:[],this.parent=n,this.depth=n?n.depth+1:0;for(let t=0;t<this.path.length;t++)this.path[t].shouldResetTransform=!0;this.root===this&&(this.nodes=new Is)}addEventListener(t,e){return this.eventHandlers.has(t)||this.eventHandlers.set(t,new Bn),this.eventHandlers.get(t).add(e)}notifyListeners(t,...e){const n=this.eventHandlers.get(t);n&&n.notify(...e)}hasListeners(t){return this.eventHandlers.has(t)}mount(e,n=this.root.hasTreeAnimated){if(this.instance)return;this.isSVG=oo(e),this.instance=e;const{layoutId:i,layout:s,visualElement:o}=this.options;if(o&&!o.current&&o.mount(e),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),n&&(s||i)&&(this.isLayoutDirty=!0),t){let n;const i=()=>this.root.updateBlockedByResize=!1;t(e,()=>{this.root.updateBlockedByResize=!0,n&&n(),n=Ns(i,250),Ws.hasAnimatedSinceResize&&(Ws.hasAnimatedSinceResize=!1,this.nodes.forEach(_r))})}i&&this.root.registerSharedNode(i,this),!1!==this.options.animate&&o&&(i||s)&&this.addEventListener("didUpdate",({delta:t,hasLayoutChanged:e,hasRelativeTargetChanged:n,layout:i})=>{if(this.isTreeAnimationBlocked())return this.target=void 0,void(this.relativeTarget=void 0);const s=this.options.transition||o.getDefaultTransition()||ia,{onLayoutAnimationStart:r,onLayoutAnimationComplete:a}=o.getProps(),l=!this.targetLayout||!Ds(this.targetLayout,i)||n,u=!e&&n;if(this.options.layoutRoot||this.resumeFrom&&this.resumeFrom.instance||u||e&&(l||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(t,u);const e={...T(s,"layout"),onPlay:r,onComplete:a};(o.shouldReduceMotion||this.options.layoutRoot)&&(e.delay=0,e.type=!1),this.startAnimation(e)}else e||_r(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=i})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const t=this.getStack();t&&t.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,L(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(Jr),this.animationId++)}getTransformTemplate(){const{visualElement:t}=this.options;return t&&t.getProps().transformTemplate}willUpdate(t=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked())return void(this.options.onExitComplete&&this.options.onExitComplete());if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&function t(e){if(e.hasCheckedOptimisedAppear=!0,e.root===e)return;const{visualElement:n}=e.options;if(!n)return;const i=zn(n);if(window.MotionHasOptimisedAnimation(i,"transform")){const{layout:t,layoutId:n}=e.options;window.MotionCancelOptimisedAnimation(i,"transform",k,!(t||n))}const{parent:s}=e;s&&!s.hasCheckedOptimisedAppear&&t(s)}(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let t=0;t<this.path.length;t++){const e=this.path[t];e.shouldResetTransform=!0,e.updateScroll("snapshot"),e.options.layoutRoot&&e.willUpdate(!1)}const{layoutId:e,layout:n}=this.options;if(void 0===e&&!n)return;const i=this.getTransformTemplate();this.prevTransformTemplateValue=i?i(this.latestValues,""):void 0,this.updateSnapshot(),t&&this.notifyListeners("willUpdate")}update(){this.updateScheduled=!1;if(this.isUpdateBlocked())return this.unblockUpdate(),this.clearAllSnapshots(),void this.nodes.forEach(Xr);this.isUpdating||this.nodes.forEach(Kr),this.isUpdating=!1,this.nodes.forEach(Gr),this.nodes.forEach(Nr),this.nodes.forEach(zr),this.clearAllSnapshots();const t=le.now();B.delta=nt(0,1e3/60,t-B.timestamp),B.timestamp=t,B.isProcessing=!0,F.update.process(B),F.preRender.process(B),F.render.process(B),B.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,kr.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(Yr),this.sharedNodes.forEach(Qr)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,k.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){k.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){!this.snapshot&&this.instance&&(this.snapshot=this.measure())}updateLayout(){if(!this.instance)return;if(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead()||this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let t=0;t<this.path.length;t++){this.path[t].updateScroll()}const t=this.layout;this.layout=this.measure(!1),this.layoutCorrected={x:{min:0,max:0},y:{min:0,max:0}},this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:e}=this.options;e&&e.notify("LayoutMeasure",this.layout.layoutBox,t?t.layoutBox:void 0)}updateScroll(t="measure"){let e=Boolean(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===t&&(e=!1),e){const e=i(this.instance);this.scroll={animationId:this.root.animationId,phase:t,isRoot:e,offset:n(this.instance),wasRoot:this.scroll?this.scroll.isRoot:e}}}resetTransform(){if(!s)return;const t=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,e=this.projectionDelta&&!Cs(this.projectionDelta),n=this.getTransformTemplate(),i=n?n(this.latestValues,""):void 0,o=i!==this.prevTransformTemplateValue;t&&(e||_i(this.latestValues)||o)&&(s(this.instance,i),this.shouldResetTransform=!1,this.scheduleRender())}measure(t=!0){const e=this.measurePageBox();let n=this.removeElementScroll(e);var i;return t&&(n=this.removeTransform(n)),ra((i=n).x),ra(i.y),{animationId:this.root.animationId,measuredBox:e,layoutBox:n,latestValues:{},source:this.id}}measurePageBox(){var t;const{visualElement:e}=this.options;if(!e)return{x:{min:0,max:0},y:{min:0,max:0}};const n=e.measureViewportBox();if(!((null===(t=this.scroll)||void 0===t?void 0:t.wasRoot)||this.path.some(la))){const{scroll:t}=this.root;t&&(ns(n.x,t.offset.x),ns(n.y,t.offset.y))}return n}removeElementScroll(t){var e;const n={x:{min:0,max:0},y:{min:0,max:0}};if(ws(n,t),null===(e=this.scroll)||void 0===e?void 0:e.wasRoot)return n;for(let e=0;e<this.path.length;e++){const i=this.path[e],{scroll:s,options:o}=i;i!==this.root&&s&&o.layoutScroll&&(s.wasRoot&&ws(n,t),ns(n.x,s.offset.x),ns(n.y,s.offset.y))}return n}applyTransform(t,e=!1){const n={x:{min:0,max:0},y:{min:0,max:0}};ws(n,t);for(let t=0;t<this.path.length;t++){const i=this.path[t];!e&&i.options.layoutScroll&&i.scroll&&i!==i.root&&ss(n,{x:-i.scroll.offset.x,y:-i.scroll.offset.y}),_i(i.latestValues)&&ss(n,i.latestValues)}return _i(this.latestValues)&&ss(n,this.latestValues),n}removeTransform(t){const e={x:{min:0,max:0},y:{min:0,max:0}};ws(e,t);for(let t=0;t<this.path.length;t++){const n=this.path[t];if(!n.instance)continue;if(!_i(n.latestValues))continue;Gi(n.latestValues)&&n.updateSnapshot();const i={x:{min:0,max:0},y:{min:0,max:0}};ws(i,n.measurePageBox()),Es(e,n.latestValues,n.snapshot?n.snapshot.layoutBox:void 0,i)}return _i(this.latestValues)&&Es(e,this.latestValues),e}setTargetDelta(t){this.targetDelta=t,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(t){this.options={...this.options,...t,crossfade:void 0===t.crossfade||t.crossfade}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==B.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(t=!1){var e;const n=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=n.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=n.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=n.isSharedProjectionDirty);const i=Boolean(this.resumingFrom)||this!==n;if(!(t||i&&this.isSharedProjectionDirty||this.isProjectionDirty||(null===(e=this.parent)||void 0===e?void 0:e.isProjectionDirty)||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:s,layoutId:o}=this.options;if(this.layout&&(s||o)){if(this.resolvedRelativeTargetAt=B.timestamp,!this.targetDelta&&!this.relativeTarget){const t=this.getClosestProjectingParent();t&&t.layout&&1!==this.animationProgress?(this.relativeParent=t,this.forceRelativeParentToResolveTarget(),this.relativeTarget={x:{min:0,max:0},y:{min:0,max:0}},this.relativeTargetOrigin={x:{min:0,max:0},y:{min:0,max:0}},Ii(this.relativeTargetOrigin,this.layout.layoutBox,t.layout.layoutBox),ws(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(this.relativeTarget||this.targetDelta){var r,a,l;if(this.target||(this.target={x:{min:0,max:0},y:{min:0,max:0}},this.targetWithTransforms={x:{min:0,max:0},y:{min:0,max:0}}),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),r=this.target,a=this.relativeTarget,l=this.relativeParent.target,ji(r.x,a.x,l.x),ji(r.y,a.y,l.y)):this.targetDelta?(Boolean(this.resumingFrom)?this.target=this.applyTransform(this.layout.layoutBox):ws(this.target,this.layout.layoutBox),es(this.target,this.targetDelta)):ws(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget){this.attemptToResolveRelativeTarget=!1;const t=this.getClosestProjectingParent();t&&Boolean(t.resumingFrom)===Boolean(this.resumingFrom)&&!t.options.layoutScroll&&t.target&&1!==this.animationProgress?(this.relativeParent=t,this.forceRelativeParentToResolveTarget(),this.relativeTarget={x:{min:0,max:0},y:{min:0,max:0}},this.relativeTargetOrigin={x:{min:0,max:0},y:{min:0,max:0}},Ii(this.relativeTargetOrigin,this.target,t.target),ws(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}Fr&&Br.resolvedTargetDeltas++}}}getClosestProjectingParent(){if(this.parent&&!Gi(this.parent.latestValues)&&!qi(this.parent.latestValues))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return Boolean((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){var t;const e=this.getLead(),n=Boolean(this.resumingFrom)||this!==e;let i=!0;if((this.isProjectionDirty||(null===(t=this.parent)||void 0===t?void 0:t.isProjectionDirty))&&(i=!1),n&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(i=!1),this.resolvedRelativeTargetAt===B.timestamp&&(i=!1),i)return;const{layout:s,layoutId:o}=this.options;if(this.isTreeAnimating=Boolean(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!s&&!o)return;ws(this.layoutCorrected,this.layout.layoutBox);const r=this.treeScale.x,a=this.treeScale.y;!function(t,e,n,i=!1){const s=n.length;if(!s)return;let o,r;e.x=e.y=1;for(let a=0;a<s;a++){o=n[a],r=o.projectionDelta;const{visualElement:s}=o.options;s&&s.props.style&&"contents"===s.props.style.display||(i&&o.options.layoutScroll&&o.scroll&&o!==o.root&&ss(t,{x:-o.scroll.offset.x,y:-o.scroll.offset.y}),r&&(e.x*=r.x.scale,e.y*=r.y.scale,es(t,r)),i&&_i(o.latestValues)&&ss(t,o.latestValues))}e.x<1.0000000000001&&e.x>.999999999999&&(e.x=1),e.y<1.0000000000001&&e.y>.999999999999&&(e.y=1)}(this.layoutCorrected,this.treeScale,this.path,n),!e.layout||e.target||1===this.treeScale.x&&1===this.treeScale.y||(e.target=e.layout.layoutBox,e.targetWithTransforms={x:{min:0,max:0},y:{min:0,max:0}});const{target:l}=e;l?(this.projectionDelta&&this.prevProjectionDelta?(Ps(this.prevProjectionDelta.x,this.projectionDelta.x),Ps(this.prevProjectionDelta.y,this.projectionDelta.y)):this.createProjectionDeltas(),Fi(this.projectionDelta,this.layoutCorrected,l,this.latestValues),this.treeScale.x===r&&this.treeScale.y===a&&Ls(this.projectionDelta.x,this.prevProjectionDelta.x)&&Ls(this.projectionDelta.y,this.prevProjectionDelta.y)||(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",l)),Fr&&Br.recalculatedProjection++):this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender())}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(t=!0){var e;if(null===(e=this.options.visualElement)||void 0===e||e.scheduleRender(),t){const t=this.getStack();t&&t.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}},this.projectionDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}},this.projectionDeltaWithTransform={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}}}setAnimationOrigin(t,e=!1){const n=this.snapshot,i=n?n.latestValues:{},s={...this.latestValues},o={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};this.relativeParent&&this.relativeParent.options.layoutRoot||(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!e;const r={x:{min:0,max:0},y:{min:0,max:0}},a=(n?n.source:void 0)!==(this.layout?this.layout.source:void 0),l=this.getStack(),u=!l||l.members.length<=1,c=Boolean(a&&!u&&!0===this.options.crossfade&&!this.path.some(na));let h;this.animationProgress=0,this.mixTargetDelta=e=>{const n=e/1e3;var l,d;ta(o.x,t.x,n),ta(o.y,t.y,n),this.setTargetDelta(o),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(Ii(r,this.layout.layoutBox,this.relativeParent.layout.layoutBox),function(t,e,n,i){ea(t.x,e.x,n.x,i),ea(t.y,e.y,n.y,i)}(this.relativeTarget,this.relativeTargetOrigin,r,n),h&&(l=this.relativeTarget,d=h,Vs(l.x,d.x)&&Vs(l.y,d.y))&&(this.isProjectionDirty=!1),h||(h={x:{min:0,max:0},y:{min:0,max:0}}),ws(h,this.relativeTarget)),a&&(this.animationValues=s,function(t,e,n,i,s,o){s?(t.opacity=Xe(0,void 0!==n.opacity?n.opacity:1,gs(i)),t.opacityExit=Xe(void 0!==e.opacity?e.opacity:1,0,ys(i))):o&&(t.opacity=Xe(void 0!==e.opacity?e.opacity:1,void 0!==n.opacity?n.opacity:1,i));for(let s=0;s<ds;s++){const o=`border${hs[s]}Radius`;let r=fs(e,o),a=fs(n,o);if(void 0===r&&void 0===a)continue;r||(r=0),a||(a=0);0===r||0===a||ms(r)===ms(a)?(t[o]=Math.max(Xe(ps(r),ps(a),i),0),(lt.test(a)||lt.test(r))&&(t[o]+="%")):t[o]=a}(e.rotate||n.rotate)&&(t.rotate=Xe(e.rotate||0,n.rotate||0,i))}(s,i,this.latestValues,n,c,u)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=n},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(t){this.notifyListeners("animationStart"),this.currentAnimation&&this.currentAnimation.stop(),this.resumingFrom&&this.resumingFrom.currentAnimation&&this.resumingFrom.currentAnimation.stop(),this.pendingAnimation&&(L(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=k.update(()=>{Ws.hasAnimatedSinceResize=!0,this.currentAnimation=Wo(0,1e3,{...t,onUpdate:e=>{this.mixTargetDelta(e),t.onUpdate&&t.onUpdate(e)},onComplete:()=>{t.onComplete&&t.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const t=this.getStack();t&&t.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(1e3),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const t=this.getLead();let{targetWithTransforms:e,target:n,layout:i,latestValues:s}=t;if(e&&n&&i){if(this!==t&&this.layout&&i&&aa(this.options.animationType,this.layout.layoutBox,i.layoutBox)){n=this.target||{x:{min:0,max:0},y:{min:0,max:0}};const e=Li(this.layout.layoutBox.x);n.x.min=t.target.x.min,n.x.max=n.x.min+e;const i=Li(this.layout.layoutBox.y);n.y.min=t.target.y.min,n.y.max=n.y.min+i}ws(e,n),ss(e,s),Fi(this.projectionDeltaWithTransform,this.layoutCorrected,e,s)}}registerSharedNode(t,e){this.sharedNodes.has(t)||this.sharedNodes.set(t,new Bs);this.sharedNodes.get(t).add(e);const n=e.options.initialPromotionConfig;e.promote({transition:n?n.transition:void 0,preserveFollowOpacity:n&&n.shouldPreserveFollowOpacity?n.shouldPreserveFollowOpacity(e):void 0})}isLead(){const t=this.getStack();return!t||t.lead===this}getLead(){var t;const{layoutId:e}=this.options;return e&&(null===(t=this.getStack())||void 0===t?void 0:t.lead)||this}getPrevLead(){var t;const{layoutId:e}=this.options;return e?null===(t=this.getStack())||void 0===t?void 0:t.prevLead:void 0}getStack(){const{layoutId:t}=this.options;if(t)return this.root.sharedNodes.get(t)}promote({needsReset:t,transition:e,preserveFollowOpacity:n}={}){const i=this.getStack();i&&i.promote(this,n),t&&(this.projectionDelta=void 0,this.needsReset=!0),e&&this.setOptions({transition:e})}relegate(){const t=this.getStack();return!!t&&t.relegate(this)}resetSkewAndRotation(){const{visualElement:t}=this.options;if(!t)return;let e=!1;const{latestValues:n}=t;if((n.z||n.rotate||n.rotateX||n.rotateY||n.rotateZ||n.skewX||n.skewY)&&(e=!0),!e)return;const i={};n.z&&Ur("z",t,i,this.animationValues);for(let e=0;e<jr.length;e++)Ur("rotate"+jr[e],t,i,this.animationValues),Ur("skew"+jr[e],t,i,this.animationValues);t.render();for(const e in i)t.setStaticValue(e,i[e]),this.animationValues&&(this.animationValues[e]=i[e]);t.scheduleRender()}getProjectionStyles(t){var e,n;if(!this.instance||this.isSVG)return;if(!this.isVisible)return Or;const i={visibility:""},s=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,i.opacity="",i.pointerEvents=Us(null==t?void 0:t.pointerEvents)||"",i.transform=s?s(this.latestValues,""):"none",i;const o=this.getLead();if(!this.projectionDelta||!this.layout||!o.target){const e={};return this.options.layoutId&&(e.opacity=void 0!==this.latestValues.opacity?this.latestValues.opacity:1,e.pointerEvents=Us(null==t?void 0:t.pointerEvents)||""),this.hasProjected&&!_i(this.latestValues)&&(e.transform=s?s({},""):"none",this.hasProjected=!1),e}const r=o.animationValues||o.latestValues;this.applyTransformsToTarget(),i.transform=function(t,e,n){let i="";const s=t.x.translate/e.x,o=t.y.translate/e.y,r=(null==n?void 0:n.z)||0;if((s||o||r)&&(i=`translate3d(${s}px, ${o}px, ${r}px) `),1===e.x&&1===e.y||(i+=`scale(${1/e.x}, ${1/e.y}) `),n){const{transformPerspective:t,rotate:e,rotateX:s,rotateY:o,skewX:r,skewY:a}=n;t&&(i=`perspective(${t}px) ${i}`),e&&(i+=`rotate(${e}deg) `),s&&(i+=`rotateX(${s}deg) `),o&&(i+=`rotateY(${o}deg) `),r&&(i+=`skewX(${r}deg) `),a&&(i+=`skewY(${a}deg) `)}const a=t.x.scale*e.x,l=t.y.scale*e.y;return 1===a&&1===l||(i+=`scale(${a}, ${l})`),i||"none"}(this.projectionDeltaWithTransform,this.treeScale,r),s&&(i.transform=s(r,i.transform));const{x:a,y:l}=this.projectionDelta;i.transformOrigin=`${100*a.origin}% ${100*l.origin}% 0`,o.animationValues?i.opacity=o===this?null!==(n=null!==(e=r.opacity)&&void 0!==e?e:this.latestValues.opacity)&&void 0!==n?n:1:this.preserveOpacity?this.latestValues.opacity:r.opacityExit:i.opacity=o===this?void 0!==r.opacity?r.opacity:"":void 0!==r.opacityExit?r.opacityExit:0;for(const t in Fs){if(void 0===r[t])continue;const{correct:e,applyTo:n}=Fs[t],s="none"===i.transform?r[t]:e(r[t],o);if(n){const t=n.length;for(let e=0;e<t;e++)i[n[e]]=s}else i[t]=s}return this.options.layoutId&&(i.pointerEvents=o===this?Us(null==t?void 0:t.pointerEvents)||"":"none"),i}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(t=>{var e;return null===(e=t.currentAnimation)||void 0===e?void 0:e.stop()}),this.root.nodes.forEach(Xr),this.root.sharedNodes.clear()}}}function Nr(t){t.updateLayout()}function zr(t){var e;const n=(null===(e=t.resumeFrom)||void 0===e?void 0:e.snapshot)||t.snapshot;if(t.isLead()&&t.layout&&n&&t.hasListeners("didUpdate")){const{layoutBox:e,measuredBox:i}=t.layout,{animationType:s}=t.options,o=n.source!==t.layout.source;"size"===s?Yi(t=>{const i=o?n.measuredBox[t]:n.layoutBox[t],s=Li(i);i.min=e[t].min,i.max=i.min+s}):aa(s,n.layoutBox,e)&&Yi(i=>{const s=o?n.measuredBox[i]:n.layoutBox[i],r=Li(e[i]);s.max=s.min+r,t.relativeTarget&&!t.currentAnimation&&(t.isProjectionDirty=!0,t.relativeTarget[i].max=t.relativeTarget[i].min+r)});const r={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};Fi(r,e,n.layoutBox);const a={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};o?Fi(a,t.applyTransform(i,!0),n.measuredBox):Fi(a,e,n.layoutBox);const l=!Cs(r);let u=!1;if(!t.resumeFrom){const i=t.getClosestProjectingParent();if(i&&!i.resumeFrom){const{snapshot:s,layout:o}=i;if(s&&o){const r={x:{min:0,max:0},y:{min:0,max:0}};Ii(r,n.layoutBox,s.layoutBox);const a={x:{min:0,max:0},y:{min:0,max:0}};Ii(a,e,o.layoutBox),Ds(r,a)||(u=!0),i.options.layoutRoot&&(t.relativeTarget=a,t.relativeTargetOrigin=r,t.relativeParent=i)}}}t.notifyListeners("didUpdate",{layout:e,snapshot:n,delta:a,layoutDelta:r,hasLayoutChanged:l,hasRelativeTargetChanged:u})}else if(t.isLead()){const{onExitComplete:e}=t.options;e&&e()}t.options.transition=void 0}function $r(t){Fr&&Br.totalNodes++,t.parent&&(t.isProjecting()||(t.isProjectionDirty=t.parent.isProjectionDirty),t.isSharedProjectionDirty||(t.isSharedProjectionDirty=Boolean(t.isProjectionDirty||t.parent.isProjectionDirty||t.parent.isSharedProjectionDirty)),t.isTransformDirty||(t.isTransformDirty=t.parent.isTransformDirty))}function Hr(t){t.isProjectionDirty=t.isSharedProjectionDirty=t.isTransformDirty=!1}function Yr(t){t.clearSnapshot()}function Xr(t){t.clearMeasurements()}function Kr(t){t.isLayoutDirty=!1}function Gr(t){const{visualElement:e}=t.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),t.resetTransform()}function _r(t){t.finishAnimation(),t.targetDelta=t.relativeTarget=t.target=void 0,t.isProjectionDirty=!0}function qr(t){t.resolveTargetDelta()}function Zr(t){t.calcProjection()}function Jr(t){t.resetSkewAndRotation()}function Qr(t){t.removeLeadSnapshot()}function ta(t,e,n){t.translate=Xe(e.translate,0,n),t.scale=Xe(e.scale,1,n),t.origin=e.origin,t.originPoint=e.originPoint}function ea(t,e,n,i){t.min=Xe(e.min,n.min,i),t.max=Xe(e.max,n.max,i)}function na(t){return t.animationValues&&void 0!==t.animationValues.opacityExit}const ia={duration:.45,ease:[.4,0,.1,1]},sa=t=>"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(t),oa=sa("applewebkit/")&&!sa("chrome/")?Math.round:M;function ra(t){t.min=oa(t.min),t.max=oa(t.max)}function aa(t,e,n){return"position"===t||"preserve-aspect"===t&&(i=ks(e),s=ks(n),o=.2,!(Math.abs(i-s)<=o));var i,s,o}function la(t){var e;return t!==t.root&&(null===(e=t.scroll)||void 0===e?void 0:e.wasRoot)}const ua=Wr({attachResizeListener:(t,e)=>Pi(t,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),ca={current:void 0},ha=Wr({measureScroll:t=>({x:t.scrollLeft,y:t.scrollTop}),defaultParent:()=>{if(!ca.current){const t=new ua({});t.mount(window),t.setOptions({layoutScroll:!0}),ca.current=t}return ca.current},resetTransform:(t,e)=>{t.style.transform=void 0!==e?e:"none"},checkIsScrollRoot:t=>Boolean("fixed"===window.getComputedStyle(t).position)}),da=t=>!t.isLayoutDirty&&t.willUpdate(!1);function pa(){const t=new Set,e=new WeakMap,n=()=>t.forEach(da);return{add:i=>{t.add(i),e.set(i,i.addEventListener("willUpdate",n))},remove:i=>{t.delete(i);const s=e.get(i);s&&(s(),e.delete(i)),n()},dirty:n}}function ma(t,e){return e.max===e.min?0:t/(e.max-e.min)*100}const fa={correct:(t,e)=>{if(!e.target)return t;if("string"==typeof t){if(!ut.test(t))return t;t=parseFloat(t)}return`${ma(t,e.target.x)}% ${ma(t,e.target.y)}%`}},ga={correct:(t,{treeScale:e,projectionDelta:n})=>{const i=t,s=Yt.parse(t);if(s.length>5)return i;const o=Yt.createTransformer(t),r="number"!=typeof s[0]?1:0,a=n.x.scale*e.x,l=n.y.scale*e.y;s[0+r]/=a,s[1+r]/=l;const u=Xe(a,l,.5);return"number"==typeof s[2+r]&&(s[2+r]/=u),"number"==typeof s[3+r]&&(s[3+r]/=u),o(s)}};var ya=React,va=Symbol.for("react.element"),xa=Symbol.for("react.fragment"),wa=Object.prototype.hasOwnProperty,Pa=ya.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,Ta={key:!0,ref:!0,__self:!0,__source:!0};function Sa(t,e,n){var i,s={},o=null,r=null;for(i in void 0!==n&&(o=""+n),void 0!==e.key&&(o=""+e.key),void 0!==e.ref&&(r=e.ref),e)wa.call(e,i)&&!Ta.hasOwnProperty(i)&&(s[i]=e[i]);if(t&&t.defaultProps)for(i in e=t.defaultProps)void 0===s[i]&&(s[i]=e[i]);return{$$typeof:va,type:t,key:o,ref:r,props:s,_owner:Pa.current}}const ba=xa,Aa=Sa,Ea=Sa,Ma=e.createContext(null);function Ca(){const t=e.useContext(Ma);if(null===t)return[!0,null];const{isPresent:n,onExitComplete:i,register:s}=t,o=e.useId();e.useEffect(()=>s(o),[]);const r=e.useCallback(()=>i&&i(o),[o,i]);return!n&&i?[!1,r]:[!0]}const Va=e.createContext({}),Ra=e.createContext({});class Da extends e.Component{componentDidMount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:n,layoutId:i}=this.props,{projection:s}=t;js(La),s&&(e.group&&e.group.add(s),n&&n.register&&i&&n.register(s),s.root.didUpdate(),s.addEventListener("animationComplete",()=>{this.safeToRemove()}),s.setOptions({...s.options,onExitComplete:()=>this.safeToRemove()})),Ws.hasEverUpdated=!0}getSnapshotBeforeUpdate(t){const{layoutDependency:e,visualElement:n,drag:i,isPresent:s}=this.props,o=n.projection;return o?(o.isPresent=s,i||t.layoutDependency!==e||void 0===e?o.willUpdate():this.safeToRemove(),t.isPresent!==s&&(s?o.promote():o.relegate()||k.postRender(()=>{const t=o.getStack();t&&t.members.length||this.safeToRemove()})),null):null}componentDidUpdate(){const{projection:t}=this.props.visualElement;t&&(t.root.didUpdate(),kr.postRender(()=>{!t.currentAnimation&&t.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:n}=this.props,{projection:i}=t;i&&(i.scheduleCheckAfterUnmount(),e&&e.group&&e.group.remove(i),n&&n.deregister&&n.deregister(i))}safeToRemove(){const{safeToRemove:t}=this.props;t&&t()}render(){return null}}function ka(t){const[n,i]=Ca(),s=e.useContext(Va);return Aa(Da,{...t,layoutGroup:s,switchLayoutGroup:e.useContext(Ra),isPresent:n,safeToRemove:i})}const La={borderRadius:{...fa,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:fa,borderTopRightRadius:fa,borderBottomLeftRadius:fa,borderBottomRightRadius:fa,boxShadow:ga},Ba={pan:{Feature:class extends ii{constructor(){super(...arguments),this.removePointerDownListener=M}onPointerDown(t){this.session=new Ai(t,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:rs(this.node)})}createPanHandlers(){const{onPanSessionStart:t,onPanStart:e,onPan:n,onPanEnd:i}=this.node.getProps();return{onSessionStart:cs(t),onStart:cs(e),onMove:n,onEnd:(t,e)=>{delete this.session,i&&k.postRender(()=>i(t,e))}}}mount(){this.removePointerDownListener=Ti(this.node.current,"pointerdown",t=>this.onPointerDown(t))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}},drag:{Feature:class extends ii{constructor(t){super(t),this.removeGroupControls=M,this.removeListeners=M,this.controls=new ls(t)}mount(){const{dragControls:t}=this.node.getProps();t&&(this.removeGroupControls=t.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||M}unmount(){this.removeGroupControls(),this.removeListeners()}},ProjectionNode:ha,MeasureLayout:ka}};function Fa(t,e,n){const{props:i}=t;t.animationState&&i.whileHover&&t.animationState.setActive("whileHover","Start"===n);const s=i["onHover"+n];s&&k.postRender(()=>s(e,xi(e)))}function ja(t,e,n){const{props:i}=t;t.animationState&&i.whileTap&&t.animationState.setActive("whileTap","Start"===n);const s=i["onTap"+("End"===n?"":n)];s&&k.postRender(()=>s(e,xi(e)))}const Oa=new WeakMap,Ia=new WeakMap,Ua=t=>{const e=Oa.get(t.target);e&&e(t)},Wa=t=>{t.forEach(Ua)};function Na(t,e,n){const i=function({root:t,...e}){const n=t||document;Ia.has(n)||Ia.set(n,{});const i=Ia.get(n),s=JSON.stringify(e);return i[s]||(i[s]=new IntersectionObserver(Wa,{root:t,...e})),i[s]}(e);return Oa.set(t,n),i.observe(t),()=>{Oa.delete(t),i.unobserve(t)}}const za={some:0,all:1};const $a={inView:{Feature:class extends ii{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:t={}}=this.node.getProps(),{root:e,margin:n,amount:i="some",once:s}=t,o={root:e?e.current:void 0,rootMargin:n,threshold:"number"==typeof i?i:za[i]};return Na(this.node.current,o,t=>{const{isIntersecting:e}=t;if(this.isInView===e)return;if(this.isInView=e,s&&!e&&this.hasEnteredView)return;e&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",e);const{onViewportEnter:n,onViewportLeave:i}=this.node.getProps(),o=e?n:i;o&&o(t)})}mount(){this.startObserver()}update(){if("undefined"==typeof IntersectionObserver)return;const{props:t,prevProps:e}=this.node;["amount","margin","root"].some(function({viewport:t={}},{viewport:e={}}={}){return n=>t[n]!==e[n]}(t,e))&&this.startObserver()}unmount(){}}},tap:{Feature:class extends ii{mount(){const{current:t}=this.node;t&&(this.unmount=vi(t,t=>(ja(this.node,t,"Start"),(t,{success:e})=>ja(this.node,t,e?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}},focus:{Feature:class extends ii{constructor(){super(...arguments),this.isActive=!1}onFocus(){let t=!1;try{t=this.node.current.matches(":focus-visible")}catch(e){t=!0}t&&this.node.animationState&&(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){this.isActive&&this.node.animationState&&(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=Ye(Pi(this.node.current,"focus",()=>this.onFocus()),Pi(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}},hover:{Feature:class extends ii{mount(){const{current:t}=this.node;t&&(this.unmount=function(t,e,n={}){const[i,s,o]=ui(t,n),r=ci(t=>{const{target:n}=t,i=e(t);if(!i||!n)return;const o=ci(t=>{i(t),n.removeEventListener("pointerleave",o)});n.addEventListener("pointerleave",o,s)});return i.forEach(t=>{t.addEventListener("pointerenter",r,s)}),o}(t,t=>(Fa(this.node,t,"Start"),t=>Fa(this.node,t,"End"))))}unmount(){}}}},Ha={layout:{ProjectionNode:ha,MeasureLayout:ka}},Ya=e.createContext({transformPagePoint:t=>t,isStatic:!1,reducedMotion:"never"}),Xa=e.createContext({}),Ka=uo?e.useLayoutEffect:e.useEffect,Ga=e.createContext({strict:!1});function _a(t,n,i,s,o){var r,a;const{visualElement:l}=e.useContext(Xa),u=e.useContext(Ga),c=e.useContext(Ma),h=e.useContext(Ya).reducedMotion,d=e.useRef(null);s=s||u.renderer,!d.current&&s&&(d.current=s(t,{visualState:n,parent:l,props:i,presenceContext:c,blockInitialAnimation:!!c&&!1===c.initial,reducedMotionConfig:h}));const p=d.current,m=e.useContext(Ra);!p||p.projection||!o||"html"!==p.type&&"svg"!==p.type||function(t,e,n,i){const{layoutId:s,layout:o,drag:r,dragConstraints:a,layoutScroll:l,layoutRoot:u}=e;t.projection=new n(t.latestValues,e["data-framer-portal-id"]?void 0:function t(e){return e?!1!==e.options.allowProjection?e.projection:t(e.parent):void 0}(t.parent)),t.projection.setOptions({layoutId:s,layout:o,alwaysMeasureLayout:Boolean(r)||a&&ki(a),visualElement:t,animationType:"string"==typeof o?o:"both",initialPromotionConfig:i,layoutScroll:l,layoutRoot:u})}(d.current,i,o,m);const f=e.useRef(!1);e.useInsertionEffect(()=>{p&&f.current&&p.update(i,c)});const g=i[Nn],y=e.useRef(Boolean(g)&&!(null===(r=window.MotionHandoffIsComplete)||void 0===r?void 0:r.call(window,g))&&(null===(a=window.MotionHasOptimisedAnimation)||void 0===a?void 0:a.call(window,g)));return Ka(()=>{p&&(f.current=!0,window.MotionIsMounted=!0,p.updateFeatures(),kr.render(p.render),y.current&&p.animationState&&p.animationState.animateChanges())}),e.useEffect(()=>{p&&(!y.current&&p.animationState&&p.animationState.animateChanges(),y.current&&(queueMicrotask(()=>{var t;null===(t=window.MotionHandoffMarkAsComplete)||void 0===t||t.call(window,g)}),y.current=!1))}),p}function qa(t,n,i){return e.useCallback(e=>{e&&t.mount&&t.mount(e),n&&(e?n.mount(e):n.unmount()),i&&("function"==typeof i?i(e):ki(i)&&(i.current=e))},[n])}function Za(t){const{initial:n,animate:i}=function(t,e){if(mo(t)){const{initial:e,animate:n}=t;return{initial:!1===e||l(e)?e:void 0,animate:l(n)?n:void 0}}return!1!==t.inherit?e:{}}(t,e.useContext(Xa));return e.useMemo(()=>({initial:n,animate:i}),[Ja(n),Ja(i)])}function Ja(t){return Array.isArray(t)?t.join(" "):t}function Qa(t){for(const e in t)yo[e]={...yo[e],...t[e]}}const tl=Symbol.for("motionComponentSymbol");function el({preloadedFeatures:t,createVisualElement:n,useRender:i,useVisualState:s,Component:o}){t&&Qa(t);const r=e.forwardRef((function(t,r){let a;const l={...e.useContext(Ya),...t,layoutId:nl(t)},{isStatic:u}=l,c=Za(t),h=s(t,u);if(!u&&uo){e.useContext(Ga).strict;const t=function(t){const{drag:e,layout:n}=yo;if(!e&&!n)return{};const i={...e,...n};return{MeasureLayout:(null==e?void 0:e.isEnabled(t))||(null==n?void 0:n.isEnabled(t))?i.MeasureLayout:void 0,ProjectionNode:i.ProjectionNode}}(l);a=t.MeasureLayout,c.visualElement=_a(o,h,l,n,t.ProjectionNode)}return Ea(Xa.Provider,{value:c,children:[a&&c.visualElement?Aa(a,{visualElement:c.visualElement,...l}):null,i(o,t,qa(h,c.visualElement,r),h,u,c.visualElement)]})}));return r[tl]=o,r}function nl({layoutId:t}){const n=e.useContext(Va).id;return n&&void 0!==t?n+"-"+t:t}const il=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function sl(t){return"string"==typeof t&&!t.includes("-")&&!!(il.indexOf(t)>-1||/[A-Z]/u.test(t))}function ol(t){const n=e.useRef(null);return null===n.current&&(n.current=t()),n.current}const rl=t=>(n,i)=>{const s=e.useContext(Xa),o=e.useContext(Ma),r=()=>function({scrapeMotionValuesFromProps:t,createRenderState:e,onMount:n},i,s,o){const r={latestValues:al(i,s,o,t),renderState:e()};return n&&(r.mount=t=>n(i,t,r)),r}(t,n,s,o);return i?r():ol(r)};function al(t,e,n,i){const s={},r=i(t,{});for(const t in r)s[t]=Us(r[t]);let{initial:a,animate:l}=t;const u=mo(t),h=fo(t);e&&h&&!u&&!1!==t.inherit&&(void 0===a&&(a=e.initial),void 0===l&&(l=e.animate));let d=!!n&&!1===n.initial;d=d||!1===a;const p=d?l:a;if(p&&"boolean"!=typeof p&&!o(p)){const e=Array.isArray(p)?p:[p];for(let n=0;n<e.length;n++){const i=c(t,e[n]);if(i){const{transitionEnd:t,transition:e,...n}=i;for(const t in n){let e=n[t];if(Array.isArray(e)){e=e[d?e.length-1:0]}null!==e&&(s[t]=e)}for(const e in t)s[e]=t[e]}}}return s}const ll=()=>({style:{},transform:{},transformOrigin:{},vars:{}}),ul=()=>({style:{},transform:{},transformOrigin:{},vars:{},attrs:{}}),cl={useVisualState:rl({scrapeMotionValuesFromProps:lo,createRenderState:ul,onMount:(t,e,{renderState:n,latestValues:i})=>{k.read(()=>{try{n.dimensions="function"==typeof e.getBBox?e.getBBox():e.getBoundingClientRect()}catch(t){n.dimensions={x:0,y:0,width:0,height:0}}}),k.render(()=>{Ro(n,i,Bo(e.tagName),t.transformTemplate),Lo(e,n)})}})},hl={useVisualState:rl({scrapeMotionValuesFromProps:ao,createRenderState:ll})};function dl(t,e,n){for(const i in e)$n(e[i])||ro(i,n)||(t[i]=e[i])}function pl(t,n){const i={};return dl(i,t.style||{},t),Object.assign(i,function({transformTemplate:t},n){return e.useMemo(()=>{const e={style:{},transform:{},transformOrigin:{},vars:{}};return Eo(e,n,t),Object.assign({},e.vars,e.style)},[n])}(t,n)),i}function ml(t,e){const n={},i=pl(t,e);return t.drag&&!1!==t.dragListener&&(n.draggable=!1,i.userSelect=i.WebkitUserSelect=i.WebkitTouchCallout="none",i.touchAction=!0===t.drag?"none":"pan-"+("x"===t.drag?"y":"x")),void 0===t.tabIndex&&(t.onTap||t.onTapStart||t.whileTap)&&(n.tabIndex=0),n.style=i,n}const fl=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function gl(t){return t.startsWith("while")||t.startsWith("drag")&&"draggable"!==t||t.startsWith("layout")||t.startsWith("onTap")||t.startsWith("onPan")||t.startsWith("onLayout")||fl.has(t)}let yl=t=>!gl(t);function vl(t){t&&(yl=e=>e.startsWith("on")?!gl(e):t(e))}try{vl(require("@emotion/is-prop-valid").default)}catch(t){}function xl(t,e,n){const i={};for(const s in t)"values"===s&&"object"==typeof t.values||(yl(s)||!0===n&&gl(s)||!e&&!gl(s)||t.draggable&&s.startsWith("onDrag"))&&(i[s]=t[s]);return i}function wl(t,n,i,s){const o=e.useMemo(()=>{const e={style:{},transform:{},transformOrigin:{},vars:{},attrs:{}};return Ro(e,n,Bo(s),t.transformTemplate),{...e.attrs,style:{...e.style}}},[n]);if(t.style){const e={};dl(e,t.style,t),o.style={...e,...o.style}}return o}function Pl(t=!1){return(n,i,s,{latestValues:o},r)=>{const a=(sl(n)?wl:ml)(i,o,r,n),l=xl(i,"string"==typeof n,t),u=n!==e.Fragment?{...l,...a,ref:s}:{},{children:c}=i,h=e.useMemo(()=>$n(c)?c.get():c,[c]);return e.createElement(n,{...u,children:h})}}function Tl(t,e){return function(n,{forwardMotionProps:i}={forwardMotionProps:!1}){return el({...sl(n)?cl:hl,preloadedFeatures:t,useRender:Pl(i),createVisualElement:e,Component:n})}}const Sl=(t,n)=>sl(t)?new Fo(n):new jo(n,{allowProjection:t!==e.Fragment}),bl=s(Tl({...oi,...$a,...Ba,...Ha},Sl)),Al=s(Tl());class El extends i.Component{getSnapshotBeforeUpdate(t){const e=this.props.childRef.current;if(e&&t.isPresent&&!this.props.isPresent){const t=this.props.sizeRef.current;t.height=e.offsetHeight||0,t.width=e.offsetWidth||0,t.top=e.offsetTop,t.left=e.offsetLeft}return null}componentDidUpdate(){}render(){return this.props.children}}function Ml({children:t,isPresent:n}){const s=e.useId(),o=e.useRef(null),r=e.useRef({width:0,height:0,top:0,left:0}),{nonce:a}=e.useContext(Ya);return e.useInsertionEffect(()=>{const{width:t,height:e,top:i,left:l}=r.current;if(n||!o.current||!t||!e)return;o.current.dataset.motionPopId=s;const u=document.createElement("style");return a&&(u.nonce=a),document.head.appendChild(u),u.sheet&&u.sheet.insertRule(`\n          [data-motion-pop-id="${s}"] {\n            position: absolute !important;\n            width: ${t}px !important;\n            height: ${e}px !important;\n            top: ${i}px !important;\n            left: ${l}px !important;\n          }\n        `),()=>{document.head.removeChild(u)}},[n]),Aa(El,{isPresent:n,childRef:o,sizeRef:r,children:i.cloneElement(t,{ref:o})})}const Cl=({children:t,initial:n,isPresent:s,onExitComplete:o,custom:r,presenceAffectsLayout:a,mode:l})=>{const u=ol(Vl),c=e.useId(),h=e.useCallback(t=>{u.set(t,!0);for(const t of u.values())if(!t)return;o&&o()},[u,o]),d=e.useMemo(()=>({id:c,initial:n,isPresent:s,custom:r,onExitComplete:h,register:t=>(u.set(t,!1),()=>u.delete(t))}),a?[Math.random(),h]:[s,h]);return e.useMemo(()=>{u.forEach((t,e)=>u.set(e,!1))},[s]),i.useEffect(()=>{!s&&!u.size&&o&&o()},[s]),"popLayout"===l&&(t=Aa(Ml,{isPresent:s,children:t})),Aa(Ma.Provider,{value:d,children:t})};function Vl(){return new Map}function Rl(t){return e.useEffect(()=>()=>t(),[])}function Dl(){const t=function(){const t=e.useRef(!1);return Ka(()=>(t.current=!0,()=>{t.current=!1}),[]),t}(),[n,i]=e.useState(0),s=e.useCallback(()=>{t.current&&i(n+1)},[n]);return[e.useCallback(()=>k.postRender(s),[s]),n]}const kl=t=>t.key||"";function Ll(t){const n=[];return e.Children.forEach(t,t=>{e.isValidElement(t)&&n.push(t)}),n}function Bl(t){return"function"==typeof t}const Fl=e.createContext(null),jl=t=>!0===t,Ol=({children:t,id:n,inherit:i=!0})=>{const s=e.useContext(Va),o=e.useContext(Fl),[r,a]=Dl(),l=e.useRef(null),u=s.id||o;null===l.current&&((t=>jl(!0===t)||"id"===t)(i)&&u&&(n=n?u+"-"+n:u),l.current={id:n,group:jl(i)&&s.group||pa()});const c=e.useMemo(()=>({...l.current,forceRender:r}),[a]);return Aa(Va.Provider,{value:c,children:t})},Il=e.createContext(null);function Ul({children:t,as:n="ul",axis:i="y",onReorder:s,values:o,...r},a){const l=ol(()=>bl[n]),u=[],c=e.useRef(!1),h={axis:i,registerItem:(t,e)=>{const n=u.findIndex(e=>t===e.value);-1!==n?u[n].layout=e[i]:u.push({value:t,layout:e[i]}),u.sort(zl)},updateOrder:(t,e,n)=>{if(c.current)return;const i=function(t,e,n,i){if(!i)return t;const s=t.findIndex(t=>t.value===e);if(-1===s)return t;const o=i>0?1:-1,r=t[s+o];if(!r)return t;const a=t[s],l=r.layout,u=Xe(l.min,l.max,.5);return 1===o&&a.layout.max+n>u||-1===o&&a.layout.min+n<u?function([...t],e,n){const i=e<0?t.length+e:e;if(i>=0&&i<t.length){const i=n<0?t.length+n:n,[s]=t.splice(e,1);t.splice(i,0,s)}return t}(t,s,s+o):t}(u,t,e,n);u!==i&&(c.current=!0,s(i.map(Nl).filter(t=>-1!==o.indexOf(t))))}};return e.useEffect(()=>{c.current=!1}),Aa(l,{...r,ref:a,ignoreStrict:!0,children:Aa(Il.Provider,{value:h,children:t})})}const Wl=e.forwardRef(Ul);function Nl(t){return t.value}function zl(t,e){return t.layout.min-e.layout.min}function $l(t){const n=ol(()=>On(t)),{isStatic:i}=e.useContext(Ya);if(i){const[,i]=e.useState(t);e.useEffect(()=>n.on("change",i),[])}return n}function Hl(t,e){const n=$l(e()),i=()=>n.set(e());return i(),Ka(()=>{const e=()=>k.preRender(i,!1,!0),n=t.map(t=>t.on("change",e));return()=>{n.forEach(t=>t()),L(i)}}),n}function Yl(t,e,n,i){if("function"==typeof t)return function(t){Fn.current=[],t();const e=Hl(Fn.current,t);return Fn.current=void 0,e}(t);const s="function"==typeof e?e:Vr(e,n,i);return Array.isArray(t)?Xl(t,s):Xl([t],([t])=>s(t))}function Xl(t,e){const n=ol(()=>[]);return Hl(t,()=>{n.length=0;const i=t.length;for(let e=0;e<i;e++)n[e]=t[e].get();return e(n)})}function Kl(t,e=0){return $n(t)?t:$l(e)}function Gl({children:t,style:n={},value:i,as:s="li",onDrag:o,layout:r=!0,...a},l){const u=ol(()=>bl[s]),c=e.useContext(Il),h={x:Kl(n.x),y:Kl(n.y)},d=Yl([h.x,h.y],([t,e])=>t||e?1:"unset"),{axis:p,registerItem:m,updateOrder:f}=c;return Aa(u,{drag:p,...a,dragSnapToOrigin:!0,style:{...n,x:h.x,y:h.y,zIndex:d},layout:r,onDrag:(t,e)=>{const{velocity:n}=e;n[p]&&f(i,h[p].get(),n[p]),o&&o(t,e)},onLayoutMeasure:t=>m(i,t),ref:l,ignoreStrict:!0,children:t})}const _l=e.forwardRef(Gl);var ql=Object.freeze({__proto__:null,Group:Wl,Item:_l});const Zl={renderer:Sl,...oi},Jl={renderer:Sl,...oi,...$a},Ql={...Jl,...Ba,...Ha};function tu(t){return"number"==typeof t?t:parseFloat(t)}function eu(t,n,i){e.useInsertionEffect(()=>t.on(n,i),[t,n,i])}function nu(t,e){C(Boolean(!e||e.current))}const iu=()=>({scrollX:On(0),scrollY:On(0),scrollXProgress:On(0),scrollYProgress:On(0)});function su({container:t,target:n,layoutEffect:i=!0,...s}={}){const o=ol(iu);return(i?Ka:e.useEffect)(()=>(nu(0,n),nu(0,t),Er((t,{x:e,y:n})=>{o.scrollX.set(e.current),o.scrollXProgress.set(e.progress),o.scrollY.set(n.current),o.scrollYProgress.set(n.progress)},{...s,container:(null==t?void 0:t.current)||void 0,target:(null==n?void 0:n.current)||void 0})),[t,n,JSON.stringify(s.offset)]),o}function ou(t){const n=e.useRef(0),{isStatic:i}=e.useContext(Ya);e.useEffect(()=>{if(i)return;const e=({timestamp:e,delta:i})=>{n.current||(n.current=e),t(e-n.current,i)};return k.update(e,!0),()=>L(e)},[t])}class ru extends jn{constructor(){super(...arguments),this.values=[]}add(t){const e=function(t){return f.has(t)?"transform":gn.has(t)?Wn(t):void 0}(t);e&&(kn(this.values,e),this.update())}update(){this.set(this.values.length?this.values.join(", "):"auto")}}function au(){!ho.current&&po();const[t]=e.useState(co.current);return t}function lu(t,e){[...e].reverse().forEach(n=>{const i=t.getVariant(n);i&&Un(t,i),t.variantChildren&&t.variantChildren.forEach(t=>{lu(t,e)})})}function uu(){const t=new Set,e={subscribe:e=>(t.add(e),()=>{t.delete(e)}),start(e,n){const i=[];return t.forEach(t=>{i.push(_n(t,e,{transitionOverride:n}))}),Promise.all(i)},set:e=>t.forEach(t=>{!function(t,e){Array.isArray(e)?lu(t,e):"string"==typeof e?lu(t,[e]):Un(t,e)}(t,e)}),stop(){t.forEach(t=>{!function(t){t.values.forEach(t=>t.stop())}(t)})},mount:()=>()=>{e.stop()}};return e}function cu(){const t=ol(uu);return Ka(t.mount,[]),t}const hu=cu;class du{constructor(){this.componentControls=new Set}subscribe(t){return this.componentControls.add(t),()=>this.componentControls.delete(t)}start(t,e){this.componentControls.forEach(n=>{n.start(t.nativeEvent||t,e)})}}const pu=()=>new du;function mu(t){return null!==t&&"object"==typeof t&&tl in t}function fu(){return gu}function gu(t){ca.current&&(ca.current.isUpdating=!1,ca.current.blockUpdate(),t&&t())}const yu=(t,e)=>`${t}: ${f.has(e)?"transform":e}`,vu=new Map,xu=new Map;function wu(t,e,n){var i;const s=yu(t,e),o=vu.get(s);if(!o)return null;const{animation:r,startTime:a}=o;function l(){var i;null===(i=window.MotionCancelOptimisedAnimation)||void 0===i||i.call(window,t,e,n)}return r.onfinish=l,null===a||(null===(i=window.MotionHandoffIsComplete)||void 0===i?void 0:i.call(window,t))?(l(),null):a}let Pu,Tu;const Su=new Set;function bu(){Su.forEach(t=>{t.animation.play(),t.animation.startTime=t.startTime}),Su.clear()}const Au=()=>({});class Eu extends wo{constructor(){super(...arguments),this.measureInstanceViewportBox=Hi}build(){}resetTransform(){}restoreTransform(){}removeValueFromRenderState(){}renderInstance(){}scrapeMotionValuesFromProps(){return{}}getBaseTargetFromProps(){}readValueFromInstance(t,e,n){return n.initialState[e]||0}sortInstanceNodePosition(){return 0}}const Mu=rl({scrapeMotionValuesFromProps:Au,createRenderState:Au});const Cu=t=>t>.001?1/t:1e5;let Vu=0;t.AcceleratedAnimation=Cn,t.AnimatePresence=({children:t,exitBeforeEnter:n,custom:i,initial:s=!0,onExitComplete:o,presenceAffectsLayout:r=!0,mode:a="sync"})=>{const l=e.useMemo(()=>Ll(t),[t]),u=l.map(kl),c=e.useRef(!0),h=e.useRef(l),d=ol(()=>new Map),[p,m]=e.useState(l),[f,g]=e.useState(l);Ka(()=>{c.current=!1,h.current=l;for(let t=0;t<f.length;t++){const e=kl(f[t]);u.includes(e)?d.delete(e):!0!==d.get(e)&&d.set(e,!1)}},[f,u.length,u.join("-")]);const y=[];if(l!==p){let t=[...l];for(let e=0;e<f.length;e++){const n=f[e],i=kl(n);u.includes(i)||(t.splice(e,0,n),y.push(n))}return"wait"===a&&y.length&&(t=y),g(Ll(t)),void m(l)}const{forceRender:v}=e.useContext(Va);return Aa(ba,{children:f.map(t=>{const e=kl(t),n=l===f||u.includes(e);return Aa(Cl,{isPresent:n,initial:!(c.current&&!s)&&void 0,custom:n?void 0:i,presenceAffectsLayout:r,mode:a,onExitComplete:n?void 0:()=>{if(!d.has(e))return;d.set(e,!0);let t=!0;d.forEach(e=>{e||(t=!1)}),t&&(null==v||v(),g(h.current),o&&o())},children:t},e)})})},t.AnimateSharedLayout=({children:t})=>(i.useEffect(()=>{},[]),Aa(Ol,{id:ol(()=>"asl-"+Vu++),children:t})),t.DeprecatedLayoutGroupContext=Fl,t.DragControls=du,t.FlatTree=Is,t.LayoutGroup=Ol,t.LayoutGroupContext=Va,t.LazyMotion=function({children:t,features:n,strict:i=!1}){const[,s]=e.useState(!Bl(n)),o=e.useRef(void 0);if(!Bl(n)){const{renderer:t,...e}=n;o.current=t,Qa(e)}return e.useEffect(()=>{Bl(n)&&n().then(({renderer:t,...e})=>{Qa(e),o.current=t,s(!0)})},[]),Aa(Ga.Provider,{value:{renderer:o.current,strict:i},children:t})},t.MotionConfig=function({children:t,isValidProp:n,...i}){n&&vl(n),(i={...e.useContext(Ya),...i}).isStatic=ol(()=>i.isStatic);const s=e.useMemo(()=>i,[JSON.stringify(i.transition),i.transformPagePoint,i.reducedMotion]);return Aa(Ya.Provider,{value:s,children:t})},t.MotionConfigContext=Ya,t.MotionContext=Xa,t.MotionGlobalConfig=S,t.MotionValue=jn,t.PresenceContext=Ma,t.Reorder=ql,t.SwitchLayoutGroupContext=Ra,t.VisualElement=wo,t.addPointerEvent=Ti,t.addPointerInfo=wi,t.addScaleCorrector=js,t.animate=Ho,t.animateMini=Jo,t.animateValue=fn,t.animateVisualElement=_n,t.animationControls=uu,t.animations=oi,t.anticipate=$,t.backIn=N,t.backInOut=z,t.backOut=W,t.buildTransform=Ao,t.calcLength=Li,t.cancelFrame=L,t.cancelSync=Dr,t.circIn=H,t.circInOut=X,t.circOut=Y,t.clamp=nt,t.color=It,t.complex=Yt,t.createBox=Hi,t.createRendererMotionComponent=el,t.createScopedAnimate=$o,t.cubicBezier=O,t.delay=Ns,t.disableInstantTransitions=function(){b.current=!1},t.distance=Si,t.distance2D=bi,t.domAnimation=Jl,t.domMax=Ql,t.domMin=Zl,t.easeIn=Oe,t.easeInOut=Ue,t.easeOut=Ie,t.filterProps=xl,t.findSpring=Ve,t.frame=k,t.frameData=B,t.frameSteps=F,t.inView=Cr,t.inertia=je,t.interpolate=an,t.invariant=V,t.isBrowser=uo,t.isDragActive=ai,t.isMotionComponent=mu,t.isMotionValue=$n,t.isValidMotionProp=gl,t.keyframes=cn,t.m=Al,t.makeUseVisualState=rl,t.mirrorEasing=I,t.mix=rn,t.motion=bl,t.motionValue=On,t.noop=M,t.optimizedAppearDataAttribute=Nn,t.pipe=Ye,t.progress=de,t.px=ut,t.resolveMotionValue=Us,t.reverseEasing=U,t.scroll=Er,t.scrollInfo=Pr,t.spring=Fe,t.stagger=function(t=.1,{startDelay:e=0,from:n=0,ease:i}={}){return(s,o)=>{const r="number"==typeof n?n:function(t,e){if("first"===t)return 0;{const n=e-1;return"last"===t?n:n/2}}(n,o),a=Math.abs(r-s);let l=t*a;if(i){const e=o*t;l=$e(i)(l/e)*e}return e+l}},t.startOptimizedAppearAnimation=function(t,e,n,i,s){if(window.MotionIsMounted)return;const o=t.dataset.framerAppearId;if(!o)return;window.MotionHandoffAnimation=wu;const r=yu(o,e);Tu||(Tu=bn(t,e,[n[0],n[0]],{duration:1e4,ease:"linear"}),vu.set(r,{animation:Tu,startTime:null}),window.MotionHandoffAnimation=wu,window.MotionHasOptimisedAnimation=(t,e)=>{if(!t)return!1;if(!e)return xu.has(t);const n=yu(t,e);return Boolean(vu.get(n))},window.MotionHandoffMarkAsComplete=t=>{xu.has(t)&&xu.set(t,!0)},window.MotionHandoffIsComplete=t=>!0===xu.get(t),window.MotionCancelOptimisedAnimation=(t,e,n,i)=>{const s=yu(t,e),o=vu.get(s);o&&(n&&void 0===i?n.postRender(()=>{n.postRender(()=>{o.animation.cancel()})}):o.animation.cancel(),n&&i?(Su.add(o),n.render(bu)):(vu.delete(s),vu.size||(window.MotionCancelOptimisedAnimation=void 0)))},window.MotionCheckAppearSync=(t,e,n)=>{var i,s;const o=zn(t);if(!o)return;const r=null===(i=window.MotionHasOptimisedAnimation)||void 0===i?void 0:i.call(window,o,e),a=null===(s=t.props.values)||void 0===s?void 0:s[e];if(!r||!a)return;const l=n.on("change",t=>{var n;a.get()!==t&&(null===(n=window.MotionCancelOptimisedAnimation)||void 0===n||n.call(window,o,e),l())});return l});const a=()=>{Tu.cancel();const o=bn(t,e,n,i);void 0===Pu&&(Pu=performance.now()),o.startTime=Pu,vu.set(r,{animation:o,startTime:Pu}),s&&s(o)};xu.set(o,!1),Tu.ready?Tu.ready.then(a).catch(M):a()},t.steps=function(t,e="end"){return n=>{const i=(n="end"===e?Math.min(n,.999):Math.max(n,.001))*t,s="end"===e?Math.floor(i):Math.ceil(i);return nt(0,1,s/t)}},t.sync=Rr,t.time=le,t.transform=Vr,t.unwrapMotionComponent=function(t){if(mu(t))return t[tl]},t.useAnimate=function(){const t=ol(()=>({current:null,animations:[]})),e=ol(()=>$o(t));return Rl(()=>{t.animations.forEach(t=>t.stop())}),[t,e]},t.useAnimateMini=function(){const t=ol(()=>({current:null,animations:[]})),e=ol(()=>Zo(t));return Rl(()=>{t.animations.forEach(t=>t.stop())}),[t,e]},t.useAnimation=hu,t.useAnimationControls=cu,t.useAnimationFrame=ou,t.useCycle=function(...t){const n=e.useRef(0),[i,s]=e.useState(t[n.current]);return[i,e.useCallback(e=>{n.current="number"!=typeof e?Xs(0,t.length,n.current+1):e,s(t[n.current])},[t.length,...t])]},t.useDeprecatedAnimatedState=function(t){const[n,i]=e.useState(t),s=Mu({},!1),o=ol(()=>new Eu({props:{onUpdate:t=>{i({...t})}},visualState:s,presenceContext:null},{initialState:t}));return e.useLayoutEffect(()=>(o.mount({}),()=>o.unmount()),[o]),[n,ol(()=>t=>_n(o,t))]},t.useDeprecatedInvertedScale=function(t){let n=$l(1),i=$l(1);const{visualElement:s}=e.useContext(Xa);return t?(n=t.scaleX||n,i=t.scaleY||i):s&&(n=s.getValue("scaleX",1),i=s.getValue("scaleY",1)),{scaleX:Yl(n,Cu),scaleY:Yl(i,Cu)}},t.useDomEvent=function(t,n,i,s){e.useEffect(()=>{const e=t.current;if(i&&e)return Pi(e,n,i,s)},[t,n,i,s])},t.useDragControls=function(){return ol(pu)},t.useElementScroll=function(t){return su({container:t})},t.useForceUpdate=Dl,t.useInView=function(t,{root:n,margin:i,amount:s,once:o=!1}={}){const[r,a]=e.useState(!1);return e.useEffect(()=>{if(!t.current||o&&r)return;const e={root:n&&n.current||void 0,margin:i,amount:s};return Cr(t.current,()=>(a(!0),o?void 0:()=>a(!1)),e)},[n,t,i,o,s]),r},t.useInstantLayoutTransition=fu,t.useInstantTransition=function(){const[t,n]=Dl(),i=fu(),s=e.useRef(-1);return e.useEffect(()=>{k.postRender(()=>k.postRender(()=>{n===s.current&&(b.current=!1)}))},[n]),e=>{i(()=>{b.current=!0,t(),e(),s.current=n+1})}},t.useIsPresent=function(){return null===(t=e.useContext(Ma))||t.isPresent;var t},t.useIsomorphicLayoutEffect=Ka,t.useMotionTemplate=function(t,...e){const n=t.length;return Hl(e.filter($n),(function(){let i="";for(let s=0;s<n;s++){i+=t[s];const n=e[s];n&&(i+=$n(n)?n.get():n)}return i}))},t.useMotionValue=$l,t.useMotionValueEvent=eu,t.usePresence=Ca,t.useReducedMotion=au,t.useReducedMotionConfig=function(){const t=au(),{reducedMotion:n}=e.useContext(Ya);return"never"!==n&&("always"===n||t)},t.useResetProjection=function(){return e.useCallback(()=>{const t=ca.current;t&&t.resetTree()},[])},t.useScroll=su,t.useSpring=function(t,n={}){const{isStatic:i}=e.useContext(Ya),s=e.useRef(null),o=$l($n(t)?tu(t.get()):t),r=e.useRef(o.get()),a=e.useRef(()=>{}),l=()=>{const t=s.current;t&&0===t.time&&t.sample(B.delta),u(),s.current=fn({keyframes:[o.get(),r.current],velocity:o.getVelocity(),type:"spring",restDelta:.001,restSpeed:.01,...n,onUpdate:a.current})},u=()=>{s.current&&s.current.stop()};return e.useInsertionEffect(()=>o.attach((t,e)=>i?e(t):(r.current=t,a.current=e,k.update(l),o.get()),u),[JSON.stringify(n)]),Ka(()=>{if($n(t))return t.on("change",t=>o.set(tu(t)))},[o]),o},t.useTime=function(){const t=$l(0);return ou(e=>t.set(e)),t},t.useTransform=Yl,t.useUnmountEffect=Rl,t.useVelocity=function(t){const e=$l(t.getVelocity()),n=()=>{const i=t.getVelocity();e.set(i),i&&k.update(n)};return eu(t,"change",()=>{k.update(n,!1,!0)}),e},t.useViewportScroll=function(){return su()},t.useWillChange=function(){return ol(()=>new ru("auto"))},t.visualElementStore=so,t.wrap=Xs}));
+!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Motion={},t.React)}(this,(function(t,e){"use strict";function n(t){var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var i=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,i.get?i:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var i=n(e);function s(t){if("undefined"==typeof Proxy)return t;const e=new Map;return new Proxy((...e)=>t(...e),{get:(n,i)=>"create"===i?t:(e.has(i)||e.set(i,t(i)),e.get(i))})}function o(t){return null!==t&&"object"==typeof t&&"function"==typeof t.start}const r=t=>Array.isArray(t);function a(t,e){if(!Array.isArray(e))return!1;const n=e.length;if(n!==t.length)return!1;for(let i=0;i<n;i++)if(e[i]!==t[i])return!1;return!0}function l(t){return"string"==typeof t||Array.isArray(t)}function u(t){const e=[{},{}];return null==t||t.values.forEach((t,n)=>{e[0][n]=t.get(),e[1][n]=t.getVelocity()}),e}function c(t,e,n,i){if("function"==typeof e){const[s,o]=u(i);e=e(void 0!==n?n:t.custom,s,o)}if("string"==typeof e&&(e=t.variants&&t.variants[e]),"function"==typeof e){const[s,o]=u(i);e=e(void 0!==n?n:t.custom,s,o)}return e}function h(t,e,n){const i=t.getProps();return c(i,e,void 0!==n?n:i.custom,t)}const d=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],p=["initial",...d],m=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],f=new Set(m),g=t=>1e3*t,y=t=>t/1e3,v={type:"spring",stiffness:500,damping:25,restSpeed:10},x={type:"keyframes",duration:.8},w={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},P=(t,{keyframes:e})=>e.length>2?x:f.has(t)?t.startsWith("scale")?{type:"spring",stiffness:550,damping:0===e[1]?2*Math.sqrt(550):30,restSpeed:10}:v:w;function S(t,e){return t?t[e]||t.default||t:void 0}const T={skipAnimations:!1,useManualTiming:!1},b={current:!1},A=t=>null!==t;function E(t,{repeat:e,repeatType:n="loop"},i){const s=t.filter(A),o=e&&"loop"!==n&&e%2==1?0:s.length-1;return o&&void 0!==i?i:s[o]}const C=t=>t;const M=["read","resolveKeyframes","update","preRender","render","postRender"];function V(t,e){let n=!1,i=!0;const s={delta:0,timestamp:0,isProcessing:!1},o=()=>n=!0,r=M.reduce((t,e)=>(t[e]=function(t){let e=new Set,n=new Set,i=!1,s=!1;const o=new WeakSet;let r={delta:0,timestamp:0,isProcessing:!1};function a(e){o.has(e)&&(l.schedule(e),t()),e(r)}const l={schedule:(t,s=!1,r=!1)=>{const a=r&&i?e:n;return s&&o.add(t),a.has(t)||a.add(t),t},cancel:t=>{n.delete(t),o.delete(t)},process:t=>{r=t,i?s=!0:(i=!0,[e,n]=[n,e],n.clear(),e.forEach(a),i=!1,s&&(s=!1,l.process(t)))}};return l}(o),t),{}),{read:a,resolveKeyframes:l,update:u,preRender:c,render:h,postRender:d}=r,p=()=>{const o=T.useManualTiming?s.timestamp:performance.now();n=!1,s.delta=i?1e3/60:Math.max(Math.min(o-s.timestamp,40),1),s.timestamp=o,s.isProcessing=!0,a.process(s),l.process(s),u.process(s),c.process(s),h.process(s),d.process(s),s.isProcessing=!1,n&&e&&(i=!1,t(p))};return{schedule:M.reduce((e,o)=>{const a=r[o];return e[o]=(e,o=!1,r=!1)=>(n||(n=!0,i=!0,s.isProcessing||t(p)),a.schedule(e,o,r)),e},{}),cancel:t=>{for(let e=0;e<M.length;e++)r[M[e]].cancel(t)},state:s,steps:r}}const{schedule:R,cancel:D,state:k,steps:L}=V("undefined"!=typeof requestAnimationFrame?requestAnimationFrame:C,!0),B=(t,e,n)=>(((1-3*n+3*e)*t+(3*n-6*e))*t+3*e)*t;function F(t,e,n,i){if(t===e&&n===i)return C;const s=e=>function(t,e,n,i,s){let o,r,a=0;do{r=e+(n-e)/2,o=B(r,i,s)-t,o>0?n=r:e=r}while(Math.abs(o)>1e-7&&++a<12);return r}(e,0,1,t,n);return t=>0===t||1===t?t:B(s(t),e,i)}const j=t=>e=>e<=.5?t(2*e)/2:(2-t(2*(1-e)))/2,O=t=>e=>1-t(1-e),I=F(.33,1.53,.69,.99),U=O(I),W=j(U),N=t=>(t*=2)<1?.5*U(t):.5*(2-Math.pow(2,-10*(t-1))),z=t=>1-Math.sin(Math.acos(t)),$=O(z),H=j(z),Y=t=>/^0[^.\s]+$/u.test(t);let X=C,G=C;const K=t=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),_=t=>e=>"string"==typeof e&&e.startsWith(t),q=_("--"),Z=_("var(--"),J=t=>!!Z(t)&&Q.test(t.split("/*")[0].trim()),Q=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,tt=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function et(t,e,n=1){const[i,s]=function(t){const e=tt.exec(t);if(!e)return[,];const[,n,i,s]=e;return["--"+(null!=n?n:i),s]}(t);if(!i)return;const o=window.getComputedStyle(e).getPropertyValue(i);if(o){const t=o.trim();return K(t)?parseFloat(t):t}return J(s)?et(s,e,n+1):s}const nt=(t,e,n)=>n>e?e:n<t?t:n,it={test:t=>"number"==typeof t,parse:parseFloat,transform:t=>t},st={...it,transform:t=>nt(0,1,t)},ot={...it,default:1},rt=t=>({test:e=>"string"==typeof e&&e.endsWith(t)&&1===e.split(" ").length,parse:parseFloat,transform:e=>`${e}${t}`}),at=rt("deg"),lt=rt("%"),ut=rt("px"),ct=rt("vh"),ht=rt("vw"),dt={...lt,parse:t=>lt.parse(t)/100,transform:t=>lt.transform(100*t)},pt=new Set(["width","height","top","left","right","bottom","x","y","translateX","translateY"]),mt=t=>t===it||t===ut,ft=(t,e)=>parseFloat(t.split(", ")[e]),gt=(t,e)=>(n,{transform:i})=>{if("none"===i||!i)return 0;const s=i.match(/^matrix3d\((.+)\)$/u);if(s)return ft(s[1],e);{const e=i.match(/^matrix\((.+)\)$/u);return e?ft(e[1],t):0}},yt=new Set(["x","y","z"]),vt=m.filter(t=>!yt.has(t));const xt={width:({x:t},{paddingLeft:e="0",paddingRight:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),height:({y:t},{paddingTop:e="0",paddingBottom:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),top:(t,{top:e})=>parseFloat(e),left:(t,{left:e})=>parseFloat(e),bottom:({y:t},{top:e})=>parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=>parseFloat(e)+(t.max-t.min),x:gt(4,13),y:gt(5,14)};xt.translateX=xt.x,xt.translateY=xt.y;const wt=t=>e=>e.test(t),Pt=[it,ut,lt,at,ht,ct,{test:t=>"auto"===t,parse:t=>t}],St=t=>Pt.find(wt(t)),Tt=new Set;let bt=!1,At=!1;function Et(){if(At){const t=Array.from(Tt).filter(t=>t.needsMeasurement),e=new Set(t.map(t=>t.element)),n=new Map;e.forEach(t=>{const e=function(t){const e=[];return vt.forEach(n=>{const i=t.getValue(n);void 0!==i&&(e.push([n,i.get()]),i.set(n.startsWith("scale")?1:0))}),e}(t);e.length&&(n.set(t,e),t.render())}),t.forEach(t=>t.measureInitialState()),e.forEach(t=>{t.render();const e=n.get(t);e&&e.forEach(([e,n])=>{var i;null===(i=t.getValue(e))||void 0===i||i.set(n)})}),t.forEach(t=>t.measureEndState()),t.forEach(t=>{void 0!==t.suspendedScrollY&&window.scrollTo(0,t.suspendedScrollY)})}At=!1,bt=!1,Tt.forEach(t=>t.complete()),Tt.clear()}function Ct(){Tt.forEach(t=>{t.readKeyframes(),t.needsMeasurement&&(At=!0)})}class Mt{constructor(t,e,n,i,s,o=!1){this.isComplete=!1,this.isAsync=!1,this.needsMeasurement=!1,this.isScheduled=!1,this.unresolvedKeyframes=[...t],this.onComplete=e,this.name=n,this.motionValue=i,this.element=s,this.isAsync=o}scheduleResolve(){this.isScheduled=!0,this.isAsync?(Tt.add(this),bt||(bt=!0,R.read(Ct),R.resolveKeyframes(Et))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:t,name:e,element:n,motionValue:i}=this;for(let s=0;s<t.length;s++)if(null===t[s])if(0===s){const s=null==i?void 0:i.get(),o=t[t.length-1];if(void 0!==s)t[0]=s;else if(n&&e){const i=n.readValue(e,o);null!=i&&(t[0]=i)}void 0===t[0]&&(t[0]=o),i&&void 0===s&&i.set(t[0])}else t[s]=t[s-1]}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(){this.isComplete=!0,this.onComplete(this.unresolvedKeyframes,this.finalKeyframe),Tt.delete(this)}cancel(){this.isComplete||(this.isScheduled=!1,Tt.delete(this))}resume(){this.isComplete||this.scheduleResolve()}}const Vt=t=>Math.round(1e5*t)/1e5,Rt=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;const Dt=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,kt=(t,e)=>n=>Boolean("string"==typeof n&&Dt.test(n)&&n.startsWith(t)||e&&!function(t){return null==t}(n)&&Object.prototype.hasOwnProperty.call(n,e)),Lt=(t,e,n)=>i=>{if("string"!=typeof i)return i;const[s,o,r,a]=i.match(Rt);return{[t]:parseFloat(s),[e]:parseFloat(o),[n]:parseFloat(r),alpha:void 0!==a?parseFloat(a):1}},Bt={...it,transform:t=>Math.round((t=>nt(0,255,t))(t))},Ft={test:kt("rgb","red"),parse:Lt("red","green","blue"),transform:({red:t,green:e,blue:n,alpha:i=1})=>"rgba("+Bt.transform(t)+", "+Bt.transform(e)+", "+Bt.transform(n)+", "+Vt(st.transform(i))+")"};const jt={test:kt("#"),parse:function(t){let e="",n="",i="",s="";return t.length>5?(e=t.substring(1,3),n=t.substring(3,5),i=t.substring(5,7),s=t.substring(7,9)):(e=t.substring(1,2),n=t.substring(2,3),i=t.substring(3,4),s=t.substring(4,5),e+=e,n+=n,i+=i,s+=s),{red:parseInt(e,16),green:parseInt(n,16),blue:parseInt(i,16),alpha:s?parseInt(s,16)/255:1}},transform:Ft.transform},Ot={test:kt("hsl","hue"),parse:Lt("hue","saturation","lightness"),transform:({hue:t,saturation:e,lightness:n,alpha:i=1})=>"hsla("+Math.round(t)+", "+lt.transform(Vt(e))+", "+lt.transform(Vt(n))+", "+Vt(st.transform(i))+")"},It={test:t=>Ft.test(t)||jt.test(t)||Ot.test(t),parse:t=>Ft.test(t)?Ft.parse(t):Ot.test(t)?Ot.parse(t):jt.parse(t),transform:t=>"string"==typeof t?t:t.hasOwnProperty("red")?Ft.transform(t):Ot.transform(t)},Ut=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;const Wt=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function Nt(t){const e=t.toString(),n=[],i={color:[],number:[],var:[]},s=[];let o=0;const r=e.replace(Wt,t=>(It.test(t)?(i.color.push(o),s.push("color"),n.push(It.parse(t))):t.startsWith("var(")?(i.var.push(o),s.push("var"),n.push(t)):(i.number.push(o),s.push("number"),n.push(parseFloat(t))),++o,"${}")).split("${}");return{values:n,split:r,indexes:i,types:s}}function zt(t){return Nt(t).values}function $t(t){const{split:e,types:n}=Nt(t),i=e.length;return t=>{let s="";for(let o=0;o<i;o++)if(s+=e[o],void 0!==t[o]){const e=n[o];s+="number"===e?Vt(t[o]):"color"===e?It.transform(t[o]):t[o]}return s}}const Ht=t=>"number"==typeof t?0:t;const Yt={test:function(t){var e,n;return isNaN(t)&&"string"==typeof t&&((null===(e=t.match(Rt))||void 0===e?void 0:e.length)||0)+((null===(n=t.match(Ut))||void 0===n?void 0:n.length)||0)>0},parse:zt,createTransformer:$t,getAnimatableNone:function(t){const e=zt(t);return $t(t)(e.map(Ht))}},Xt=new Set(["brightness","contrast","saturate","opacity"]);function Gt(t){const[e,n]=t.slice(0,-1).split("(");if("drop-shadow"===e)return t;const[i]=n.match(Rt)||[];if(!i)return t;const s=n.replace(i,"");let o=Xt.has(e)?1:0;return i!==n&&(o*=100),e+"("+o+s+")"}const Kt=/\b([a-z-]*)\(.*?\)/gu,_t={...Yt,getAnimatableNone:t=>{const e=t.match(Kt);return e?e.map(Gt).join(" "):t}},qt={borderWidth:ut,borderTopWidth:ut,borderRightWidth:ut,borderBottomWidth:ut,borderLeftWidth:ut,borderRadius:ut,radius:ut,borderTopLeftRadius:ut,borderTopRightRadius:ut,borderBottomRightRadius:ut,borderBottomLeftRadius:ut,width:ut,maxWidth:ut,height:ut,maxHeight:ut,top:ut,right:ut,bottom:ut,left:ut,padding:ut,paddingTop:ut,paddingRight:ut,paddingBottom:ut,paddingLeft:ut,margin:ut,marginTop:ut,marginRight:ut,marginBottom:ut,marginLeft:ut,backgroundPositionX:ut,backgroundPositionY:ut},Zt={rotate:at,rotateX:at,rotateY:at,rotateZ:at,scale:ot,scaleX:ot,scaleY:ot,scaleZ:ot,skew:at,skewX:at,skewY:at,distance:ut,translateX:ut,translateY:ut,translateZ:ut,x:ut,y:ut,z:ut,perspective:ut,transformPerspective:ut,opacity:st,originX:dt,originY:dt,originZ:ut},Jt={...it,transform:Math.round},Qt={...qt,...Zt,zIndex:Jt,size:ut,fillOpacity:st,strokeOpacity:st,numOctaves:Jt},te={...Qt,color:It,backgroundColor:It,outlineColor:It,fill:It,stroke:It,borderColor:It,borderTopColor:It,borderRightColor:It,borderBottomColor:It,borderLeftColor:It,filter:_t,WebkitFilter:_t},ee=t=>te[t];function ne(t,e){let n=ee(t);return n!==_t&&(n=Yt),n.getAnimatableNone?n.getAnimatableNone(e):void 0}const ie=new Set(["auto","none","0"]);class se extends Mt{constructor(t,e,n,i,s){super(t,e,n,i,s,!0)}readKeyframes(){const{unresolvedKeyframes:t,element:e,name:n}=this;if(!e||!e.current)return;super.readKeyframes();for(let n=0;n<t.length;n++){let i=t[n];if("string"==typeof i&&(i=i.trim(),J(i))){const s=et(i,e.current);void 0!==s&&(t[n]=s),n===t.length-1&&(this.finalKeyframe=i)}}if(this.resolveNoneKeyframes(),!pt.has(n)||2!==t.length)return;const[i,s]=t,o=St(i),r=St(s);if(o!==r)if(mt(o)&&mt(r))for(let e=0;e<t.length;e++){const n=t[e];"string"==typeof n&&(t[e]=parseFloat(n))}else this.needsMeasurement=!0}resolveNoneKeyframes(){const{unresolvedKeyframes:t,name:e}=this,n=[];for(let e=0;e<t.length;e++)("number"==typeof(i=t[e])?0===i:null===i||"none"===i||"0"===i||Y(i))&&n.push(e);var i;n.length&&function(t,e,n){let i=0,s=void 0;for(;i<t.length&&!s;){const e=t[i];"string"==typeof e&&!ie.has(e)&&Nt(e).values.length&&(s=t[i]),i++}if(s&&n)for(const i of e)t[i]=ne(n,s)}(t,n,e)}measureInitialState(){const{element:t,unresolvedKeyframes:e,name:n}=this;if(!t||!t.current)return;"height"===n&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=xt[n](t.measureViewportBox(),window.getComputedStyle(t.current)),e[0]=this.measuredOrigin;const i=e[e.length-1];void 0!==i&&t.getValue(n,i).jump(i,!1)}measureEndState(){var t;const{element:e,name:n,unresolvedKeyframes:i}=this;if(!e||!e.current)return;const s=e.getValue(n);s&&s.jump(this.measuredOrigin,!1);const o=i.length-1,r=i[o];i[o]=xt[n](e.measureViewportBox(),window.getComputedStyle(e.current)),null!==r&&void 0===this.finalKeyframe&&(this.finalKeyframe=r),(null===(t=this.removedTransforms)||void 0===t?void 0:t.length)&&this.removedTransforms.forEach(([t,n])=>{e.getValue(t).set(n)}),this.resolveNoneKeyframes()}}function oe(t){return"function"==typeof t}let re;function ae(){re=void 0}const le={now:()=>(void 0===re&&le.set(k.isProcessing||T.useManualTiming?k.timestamp:performance.now()),re),set:t=>{re=t,queueMicrotask(ae)}},ue=(t,e)=>"zIndex"!==e&&(!("number"!=typeof t&&!Array.isArray(t))||!("string"!=typeof t||!Yt.test(t)&&"0"!==t||t.startsWith("url(")));function ce(t,e,n,i){const s=t[0];if(null===s)return!1;if("display"===e||"visibility"===e)return!0;const o=t[t.length-1],r=ue(s,e),a=ue(o,e);return!(!r||!a)&&(function(t){const e=t[0];if(1===t.length)return!0;for(let n=0;n<t.length;n++)if(t[n]!==e)return!0}(t)||("spring"===n||oe(n))&&i)}class he{constructor({autoplay:t=!0,delay:e=0,type:n="keyframes",repeat:i=0,repeatDelay:s=0,repeatType:o="loop",...r}){this.isStopped=!1,this.hasAttemptedResolve=!1,this.createdAt=le.now(),this.options={autoplay:t,delay:e,type:n,repeat:i,repeatDelay:s,repeatType:o,...r},this.updateFinishedPromise()}calcStartTime(){return this.resolvedAt&&this.resolvedAt-this.createdAt>40?this.resolvedAt:this.createdAt}get resolved(){return this._resolved||this.hasAttemptedResolve||(Ct(),Et()),this._resolved}onKeyframesResolved(t,e){this.resolvedAt=le.now(),this.hasAttemptedResolve=!0;const{name:n,type:i,velocity:s,delay:o,onComplete:r,onUpdate:a,isGenerator:l}=this.options;if(!l&&!ce(t,n,i,s)){if(b.current||!o)return null==a||a(E(t,this.options,e)),null==r||r(),void this.resolveFinishedPromise();this.options.duration=0}const u=this.initPlayback(t,e);!1!==u&&(this._resolved={keyframes:t,finalKeyframe:e,...u},this.onPostResolved())}onPostResolved(){}then(t,e){return this.currentFinishedPromise.then(t,e)}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}}function de(t,e){return e?t*(1e3/e):0}function pe(t,e,n){const i=Math.max(e-5,0);return de(n-t(i),e-i)}function me({duration:t=800,bounce:e=.25,velocity:n=0,mass:i=1}){let s,o,r=1-e;r=nt(.05,1,r),t=nt(.01,10,y(t)),r<1?(s=e=>{const i=e*r,s=i*t;return.001-(i-n)/fe(e,r)*Math.exp(-s)},o=e=>{const i=e*r*t,o=i*n+n,a=Math.pow(r,2)*Math.pow(e,2)*t,l=Math.exp(-i),u=fe(Math.pow(e,2),r);return(.001-s(e)>0?-1:1)*((o-a)*l)/u}):(s=e=>Math.exp(-e*t)*((e-n)*t+1)-.001,o=e=>Math.exp(-e*t)*(t*t*(n-e)));const a=function(t,e,n){let i=n;for(let n=1;n<12;n++)i-=t(i)/e(i);return i}(s,o,5/t);if(t=g(t),isNaN(a))return{stiffness:100,damping:10,duration:t};{const e=Math.pow(a,2)*i;return{stiffness:e,damping:2*r*Math.sqrt(i*e),duration:t}}}function fe(t,e){return t*Math.sqrt(1-e*e)}const ge=["duration","bounce"],ye=["stiffness","damping","mass"];function ve(t,e){return e.some(e=>void 0!==t[e])}function xe({keyframes:t,restDelta:e,restSpeed:n,...i}){const s=t[0],o=t[t.length-1],r={done:!1,value:s},{stiffness:a,damping:l,mass:u,duration:c,velocity:h,isResolvedFromDuration:d}=function(t){let e={velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1,...t};if(!ve(t,ye)&&ve(t,ge)){const n=me(t);e={...e,...n,mass:1},e.isResolvedFromDuration=!0}return e}({...i,velocity:-y(i.velocity||0)}),p=h||0,m=l/(2*Math.sqrt(a*u)),f=o-s,v=y(Math.sqrt(a/u)),x=Math.abs(f)<5;let w;if(n||(n=x?.01:2),e||(e=x?.005:.5),m<1){const t=fe(v,m);w=e=>{const n=Math.exp(-m*v*e);return o-n*((p+m*v*f)/t*Math.sin(t*e)+f*Math.cos(t*e))}}else if(1===m)w=t=>o-Math.exp(-v*t)*(f+(p+v*f)*t);else{const t=v*Math.sqrt(m*m-1);w=e=>{const n=Math.exp(-m*v*e),i=Math.min(t*e,300);return o-n*((p+m*v*f)*Math.sinh(i)+t*f*Math.cosh(i))/t}}return{calculatedDuration:d&&c||null,next:t=>{const i=w(t);if(d)r.done=t>=c;else{let s=0;m<1&&(s=0===t?g(p):pe(w,t,i));const a=Math.abs(s)<=n,l=Math.abs(o-i)<=e;r.done=a&&l}return r.value=r.done?o:i,r}}}function we({keyframes:t,velocity:e=0,power:n=.8,timeConstant:i=325,bounceDamping:s=10,bounceStiffness:o=500,modifyTarget:r,min:a,max:l,restDelta:u=.5,restSpeed:c}){const h=t[0],d={done:!1,value:h},p=t=>void 0===a?l:void 0===l||Math.abs(a-t)<Math.abs(l-t)?a:l;let m=n*e;const f=h+m,g=void 0===r?f:r(f);g!==f&&(m=g-h);const y=t=>-m*Math.exp(-t/i),v=t=>g+y(t),x=t=>{const e=y(t),n=v(t);d.done=Math.abs(e)<=u,d.value=d.done?g:n};let w,P;const S=t=>{var e;(e=d.value,void 0!==a&&e<a||void 0!==l&&e>l)&&(w=t,P=xe({keyframes:[d.value,p(d.value)],velocity:pe(v,t,d.value),damping:s,stiffness:o,restDelta:u,restSpeed:c}))};return S(0),{calculatedDuration:null,next:t=>{let e=!1;return P||void 0!==w||(e=!0,x(t),S(t)),void 0!==w&&t>=w?P.next(t-w):(!e&&x(t),d)}}}const Pe=F(.42,0,1,1),Se=F(0,0,.58,1),Te=F(.42,0,.58,1),be=t=>Array.isArray(t)&&"number"!=typeof t[0],Ae=t=>Array.isArray(t)&&"number"==typeof t[0],Ee={linear:C,easeIn:Pe,easeInOut:Te,easeOut:Se,circIn:z,circInOut:H,circOut:$,backIn:U,backInOut:W,backOut:I,anticipate:N},Ce=t=>{if(Ae(t)){G(4===t.length);const[e,n,i,s]=t;return F(e,n,i,s)}return"string"==typeof t?Ee[t]:t},Me=(t,e)=>n=>e(t(n)),Ve=(...t)=>t.reduce(Me),Re=(t,e,n)=>{const i=e-t;return 0===i?1:(n-t)/i},De=(t,e,n)=>t+(e-t)*n;function ke(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+(e-t)*(2/3-n)*6:t}function Le(t,e){return n=>n>0?e:t}const Be=(t,e,n)=>{const i=t*t,s=n*(e*e-i)+i;return s<0?0:Math.sqrt(s)},Fe=[jt,Ft,Ot];function je(t){const e=(n=t,Fe.find(t=>t.test(n)));var n;if(!Boolean(e))return!1;let i=e.parse(t);return e===Ot&&(i=function({hue:t,saturation:e,lightness:n,alpha:i}){t/=360,n/=100;let s=0,o=0,r=0;if(e/=100){const i=n<.5?n*(1+e):n+e-n*e,a=2*n-i;s=ke(a,i,t+1/3),o=ke(a,i,t),r=ke(a,i,t-1/3)}else s=o=r=n;return{red:Math.round(255*s),green:Math.round(255*o),blue:Math.round(255*r),alpha:i}}(i)),i}const Oe=(t,e)=>{const n=je(t),i=je(e);if(!n||!i)return Le(t,e);const s={...n};return t=>(s.red=Be(n.red,i.red,t),s.green=Be(n.green,i.green,t),s.blue=Be(n.blue,i.blue,t),s.alpha=De(n.alpha,i.alpha,t),Ft.transform(s))},Ie=new Set(["none","hidden"]);function Ue(t,e){return n=>De(t,e,n)}function We(t){return"number"==typeof t?Ue:"string"==typeof t?J(t)?Le:It.test(t)?Oe:$e:Array.isArray(t)?Ne:"object"==typeof t?It.test(t)?Oe:ze:Le}function Ne(t,e){const n=[...t],i=n.length,s=t.map((t,n)=>We(t)(t,e[n]));return t=>{for(let e=0;e<i;e++)n[e]=s[e](t);return n}}function ze(t,e){const n={...t,...e},i={};for(const s in n)void 0!==t[s]&&void 0!==e[s]&&(i[s]=We(t[s])(t[s],e[s]));return t=>{for(const e in i)n[e]=i[e](t);return n}}const $e=(t,e)=>{const n=Yt.createTransformer(e),i=Nt(t),s=Nt(e);return i.indexes.var.length===s.indexes.var.length&&i.indexes.color.length===s.indexes.color.length&&i.indexes.number.length>=s.indexes.number.length?Ie.has(t)&&!s.values.length||Ie.has(e)&&!i.values.length?function(t,e){return Ie.has(t)?n=>n<=0?t:e:n=>n>=1?e:t}(t,e):Ve(Ne(function(t,e){var n;const i=[],s={color:0,var:0,number:0};for(let o=0;o<e.values.length;o++){const r=e.types[o],a=t.indexes[r][s[r]],l=null!==(n=t.values[a])&&void 0!==n?n:0;i[o]=l,s[r]++}return i}(i,s),s.values),n):Le(t,e)};function He(t,e,n){if("number"==typeof t&&"number"==typeof e&&"number"==typeof n)return De(t,e,n);return We(t)(t,e)}function Ye(t,e,{clamp:n=!0,ease:i,mixer:s}={}){const o=t.length;if(G(o===e.length),1===o)return()=>e[0];if(2===o&&t[0]===t[1])return()=>e[1];t[0]>t[o-1]&&(t=[...t].reverse(),e=[...e].reverse());const r=function(t,e,n){const i=[],s=n||He,o=t.length-1;for(let n=0;n<o;n++){let o=s(t[n],t[n+1]);if(e){const t=Array.isArray(e)?e[n]||C:e;o=Ve(t,o)}i.push(o)}return i}(e,i,s),a=r.length,l=e=>{let n=0;if(a>1)for(;n<t.length-2&&!(e<t[n+1]);n++);const i=Re(t[n],t[n+1],e);return r[n](i)};return n?e=>l(nt(t[0],t[o-1],e)):l}function Xe(t,e){const n=t[t.length-1];for(let i=1;i<=e;i++){const s=Re(0,e,i);t.push(De(n,1,s))}}function Ge(t){const e=[0];return Xe(e,t.length-1),e}function Ke({duration:t=300,keyframes:e,times:n,ease:i="easeInOut"}){const s=be(i)?i.map(Ce):Ce(i),o={done:!1,value:e[0]},r=Ye(function(t,e){return t.map(t=>t*e)}(n&&n.length===e.length?n:Ge(e),t),e,{ease:Array.isArray(s)?s:(a=e,l=s,a.map(()=>l||Te).splice(0,a.length-1))});var a,l;return{calculatedDuration:t,next:e=>(o.value=r(e),o.done=e>=t,o)}}function _e(t){let e=0;let n=t.next(e);for(;!n.done&&e<2e4;)e+=50,n=t.next(e);return e>=2e4?1/0:e}const qe=t=>{const e=({timestamp:e})=>t(e);return{start:()=>R.update(e,!0),stop:()=>D(e),now:()=>k.isProcessing?k.timestamp:le.now()}},Ze={decay:we,inertia:we,tween:Ke,keyframes:Ke,spring:xe},Je=t=>t/100;class Qe extends he{constructor(t){super(t),this.holdTime=null,this.cancelTime=null,this.currentTime=0,this.playbackSpeed=1,this.pendingPlayState="running",this.startTime=null,this.state="idle",this.stop=()=>{if(this.resolver.cancel(),this.isStopped=!0,"idle"===this.state)return;this.teardown();const{onStop:t}=this.options;t&&t()};const{name:e,motionValue:n,element:i,keyframes:s}=this.options,o=(null==i?void 0:i.KeyframeResolver)||Mt;this.resolver=new o(s,(t,e)=>this.onKeyframesResolved(t,e),e,n,i),this.resolver.scheduleResolve()}initPlayback(t){const{type:e="keyframes",repeat:n=0,repeatDelay:i=0,repeatType:s,velocity:o=0}=this.options,r=oe(e)?e:Ze[e]||Ke;let a,l;r!==Ke&&"number"!=typeof t[0]&&(a=Ve(Je,He(t[0],t[1])),t=[0,100]);const u=r({...this.options,keyframes:t});"mirror"===s&&(l=r({...this.options,keyframes:[...t].reverse(),velocity:-o})),null===u.calculatedDuration&&(u.calculatedDuration=_e(u));const{calculatedDuration:c}=u,h=c+i;return{generator:u,mirroredGenerator:l,mapPercentToKeyframes:a,calculatedDuration:c,resolvedDuration:h,totalDuration:h*(n+1)-i}}onPostResolved(){const{autoplay:t=!0}=this.options;this.play(),"paused"!==this.pendingPlayState&&t?this.state=this.pendingPlayState:this.pause()}tick(t,e=!1){const{resolved:n}=this;if(!n){const{keyframes:t}=this.options;return{done:!0,value:t[t.length-1]}}const{finalKeyframe:i,generator:s,mirroredGenerator:o,mapPercentToKeyframes:r,keyframes:a,calculatedDuration:l,totalDuration:u,resolvedDuration:c}=n;if(null===this.startTime)return s.next(0);const{delay:h,repeat:d,repeatType:p,repeatDelay:m,onUpdate:f}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,t):this.speed<0&&(this.startTime=Math.min(t-u/this.speed,this.startTime)),e?this.currentTime=t:null!==this.holdTime?this.currentTime=this.holdTime:this.currentTime=Math.round(t-this.startTime)*this.speed;const g=this.currentTime-h*(this.speed>=0?1:-1),y=this.speed>=0?g<0:g>u;this.currentTime=Math.max(g,0),"finished"===this.state&&null===this.holdTime&&(this.currentTime=u);let v=this.currentTime,x=s;if(d){const t=Math.min(this.currentTime,u)/c;let e=Math.floor(t),n=t%1;!n&&t>=1&&(n=1),1===n&&e--,e=Math.min(e,d+1);Boolean(e%2)&&("reverse"===p?(n=1-n,m&&(n-=m/c)):"mirror"===p&&(x=o)),v=nt(0,1,n)*c}const w=y?{done:!1,value:a[0]}:x.next(v);r&&(w.value=r(w.value));let{done:P}=w;y||null===l||(P=this.speed>=0?this.currentTime>=u:this.currentTime<=0);const S=null===this.holdTime&&("finished"===this.state||"running"===this.state&&P);return S&&void 0!==i&&(w.value=E(a,this.options,i)),f&&f(w.value),S&&this.finish(),w}get duration(){const{resolved:t}=this;return t?y(t.calculatedDuration):0}get time(){return y(this.currentTime)}set time(t){t=g(t),this.currentTime=t,null!==this.holdTime||0===this.speed?this.holdTime=t:this.driver&&(this.startTime=this.driver.now()-t/this.speed)}get speed(){return this.playbackSpeed}set speed(t){const e=this.playbackSpeed!==t;this.playbackSpeed=t,e&&(this.time=y(this.currentTime))}play(){if(this.resolver.isScheduled||this.resolver.resume(),!this._resolved)return void(this.pendingPlayState="running");if(this.isStopped)return;const{driver:t=qe,onPlay:e,startTime:n}=this.options;this.driver||(this.driver=t(t=>this.tick(t))),e&&e();const i=this.driver.now();null!==this.holdTime?this.startTime=i-this.holdTime:this.startTime?"finished"===this.state&&(this.startTime=i):this.startTime=null!=n?n:this.calcStartTime(),"finished"===this.state&&this.updateFinishedPromise(),this.cancelTime=this.startTime,this.holdTime=null,this.state="running",this.driver.start()}pause(){var t;this._resolved?(this.state="paused",this.holdTime=null!==(t=this.currentTime)&&void 0!==t?t:0):this.pendingPlayState="paused"}complete(){"running"!==this.state&&this.play(),this.pendingPlayState=this.state="finished",this.holdTime=null}finish(){this.teardown(),this.state="finished";const{onComplete:t}=this.options;t&&t()}cancel(){null!==this.cancelTime&&this.tick(this.cancelTime),this.teardown(),this.updateFinishedPromise()}teardown(){this.state="idle",this.stopDriver(),this.resolveFinishedPromise(),this.updateFinishedPromise(),this.startTime=this.cancelTime=null,this.resolver.cancel()}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(t){return this.startTime=0,this.tick(t,!0)}}function tn(t){return new Qe(t)}const en=new Set(["opacity","clipPath","filter","transform"]);function nn(t){let e;return()=>(void 0===e&&(e=t()),e)}const sn={linearEasing:void 0};function on(t,e){const n=nn(t);return()=>{var t;return null!==(t=sn[e])&&void 0!==t?t:n()}}const rn=on(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch(t){return!1}return!0},"linearEasing");function an(t){return Boolean("function"==typeof t&&rn()||!t||"string"==typeof t&&(t in un||rn())||Ae(t)||Array.isArray(t)&&t.every(an))}const ln=([t,e,n,i])=>`cubic-bezier(${t}, ${e}, ${n}, ${i})`,un={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:ln([0,.65,.55,1]),circOut:ln([.55,0,1,.45]),backIn:ln([.31,.01,.66,-.59]),backOut:ln([.33,1.53,.69,.99])};function cn(t,e){return t?"function"==typeof t&&rn()?((t,e)=>{let n="";const i=Math.max(Math.round(e/10),2);for(let e=0;e<i;e++)n+=t(Re(0,i-1,e))+", ";return`linear(${n.substring(0,n.length-2)})`})(t,e):Ae(t)?ln(t):Array.isArray(t)?t.map(t=>cn(t,e)||un.easeOut):un[t]:void 0}function hn(t,e,n,{delay:i=0,duration:s=300,repeat:o=0,repeatType:r="loop",ease:a,times:l}={}){const u={[e]:n};l&&(u.offset=l);const c=cn(a,s);return Array.isArray(c)&&(u.easing=c),t.animate(u,{delay:i,duration:s,easing:Array.isArray(c)?"linear":c,fill:"both",iterations:o+1,direction:"reverse"===r?"alternate":"normal"})}function dn(t,e){t.timeline=e,t.onfinish=null}const pn=nn(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));const mn={anticipate:N,backInOut:W,circInOut:H};class fn extends he{constructor(t){super(t);const{name:e,motionValue:n,element:i,keyframes:s}=this.options;this.resolver=new se(s,(t,e)=>this.onKeyframesResolved(t,e),e,n,i),this.resolver.scheduleResolve()}initPlayback(t,e){var n;let{duration:i=300,times:s,ease:o,type:r,motionValue:a,name:l,startTime:u}=this.options;if(!(null===(n=a.owner)||void 0===n?void 0:n.current))return!1;var c;if("string"==typeof o&&rn()&&o in mn&&(o=mn[o]),oe((c=this.options).type)||"spring"===c.type||!an(c.ease)){const{onComplete:e,onUpdate:n,motionValue:a,element:l,...u}=this.options,c=function(t,e){const n=new Qe({...e,keyframes:t,repeat:0,delay:0,isGenerator:!0});let i={done:!1,value:t[0]};const s=[];let o=0;for(;!i.done&&o<2e4;)i=n.sample(o),s.push(i.value),o+=10;return{times:void 0,keyframes:s,duration:o-10,ease:"linear"}}(t,u);1===(t=c.keyframes).length&&(t[1]=t[0]),i=c.duration,s=c.times,o=c.ease,r="keyframes"}const h=hn(a.owner.current,l,t,{...this.options,duration:i,times:s,ease:o});return h.startTime=null!=u?u:this.calcStartTime(),this.pendingTimeline?(dn(h,this.pendingTimeline),this.pendingTimeline=void 0):h.onfinish=()=>{const{onComplete:n}=this.options;a.set(E(t,this.options,e)),n&&n(),this.cancel(),this.resolveFinishedPromise()},{animation:h,duration:i,times:s,type:r,ease:o,keyframes:t}}get duration(){const{resolved:t}=this;if(!t)return 0;const{duration:e}=t;return y(e)}get time(){const{resolved:t}=this;if(!t)return 0;const{animation:e}=t;return y(e.currentTime||0)}set time(t){const{resolved:e}=this;if(!e)return;const{animation:n}=e;n.currentTime=g(t)}get speed(){const{resolved:t}=this;if(!t)return 1;const{animation:e}=t;return e.playbackRate}set speed(t){const{resolved:e}=this;if(!e)return;const{animation:n}=e;n.playbackRate=t}get state(){const{resolved:t}=this;if(!t)return"idle";const{animation:e}=t;return e.playState}get startTime(){const{resolved:t}=this;if(!t)return null;const{animation:e}=t;return e.startTime}attachTimeline(t){if(this._resolved){const{resolved:e}=this;if(!e)return C;const{animation:n}=e;dn(n,t)}else this.pendingTimeline=t;return C}play(){if(this.isStopped)return;const{resolved:t}=this;if(!t)return;const{animation:e}=t;"finished"===e.playState&&this.updateFinishedPromise(),e.play()}pause(){const{resolved:t}=this;if(!t)return;const{animation:e}=t;e.pause()}stop(){if(this.resolver.cancel(),this.isStopped=!0,"idle"===this.state)return;this.resolveFinishedPromise(),this.updateFinishedPromise();const{resolved:t}=this;if(!t)return;const{animation:e,keyframes:n,duration:i,type:s,ease:o,times:r}=t;if("idle"===e.playState||"finished"===e.playState)return;if(this.time){const{motionValue:t,onUpdate:e,onComplete:a,element:l,...u}=this.options,c=new Qe({...u,keyframes:n,duration:i,type:s,ease:o,times:r,isGenerator:!0}),h=g(this.time);t.setWithVelocity(c.sample(h-10).value,c.sample(h).value,10)}const{onStop:a}=this.options;a&&a(),this.cancel()}complete(){const{resolved:t}=this;t&&t.animation.finish()}cancel(){const{resolved:t}=this;t&&t.animation.cancel()}static supports(t){const{motionValue:e,name:n,repeatDelay:i,repeatType:s,damping:o,type:r}=t;return pn()&&n&&en.has(n)&&e&&e.owner&&e.owner.current instanceof HTMLElement&&!e.owner.getProps().onUpdate&&!i&&"mirror"!==s&&0!==o&&"inertia"!==r}}const gn=nn(()=>void 0!==window.ScrollTimeline);class yn{constructor(t){this.stop=()=>this.runAll("stop"),this.animations=t.filter(Boolean)}then(t,e){return Promise.all(this.animations).then(t).catch(e)}getAll(t){return this.animations[0][t]}setAll(t,e){for(let n=0;n<this.animations.length;n++)this.animations[n][t]=e}attachTimeline(t,e){const n=this.animations.map(n=>gn()&&n.attachTimeline?n.attachTimeline(t):e(n));return()=>{n.forEach((t,e)=>{t&&t(),this.animations[e].stop()})}}get time(){return this.getAll("time")}set time(t){this.setAll("time",t)}get speed(){return this.getAll("speed")}set speed(t){this.setAll("speed",t)}get startTime(){return this.getAll("startTime")}get duration(){let t=0;for(let e=0;e<this.animations.length;e++)t=Math.max(t,this.animations[e].duration);return t}runAll(t){this.animations.forEach(e=>e[t]())}play(){this.runAll("play")}pause(){this.runAll("pause")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}const vn=(t,e,n,i={},s,o)=>r=>{const a=S(i,t)||{},l=a.delay||i.delay||0;let{elapsed:u=0}=i;u-=g(l);let c={keyframes:Array.isArray(n)?n:[null,n],ease:"easeOut",velocity:e.getVelocity(),...a,delay:-u,onUpdate:t=>{e.set(t),a.onUpdate&&a.onUpdate(t)},onComplete:()=>{r(),a.onComplete&&a.onComplete()},name:t,motionValue:e,element:o?void 0:s};(function({when:t,delay:e,delayChildren:n,staggerChildren:i,staggerDirection:s,repeat:o,repeatType:r,repeatDelay:a,from:l,elapsed:u,...c}){return!!Object.keys(c).length})(a)||(c={...c,...P(t,c)}),c.duration&&(c.duration=g(c.duration)),c.repeatDelay&&(c.repeatDelay=g(c.repeatDelay)),void 0!==c.from&&(c.keyframes[0]=c.from);let h=!1;if((!1===c.type||0===c.duration&&!c.repeatDelay)&&(c.duration=0,0===c.delay&&(h=!0)),(b.current||T.skipAnimations)&&(h=!0,c.duration=0,c.delay=0),h&&!o&&void 0!==e.get()){const t=E(c.keyframes,a);if(void 0!==t)return R.update(()=>{c.onUpdate(t),c.onComplete()}),new yn([])}return!o&&fn.supports(c)?new fn(c):new Qe(c)};function xn(t,e){-1===t.indexOf(e)&&t.push(e)}function wn(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class Pn{constructor(){this.subscriptions=[]}add(t){return xn(this.subscriptions,t),()=>wn(this.subscriptions,t)}notify(t,e,n){const i=this.subscriptions.length;if(i)if(1===i)this.subscriptions[0](t,e,n);else for(let s=0;s<i;s++){const i=this.subscriptions[s];i&&i(t,e,n)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const Sn={current:void 0};class Tn{constructor(t,e={}){this.version="11.11.10",this.canTrackVelocity=null,this.events={},this.updateAndNotify=(t,e=!0)=>{const n=le.now();this.updatedAt!==n&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(t),this.current!==this.prev&&this.events.change&&this.events.change.notify(this.current),e&&this.events.renderRequest&&this.events.renderRequest.notify(this.current)},this.hasAnimated=!1,this.setCurrent(t),this.owner=e.owner}setCurrent(t){var e;this.current=t,this.updatedAt=le.now(),null===this.canTrackVelocity&&void 0!==t&&(this.canTrackVelocity=(e=this.current,!isNaN(parseFloat(e))))}setPrevFrameValue(t=this.current){this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt}onChange(t){return this.on("change",t)}on(t,e){this.events[t]||(this.events[t]=new Pn);const n=this.events[t].add(e);return"change"===t?()=>{n(),R.read(()=>{this.events.change.getSize()||this.stop()})}:n}clearListeners(){for(const t in this.events)this.events[t].clear()}attach(t,e){this.passiveEffect=t,this.stopPassiveEffect=e}set(t,e=!0){e&&this.passiveEffect?this.passiveEffect(t,this.updateAndNotify):this.updateAndNotify(t,e)}setWithVelocity(t,e,n){this.set(e),this.prev=void 0,this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt-n}jump(t,e=!0){this.updateAndNotify(t),this.prev=t,this.prevUpdatedAt=this.prevFrameValue=void 0,e&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return Sn.current&&Sn.current.push(this),this.current}getPrevious(){return this.prev}getVelocity(){const t=le.now();if(!this.canTrackVelocity||void 0===this.prevFrameValue||t-this.updatedAt>30)return 0;const e=Math.min(this.updatedAt-this.prevUpdatedAt,30);return de(parseFloat(this.current)-parseFloat(this.prevFrameValue),e)}start(t){return this.stop(),new Promise(e=>{this.hasAnimated=!0,this.animation=t(e),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function bn(t,e){return new Tn(t,e)}function An(t,e,n){t.hasValue(e)?t.getValue(e).set(n):t.addValue(e,bn(n))}function En(t,e){const n=h(t,e);let{transitionEnd:i={},transition:s={},...o}=n||{};o={...o,...i};for(const e in o){An(t,e,(a=o[e],r(a)?a[a.length-1]||0:a))}var a}const Cn=t=>t.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),Mn="data-"+Cn("framerAppearId");function Vn(t){return t.props[Mn]}const Rn=t=>Boolean(t&&t.getVelocity);function Dn(t,e){const n=t.getValue("willChange");if(i=n,Boolean(Rn(i)&&i.add))return n.add(e);var i}function kn({protectedKeys:t,needsAnimating:e},n){const i=t.hasOwnProperty(n)&&!0!==e[n];return e[n]=!1,i}function Ln(t,e,{delay:n=0,transitionOverride:i,type:s}={}){var o;let{transition:r=t.getDefaultTransition(),transitionEnd:a,...l}=e;i&&(r=i);const u=[],c=s&&t.animationState&&t.animationState.getState()[s];for(const e in l){const i=t.getValue(e,null!==(o=t.latestValues[e])&&void 0!==o?o:null),s=l[e];if(void 0===s||c&&kn(c,e))continue;const a={delay:n,...S(r||{},e)};let h=!1;if(window.MotionHandoffAnimation){const n=Vn(t);if(n){const t=window.MotionHandoffAnimation(n,e,R);null!==t&&(a.startTime=t,h=!0)}}Dn(t,e),i.start(vn(e,i,s,t.shouldReduceMotion&&f.has(e)?{type:!1}:a,t,h));const d=i.animation;d&&u.push(d)}return a&&Promise.all(u).then(()=>{R.update(()=>{a&&En(t,a)})}),u}function Bn(t,e,n={}){var i;const s=h(t,e,"exit"===n.type?null===(i=t.presenceContext)||void 0===i?void 0:i.custom:void 0);let{transition:o=t.getDefaultTransition()||{}}=s||{};n.transitionOverride&&(o=n.transitionOverride);const r=s?()=>Promise.all(Ln(t,s,n)):()=>Promise.resolve(),a=t.variantChildren&&t.variantChildren.size?(i=0)=>{const{delayChildren:s=0,staggerChildren:r,staggerDirection:a}=o;return function(t,e,n=0,i=0,s=1,o){const r=[],a=(t.variantChildren.size-1)*i,l=1===s?(t=0)=>t*i:(t=0)=>a-t*i;return Array.from(t.variantChildren).sort(Fn).forEach((t,i)=>{t.notify("AnimationStart",e),r.push(Bn(t,e,{...o,delay:n+l(i)}).then(()=>t.notify("AnimationComplete",e)))}),Promise.all(r)}(t,e,s+i,r,a,n)}:()=>Promise.resolve(),{when:l}=o;if(l){const[t,e]="beforeChildren"===l?[r,a]:[a,r];return t().then(()=>e())}return Promise.all([r(),a(n.delay)])}function Fn(t,e){return t.sortNodePosition(e)}function jn(t,e,n={}){let i;if(t.notify("AnimationStart",e),Array.isArray(e)){const s=e.map(e=>Bn(t,e,n));i=Promise.all(s)}else if("string"==typeof e)i=Bn(t,e,n);else{const s="function"==typeof e?h(t,e,n.custom):e;i=Promise.all(Ln(t,s,n))}return i.then(()=>{t.notify("AnimationComplete",e)})}const On=p.length;const In=[...d].reverse(),Un=d.length;function Wn(t){let e=function(t){return e=>Promise.all(e.map(({animation:e,options:n})=>jn(t,e,n)))}(t),n=$n(),i=!0;const s=e=>(n,i)=>{var s;const o=h(t,i,"exit"===e?null===(s=t.presenceContext)||void 0===s?void 0:s.custom:void 0);if(o){const{transition:t,transitionEnd:e,...i}=o;n={...n,...i,...e}}return n};function u(u){const{props:c}=t,h=function t(e){if(!e)return;if(!e.isControllingVariants){const n=e.parent&&t(e.parent)||{};return void 0!==e.props.initial&&(n.initial=e.props.initial),n}const n={};for(let t=0;t<On;t++){const i=p[t],s=e.props[i];(l(s)||!1===s)&&(n[i]=s)}return n}(t.parent)||{},d=[],m=new Set;let f={},g=1/0;for(let e=0;e<Un;e++){const p=In[e],y=n[p],v=void 0!==c[p]?c[p]:h[p],x=l(v),w=p===u?y.isActive:null;!1===w&&(g=e);let P=v===h[p]&&v!==c[p]&&x;if(P&&i&&t.manuallyAnimateOnMount&&(P=!1),y.protectedKeys={...f},!y.isActive&&null===w||!v&&!y.prevProp||o(v)||"boolean"==typeof v)continue;const S=Nn(y.prevProp,v);let T=S||p===u&&y.isActive&&!P&&x||e>g&&x,b=!1;const A=Array.isArray(v)?v:[v];let E=A.reduce(s(p),{});!1===w&&(E={});const{prevResolvedValues:C={}}=y,M={...C,...E},V=e=>{T=!0,m.has(e)&&(b=!0,m.delete(e)),y.needsAnimating[e]=!0;const n=t.getValue(e);n&&(n.liveStyle=!1)};for(const t in M){const e=E[t],n=C[t];if(f.hasOwnProperty(t))continue;let i=!1;i=r(e)&&r(n)?!a(e,n):e!==n,i?null!=e?V(t):m.add(t):void 0!==e&&m.has(t)?V(t):y.protectedKeys[t]=!0}y.prevProp=v,y.prevResolvedValues=E,y.isActive&&(f={...f,...E}),i&&t.blockInitialAnimation&&(T=!1);const R=!(P&&S)||b;T&&R&&d.push(...A.map(t=>({animation:t,options:{type:p}})))}if(m.size){const e={};m.forEach(n=>{const i=t.getBaseTarget(n),s=t.getValue(n);s&&(s.liveStyle=!0),e[n]=null!=i?i:null}),d.push({animation:e})}let y=Boolean(d.length);return!i||!1!==c.initial&&c.initial!==c.animate||t.manuallyAnimateOnMount||(y=!1),i=!1,y?e(d):Promise.resolve()}return{animateChanges:u,setActive:function(e,i){var s;if(n[e].isActive===i)return Promise.resolve();null===(s=t.variantChildren)||void 0===s||s.forEach(t=>{var n;return null===(n=t.animationState)||void 0===n?void 0:n.setActive(e,i)}),n[e].isActive=i;const o=u(e);for(const t in n)n[t].protectedKeys={};return o},setAnimateFunction:function(n){e=n(t)},getState:()=>n,reset:()=>{n=$n(),i=!0}}}function Nn(t,e){return"string"==typeof e?e!==t:!!Array.isArray(e)&&!a(e,t)}function zn(t=!1){return{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function $n(){return{animate:zn(!0),whileInView:zn(),whileHover:zn(),whileTap:zn(),whileDrag:zn(),whileFocus:zn(),exit:zn()}}class Hn{constructor(t){this.isMounted=!1,this.node=t}update(){}}let Yn=0;const Xn={animation:{Feature:class extends Hn{constructor(t){super(t),t.animationState||(t.animationState=Wn(t))}updateAnimationControlsSubscription(){const{animate:t}=this.node.getProps();o(t)&&(this.unmountControls=t.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:t}=this.node.getProps(),{animate:e}=this.node.prevProps||{};t!==e&&this.updateAnimationControlsSubscription()}unmount(){var t;this.node.animationState.reset(),null===(t=this.unmountControls)||void 0===t||t.call(this)}}},exit:{Feature:class extends Hn{constructor(){super(...arguments),this.id=Yn++}update(){if(!this.node.presenceContext)return;const{isPresent:t,onExitComplete:e}=this.node.presenceContext,{isPresent:n}=this.node.prevPresenceContext||{};if(!this.node.animationState||t===n)return;const i=this.node.animationState.setActive("exit",!t);e&&!t&&i.then(()=>e(this.id))}mount(){const{register:t}=this.node.presenceContext||{};t&&(this.unmount=t(this.id))}unmount(){}}}},Gn=t=>"mouse"===t.pointerType?"number"!=typeof t.button||t.button<=0:!1!==t.isPrimary;function Kn(t,e="page"){return{point:{x:t[e+"X"],y:t[e+"Y"]}}}const _n=t=>e=>Gn(e)&&t(e,Kn(e));function qn(t,e,n,i={passive:!0}){return t.addEventListener(e,n,i),()=>t.removeEventListener(e,n)}function Zn(t,e,n,i){return qn(t,e,_n(n),i)}const Jn=(t,e)=>Math.abs(t-e);function Qn(t,e){const n=Jn(t.x,e.x),i=Jn(t.y,e.y);return Math.sqrt(n**2+i**2)}class ti{constructor(t,e,{transformPagePoint:n,contextWindow:i,dragSnapToOrigin:s=!1}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!this.lastMoveEvent||!this.lastMoveEventInfo)return;const t=ii(this.lastMoveEventInfo,this.history),e=null!==this.startEvent,n=Qn(t.offset,{x:0,y:0})>=3;if(!e&&!n)return;const{point:i}=t,{timestamp:s}=k;this.history.push({...i,timestamp:s});const{onStart:o,onMove:r}=this.handlers;e||(o&&o(this.lastMoveEvent,t),this.startEvent=this.lastMoveEvent),r&&r(this.lastMoveEvent,t)},this.handlePointerMove=(t,e)=>{this.lastMoveEvent=t,this.lastMoveEventInfo=ei(e,this.transformPagePoint),R.update(this.updatePoint,!0)},this.handlePointerUp=(t,e)=>{this.end();const{onEnd:n,onSessionEnd:i,resumeAnimation:s}=this.handlers;if(this.dragSnapToOrigin&&s&&s(),!this.lastMoveEvent||!this.lastMoveEventInfo)return;const o=ii("pointercancel"===t.type?this.lastMoveEventInfo:ei(e,this.transformPagePoint),this.history);this.startEvent&&n&&n(t,o),i&&i(t,o)},!Gn(t))return;this.dragSnapToOrigin=s,this.handlers=e,this.transformPagePoint=n,this.contextWindow=i||window;const o=ei(Kn(t),this.transformPagePoint),{point:r}=o,{timestamp:a}=k;this.history=[{...r,timestamp:a}];const{onSessionStart:l}=e;l&&l(t,ii(o,this.history)),this.removeListeners=Ve(Zn(this.contextWindow,"pointermove",this.handlePointerMove),Zn(this.contextWindow,"pointerup",this.handlePointerUp),Zn(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(t){this.handlers=t}end(){this.removeListeners&&this.removeListeners(),D(this.updatePoint)}}function ei(t,e){return e?{point:e(t.point)}:t}function ni(t,e){return{x:t.x-e.x,y:t.y-e.y}}function ii({point:t},e){return{point:t,delta:ni(t,oi(e)),offset:ni(t,si(e)),velocity:ri(e,.1)}}function si(t){return t[0]}function oi(t){return t[t.length-1]}function ri(t,e){if(t.length<2)return{x:0,y:0};let n=t.length-1,i=null;const s=oi(t);for(;n>=0&&(i=t[n],!(s.timestamp-i.timestamp>g(e)));)n--;if(!i)return{x:0,y:0};const o=y(s.timestamp-i.timestamp);if(0===o)return{x:0,y:0};const r={x:(s.x-i.x)/o,y:(s.y-i.y)/o};return r.x===1/0&&(r.x=0),r.y===1/0&&(r.y=0),r}function ai(t){let e=null;return()=>{const n=()=>{e=null};return null===e&&(e=t,n)}}const li=ai("dragHorizontal"),ui=ai("dragVertical");function ci(t){let e=!1;if("y"===t)e=ui();else if("x"===t)e=li();else{const t=li(),n=ui();t&&n?e=()=>{t(),n()}:(t&&t(),n&&n())}return e}function hi(){const t=ci(!0);return!t||(t(),!1)}function di(t){return t&&"object"==typeof t&&Object.prototype.hasOwnProperty.call(t,"current")}function pi(t){return t.max-t.min}function mi(t,e,n,i=.5){t.origin=i,t.originPoint=De(e.min,e.max,t.origin),t.scale=pi(n)/pi(e),t.translate=De(n.min,n.max,t.origin)-t.originPoint,(t.scale>=.9999&&t.scale<=1.0001||isNaN(t.scale))&&(t.scale=1),(t.translate>=-.01&&t.translate<=.01||isNaN(t.translate))&&(t.translate=0)}function fi(t,e,n,i){mi(t.x,e.x,n.x,i?i.originX:void 0),mi(t.y,e.y,n.y,i?i.originY:void 0)}function gi(t,e,n){t.min=n.min+e.min,t.max=t.min+pi(e)}function yi(t,e,n){t.min=e.min-n.min,t.max=t.min+pi(e)}function vi(t,e,n){yi(t.x,e.x,n.x),yi(t.y,e.y,n.y)}function xi(t,e,n){return{min:void 0!==e?t.min+e:void 0,max:void 0!==n?t.max+n-(t.max-t.min):void 0}}function wi(t,e){let n=e.min-t.min,i=e.max-t.max;return e.max-e.min<t.max-t.min&&([n,i]=[i,n]),{min:n,max:i}}const Pi=.35;function Si(t,e,n){return{min:Ti(t,e),max:Ti(t,n)}}function Ti(t,e){return"number"==typeof t?t:t[e]||0}const bi=()=>({x:{min:0,max:0},y:{min:0,max:0}});function Ai(t){return[t("x"),t("y")]}function Ei({top:t,left:e,right:n,bottom:i}){return{x:{min:e,max:n},y:{min:t,max:i}}}function Ci(t){return void 0===t||1===t}function Mi({scale:t,scaleX:e,scaleY:n}){return!Ci(t)||!Ci(e)||!Ci(n)}function Vi(t){return Mi(t)||Ri(t)||t.z||t.rotate||t.rotateX||t.rotateY||t.skewX||t.skewY}function Ri(t){return Di(t.x)||Di(t.y)}function Di(t){return t&&"0%"!==t}function ki(t,e,n){return n+e*(t-n)}function Li(t,e,n,i,s){return void 0!==s&&(t=ki(t,s,i)),ki(t,n,i)+e}function Bi(t,e=0,n=1,i,s){t.min=Li(t.min,e,n,i,s),t.max=Li(t.max,e,n,i,s)}function Fi(t,{x:e,y:n}){Bi(t.x,e.translate,e.scale,e.originPoint),Bi(t.y,n.translate,n.scale,n.originPoint)}function ji(t,e){t.min=t.min+e,t.max=t.max+e}function Oi(t,e,n,i,s=.5){Bi(t,e,n,De(t.min,t.max,s),i)}function Ii(t,e){Oi(t.x,e.x,e.scaleX,e.scale,e.originX),Oi(t.y,e.y,e.scaleY,e.scale,e.originY)}function Ui(t,e){return Ei(function(t,e){if(!e)return t;const n=e({x:t.left,y:t.top}),i=e({x:t.right,y:t.bottom});return{top:n.y,left:n.x,bottom:i.y,right:i.x}}(t.getBoundingClientRect(),e))}const Wi=({current:t})=>t?t.ownerDocument.defaultView:null,Ni=new WeakMap;class zi{constructor(t){this.openGlobalLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic={x:{min:0,max:0},y:{min:0,max:0}},this.visualElement=t}start(t,{snapToCursor:e=!1}={}){const{presenceContext:n}=this.visualElement;if(n&&!1===n.isPresent)return;const{dragSnapToOrigin:i}=this.getProps();this.panSession=new ti(t,{onSessionStart:t=>{const{dragSnapToOrigin:n}=this.getProps();n?this.pauseAnimation():this.stopAnimation(),e&&this.snapToCursor(Kn(t,"page").point)},onStart:(t,e)=>{const{drag:n,dragPropagation:i,onDragStart:s}=this.getProps();if(n&&!i&&(this.openGlobalLock&&this.openGlobalLock(),this.openGlobalLock=ci(n),!this.openGlobalLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),Ai(t=>{let e=this.getAxisMotionValue(t).get()||0;if(lt.test(e)){const{projection:n}=this.visualElement;if(n&&n.layout){const i=n.layout.layoutBox[t];if(i){e=pi(i)*(parseFloat(e)/100)}}}this.originPoint[t]=e}),s&&R.postRender(()=>s(t,e)),Dn(this.visualElement,"transform");const{animationState:o}=this.visualElement;o&&o.setActive("whileDrag",!0)},onMove:(t,e)=>{const{dragPropagation:n,dragDirectionLock:i,onDirectionLock:s,onDrag:o}=this.getProps();if(!n&&!this.openGlobalLock)return;const{offset:r}=e;if(i&&null===this.currentDirection)return this.currentDirection=function(t,e=10){let n=null;Math.abs(t.y)>e?n="y":Math.abs(t.x)>e&&(n="x");return n}(r),void(null!==this.currentDirection&&s&&s(this.currentDirection));this.updateAxis("x",e.point,r),this.updateAxis("y",e.point,r),this.visualElement.render(),o&&o(t,e)},onSessionEnd:(t,e)=>this.stop(t,e),resumeAnimation:()=>Ai(t=>{var e;return"paused"===this.getAnimationState(t)&&(null===(e=this.getAxisMotionValue(t).animation)||void 0===e?void 0:e.play())})},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:i,contextWindow:Wi(this.visualElement)})}stop(t,e){const n=this.isDragging;if(this.cancel(),!n)return;const{velocity:i}=e;this.startAnimation(i);const{onDragEnd:s}=this.getProps();s&&R.postRender(()=>s(t,e))}cancel(){this.isDragging=!1;const{projection:t,animationState:e}=this.visualElement;t&&(t.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:n}=this.getProps();!n&&this.openGlobalLock&&(this.openGlobalLock(),this.openGlobalLock=null),e&&e.setActive("whileDrag",!1)}updateAxis(t,e,n){const{drag:i}=this.getProps();if(!n||!$i(t,i,this.currentDirection))return;const s=this.getAxisMotionValue(t);let o=this.originPoint[t]+n[t];this.constraints&&this.constraints[t]&&(o=function(t,{min:e,max:n},i){return void 0!==e&&t<e?t=i?De(e,t,i.min):Math.max(t,e):void 0!==n&&t>n&&(t=i?De(n,t,i.max):Math.min(t,n)),t}(o,this.constraints[t],this.elastic[t])),s.set(o)}resolveConstraints(){var t;const{dragConstraints:e,dragElastic:n}=this.getProps(),i=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):null===(t=this.visualElement.projection)||void 0===t?void 0:t.layout,s=this.constraints;e&&di(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):this.constraints=!(!e||!i)&&function(t,{top:e,left:n,bottom:i,right:s}){return{x:xi(t.x,n,s),y:xi(t.y,e,i)}}(i.layoutBox,e),this.elastic=function(t=Pi){return!1===t?t=0:!0===t&&(t=Pi),{x:Si(t,"left","right"),y:Si(t,"top","bottom")}}(n),s!==this.constraints&&i&&this.constraints&&!this.hasMutatedConstraints&&Ai(t=>{!1!==this.constraints&&this.getAxisMotionValue(t)&&(this.constraints[t]=function(t,e){const n={};return void 0!==e.min&&(n.min=e.min-t.min),void 0!==e.max&&(n.max=e.max-t.min),n}(i.layoutBox[t],this.constraints[t]))})}resolveRefConstraints(){const{dragConstraints:t,onMeasureDragConstraints:e}=this.getProps();if(!t||!di(t))return!1;const n=t.current,{projection:i}=this.visualElement;if(!i||!i.layout)return!1;const s=function(t,e,n){const i=Ui(t,n),{scroll:s}=e;return s&&(ji(i.x,s.offset.x),ji(i.y,s.offset.y)),i}(n,i.root,this.visualElement.getTransformPagePoint());let o=function(t,e){return{x:wi(t.x,e.x),y:wi(t.y,e.y)}}(i.layout.layoutBox,s);if(e){const t=e(function({x:t,y:e}){return{top:e.min,right:t.max,bottom:e.max,left:t.min}}(o));this.hasMutatedConstraints=!!t,t&&(o=Ei(t))}return o}startAnimation(t){const{drag:e,dragMomentum:n,dragElastic:i,dragTransition:s,dragSnapToOrigin:o,onDragTransitionEnd:r}=this.getProps(),a=this.constraints||{},l=Ai(r=>{if(!$i(r,e,this.currentDirection))return;let l=a&&a[r]||{};o&&(l={min:0,max:0});const u=i?200:1e6,c=i?40:1e7,h={type:"inertia",velocity:n?t[r]:0,bounceStiffness:u,bounceDamping:c,timeConstant:750,restDelta:1,restSpeed:10,...s,...l};return this.startAxisValueAnimation(r,h)});return Promise.all(l).then(r)}startAxisValueAnimation(t,e){const n=this.getAxisMotionValue(t);return Dn(this.visualElement,t),n.start(vn(t,n,0,e,this.visualElement,!1))}stopAnimation(){Ai(t=>this.getAxisMotionValue(t).stop())}pauseAnimation(){Ai(t=>{var e;return null===(e=this.getAxisMotionValue(t).animation)||void 0===e?void 0:e.pause()})}getAnimationState(t){var e;return null===(e=this.getAxisMotionValue(t).animation)||void 0===e?void 0:e.state}getAxisMotionValue(t){const e="_drag"+t.toUpperCase(),n=this.visualElement.getProps(),i=n[e];return i||this.visualElement.getValue(t,(n.initial?n.initial[t]:void 0)||0)}snapToCursor(t){Ai(e=>{const{drag:n}=this.getProps();if(!$i(e,n,this.currentDirection))return;const{projection:i}=this.visualElement,s=this.getAxisMotionValue(e);if(i&&i.layout){const{min:n,max:o}=i.layout.layoutBox[e];s.set(t[e]-De(n,o,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:t,dragConstraints:e}=this.getProps(),{projection:n}=this.visualElement;if(!di(e)||!n||!this.constraints)return;this.stopAnimation();const i={x:0,y:0};Ai(t=>{const e=this.getAxisMotionValue(t);if(e&&!1!==this.constraints){const n=e.get();i[t]=function(t,e){let n=.5;const i=pi(t),s=pi(e);return s>i?n=Re(e.min,e.max-i,t.min):i>s&&(n=Re(t.min,t.max-s,e.min)),nt(0,1,n)}({min:n,max:n},this.constraints[t])}});const{transformTemplate:s}=this.visualElement.getProps();this.visualElement.current.style.transform=s?s({},""):"none",n.root&&n.root.updateScroll(),n.updateLayout(),this.resolveConstraints(),Ai(e=>{if(!$i(e,t,null))return;const n=this.getAxisMotionValue(e),{min:s,max:o}=this.constraints[e];n.set(De(s,o,i[e]))})}addListeners(){if(!this.visualElement.current)return;Ni.set(this.visualElement,this);const t=Zn(this.visualElement.current,"pointerdown",t=>{const{drag:e,dragListener:n=!0}=this.getProps();e&&n&&this.start(t)}),e=()=>{const{dragConstraints:t}=this.getProps();di(t)&&t.current&&(this.constraints=this.resolveRefConstraints())},{projection:n}=this.visualElement,i=n.addEventListener("measure",e);n&&!n.layout&&(n.root&&n.root.updateScroll(),n.updateLayout()),R.read(e);const s=qn(window,"resize",()=>this.scalePositionWithinConstraints()),o=n.addEventListener("didUpdate",({delta:t,hasLayoutChanged:e})=>{this.isDragging&&e&&(Ai(e=>{const n=this.getAxisMotionValue(e);n&&(this.originPoint[e]+=t[e].translate,n.set(n.get()+t[e].translate))}),this.visualElement.render())});return()=>{s(),t(),i(),o&&o()}}getProps(){const t=this.visualElement.getProps(),{drag:e=!1,dragDirectionLock:n=!1,dragPropagation:i=!1,dragConstraints:s=!1,dragElastic:o=Pi,dragMomentum:r=!0}=t;return{...t,drag:e,dragDirectionLock:n,dragPropagation:i,dragConstraints:s,dragElastic:o,dragMomentum:r}}}function $i(t,e,n){return!(!0!==e&&e!==t||null!==n&&n!==t)}const Hi=t=>(e,n)=>{t&&R.postRender(()=>t(e,n))};const Yi=["TopLeft","TopRight","BottomLeft","BottomRight"],Xi=Yi.length,Gi=t=>"string"==typeof t?parseFloat(t):t,Ki=t=>"number"==typeof t||ut.test(t);function _i(t,e){return void 0!==t[e]?t[e]:t.borderRadius}const qi=Ji(0,.5,$),Zi=Ji(.5,.95,C);function Ji(t,e,n){return i=>i<t?0:i>e?1:n(Re(t,e,i))}function Qi(t,e){t.min=e.min,t.max=e.max}function ts(t,e){Qi(t.x,e.x),Qi(t.y,e.y)}function es(t,e){t.translate=e.translate,t.scale=e.scale,t.originPoint=e.originPoint,t.origin=e.origin}function ns(t,e,n,i,s){return t=ki(t-=e,1/n,i),void 0!==s&&(t=ki(t,1/s,i)),t}function is(t,e,[n,i,s],o,r){!function(t,e=0,n=1,i=.5,s,o=t,r=t){if(lt.test(e)){e=parseFloat(e);e=De(r.min,r.max,e/100)-r.min}if("number"!=typeof e)return;let a=De(o.min,o.max,i);t===o&&(a-=e),t.min=ns(t.min,e,n,a,s),t.max=ns(t.max,e,n,a,s)}(t,e[n],e[i],e[s],e.scale,o,r)}const ss=["x","scaleX","originX"],os=["y","scaleY","originY"];function rs(t,e,n,i){is(t.x,e,ss,n?n.x:void 0,i?i.x:void 0),is(t.y,e,os,n?n.y:void 0,i?i.y:void 0)}function as(t){return 0===t.translate&&1===t.scale}function ls(t){return as(t.x)&&as(t.y)}function us(t,e){return t.min===e.min&&t.max===e.max}function cs(t,e){return Math.round(t.min)===Math.round(e.min)&&Math.round(t.max)===Math.round(e.max)}function hs(t,e){return cs(t.x,e.x)&&cs(t.y,e.y)}function ds(t){return pi(t.x)/pi(t.y)}function ps(t,e){return t.translate===e.translate&&t.scale===e.scale&&t.originPoint===e.originPoint}class ms{constructor(){this.members=[]}add(t){xn(this.members,t),t.scheduleRender()}remove(t){if(wn(this.members,t),t===this.prevLead&&(this.prevLead=void 0),t===this.lead){const t=this.members[this.members.length-1];t&&this.promote(t)}}relegate(t){const e=this.members.findIndex(e=>t===e);if(0===e)return!1;let n;for(let t=e;t>=0;t--){const e=this.members[t];if(!1!==e.isPresent){n=e;break}}return!!n&&(this.promote(n),!0)}promote(t,e){const n=this.lead;if(t!==n&&(this.prevLead=n,this.lead=t,t.show(),n)){n.instance&&n.scheduleRender(),t.scheduleRender(),t.resumeFrom=n,e&&(t.resumeFrom.preserveOpacity=!0),n.snapshot&&(t.snapshot=n.snapshot,t.snapshot.latestValues=n.animationValues||n.latestValues),t.root&&t.root.isUpdating&&(t.isLayoutDirty=!0);const{crossfade:i}=t.options;!1===i&&n.hide()}}exitAnimationComplete(){this.members.forEach(t=>{const{options:e,resumingFrom:n}=t;e.onExitComplete&&e.onExitComplete(),n&&n.options.onExitComplete&&n.options.onExitComplete()})}scheduleRender(){this.members.forEach(t=>{t.instance&&t.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}const fs={};function gs(t){Object.assign(fs,t)}const ys=(t,e)=>t.depth-e.depth;class vs{constructor(){this.children=[],this.isDirty=!1}add(t){xn(this.children,t),this.isDirty=!0}remove(t){wn(this.children,t),this.isDirty=!0}forEach(t){this.isDirty&&this.children.sort(ys),this.isDirty=!1,this.children.forEach(t)}}function xs(t){const e=Rn(t)?t.get():t;return n=e,Boolean(n&&"object"==typeof n&&n.mix&&n.toValue)?e.toValue():e;var n}const ws={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function Ps(t,e){const n=le.now(),i=({timestamp:s})=>{const o=s-n;o>=e&&(D(i),t(o-e))};return R.read(i,!0),()=>D(i)}function Ss(t,e=100,n){const i=n({...t,keyframes:[0,e]}),s=Math.min(_e(i),2e4);return{type:"keyframes",ease:t=>i.next(s*t).value/e,duration:y(s)}}function Ts(t,e,n){var i;if("string"==typeof t){let s=document;e&&(G(Boolean(e.current)),s=e.current),n?(null!==(i=n[t])&&void 0!==i||(n[t]=s.querySelectorAll(t)),t=n[t]):t=s.querySelectorAll(t)}else t instanceof Element&&(t=[t]);return Array.from(t||[])}function bs(t){return"object"==typeof t&&!Array.isArray(t)}function As(t,e,n,i){return"string"==typeof t&&bs(e)?Ts(t,n,i):t instanceof NodeList?Array.from(t):Array.isArray(t)?t:[t]}function Es(t,e,n,i){var s;return"number"==typeof e?e:e.startsWith("-")||e.startsWith("+")?Math.max(0,t+parseFloat(e)):"<"===e?n:null!==(s=i.get(e))&&void 0!==s?s:t}const Cs=(t,e,n)=>{const i=e-t;return((n-t)%i+i)%i+t};function Ms(t,e){return be(t)?t[Cs(0,t.length,e)]:t}function Vs(t,e,n,i,s,o){!function(t,e,n){for(let i=0;i<t.length;i++){const s=t[i];s.at>e&&s.at<n&&(wn(t,s),i--)}}(t,s,o);for(let r=0;r<e.length;r++)t.push({value:e[r],at:De(s,o,i[r]),easing:Ms(n,r)})}function Rs(t,e){return t.at===e.at?null===t.value?1:null===e.value?-1:0:t.at-e.at}function Ds(t,e){return!e.has(t)&&e.set(t,{}),e.get(t)}function ks(t,e){return e[t]||(e[t]=[]),e[t]}function Ls(t){return Array.isArray(t)?t:[t]}function Bs(t,e){return t&&t[e]?{...t,...t[e]}:{...t}}const Fs=t=>"number"==typeof t,js=t=>t.every(Fs),Os=new WeakMap;function Is(t){return t instanceof SVGElement&&"svg"!==t.tagName}function Us(t,{layout:e,layoutId:n}){return f.has(t)||t.startsWith("origin")||(e||void 0!==n)&&(!!fs[t]||"opacity"===t)}function Ws(t,e,n){var i;const{style:s}=t,o={};for(const r in s)(Rn(s[r])||e.style&&Rn(e.style[r])||Us(r,t)||void 0!==(null===(i=null==n?void 0:n.getValue(r))||void 0===i?void 0:i.liveStyle))&&(o[r]=s[r]);return o}function Ns(t,e,n){const i=Ws(t,e,n);for(const n in t)if(Rn(t[n])||Rn(e[n])){i[-1!==m.indexOf(n)?"attr"+n.charAt(0).toUpperCase()+n.substring(1):n]=t[n]}return i}const zs="undefined"!=typeof window,$s={current:null},Hs={current:!1};function Ys(){if(Hs.current=!0,zs)if(window.matchMedia){const t=window.matchMedia("(prefers-reduced-motion)"),e=()=>$s.current=t.matches;t.addListener(e),e()}else $s.current=!1}function Xs(t){return o(t.animate)||p.some(e=>l(t[e]))}function Gs(t){return Boolean(Xs(t)||t.variants)}const Ks={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},_s={};for(const t in Ks)_s[t]={isEnabled:e=>Ks[t].some(t=>!!e[t])};const qs=[...Pt,It,Yt],Zs=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class Js{scrapeMotionValuesFromProps(t,e,n){return{}}constructor({parent:t,props:e,presenceContext:n,reducedMotionConfig:i,blockInitialAnimation:s,visualState:o},r={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=Mt,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const t=le.now();this.renderScheduledAt<t&&(this.renderScheduledAt=t,R.render(this.render,!1,!0))};const{latestValues:a,renderState:l}=o;this.latestValues=a,this.baseTarget={...a},this.initialValues=e.initial?{...a}:{},this.renderState=l,this.parent=t,this.props=e,this.presenceContext=n,this.depth=t?t.depth+1:0,this.reducedMotionConfig=i,this.options=r,this.blockInitialAnimation=Boolean(s),this.isControllingVariants=Xs(e),this.isVariantNode=Gs(e),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=Boolean(t&&t.current);const{willChange:u,...c}=this.scrapeMotionValuesFromProps(e,{},this);for(const t in c){const e=c[t];void 0!==a[t]&&Rn(e)&&e.set(a[t],!1)}}mount(t){this.current=t,Os.set(t,this),this.projection&&!this.projection.instance&&this.projection.mount(t),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((t,e)=>this.bindToMotionValue(e,t)),Hs.current||Ys(),this.shouldReduceMotion="never"!==this.reducedMotionConfig&&("always"===this.reducedMotionConfig||$s.current),this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){Os.delete(this.current),this.projection&&this.projection.unmount(),D(this.notifyUpdate),D(this.render),this.valueSubscriptions.forEach(t=>t()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const t in this.events)this.events[t].clear();for(const t in this.features){const e=this.features[t];e&&(e.unmount(),e.isMounted=!1)}this.current=null}bindToMotionValue(t,e){this.valueSubscriptions.has(t)&&this.valueSubscriptions.get(t)();const n=f.has(t),i=e.on("change",e=>{this.latestValues[t]=e,this.props.onUpdate&&R.preRender(this.notifyUpdate),n&&this.projection&&(this.projection.isTransformDirty=!0)}),s=e.on("renderRequest",this.scheduleRender);let o;window.MotionCheckAppearSync&&(o=window.MotionCheckAppearSync(this,t,e)),this.valueSubscriptions.set(t,()=>{i(),s(),o&&o(),e.owner&&e.stop()})}sortNodePosition(t){return this.current&&this.sortInstanceNodePosition&&this.type===t.type?this.sortInstanceNodePosition(this.current,t.current):0}updateFeatures(){let t="animation";for(t in _s){const e=_s[t];if(!e)continue;const{isEnabled:n,Feature:i}=e;if(!this.features[t]&&i&&n(this.props)&&(this.features[t]=new i(this)),this.features[t]){const e=this.features[t];e.isMounted?e.update():(e.mount(),e.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):{x:{min:0,max:0},y:{min:0,max:0}}}getStaticValue(t){return this.latestValues[t]}setStaticValue(t,e){this.latestValues[t]=e}update(t,e){(t.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=t,this.prevPresenceContext=this.presenceContext,this.presenceContext=e;for(let e=0;e<Zs.length;e++){const n=Zs[e];this.propEventSubscriptions[n]&&(this.propEventSubscriptions[n](),delete this.propEventSubscriptions[n]);const i=t["on"+n];i&&(this.propEventSubscriptions[n]=this.on(n,i))}this.prevMotionValues=function(t,e,n){for(const i in e){const s=e[i],o=n[i];if(Rn(s))t.addValue(i,s);else if(Rn(o))t.addValue(i,bn(s,{owner:t}));else if(o!==s)if(t.hasValue(i)){const e=t.getValue(i);!0===e.liveStyle?e.jump(s):e.hasAnimated||e.set(s)}else{const e=t.getStaticValue(i);t.addValue(i,bn(void 0!==e?e:s,{owner:t}))}}for(const i in n)void 0===e[i]&&t.removeValue(i);return e}(this,this.scrapeMotionValuesFromProps(t,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(t){return this.props.variants?this.props.variants[t]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(t){const e=this.getClosestVariantNode();if(e)return e.variantChildren&&e.variantChildren.add(t),()=>e.variantChildren.delete(t)}addValue(t,e){const n=this.values.get(t);e!==n&&(n&&this.removeValue(t),this.bindToMotionValue(t,e),this.values.set(t,e),this.latestValues[t]=e.get())}removeValue(t){this.values.delete(t);const e=this.valueSubscriptions.get(t);e&&(e(),this.valueSubscriptions.delete(t)),delete this.latestValues[t],this.removeValueFromRenderState(t,this.renderState)}hasValue(t){return this.values.has(t)}getValue(t,e){if(this.props.values&&this.props.values[t])return this.props.values[t];let n=this.values.get(t);return void 0===n&&void 0!==e&&(n=bn(null===e?void 0:e,{owner:this}),this.addValue(t,n)),n}readValue(t,e){var n;let i=void 0===this.latestValues[t]&&this.current?null!==(n=this.getBaseTargetFromProps(this.props,t))&&void 0!==n?n:this.readValueFromInstance(this.current,t,this.options):this.latestValues[t];var s;return null!=i&&("string"==typeof i&&(K(i)||Y(i))?i=parseFloat(i):(s=i,!qs.find(wt(s))&&Yt.test(e)&&(i=ne(t,e))),this.setBaseTarget(t,Rn(i)?i.get():i)),Rn(i)?i.get():i}setBaseTarget(t,e){this.baseTarget[t]=e}getBaseTarget(t){var e;const{initial:n}=this.props;let i;if("string"==typeof n||"object"==typeof n){const s=c(this.props,n,null===(e=this.presenceContext)||void 0===e?void 0:e.custom);s&&(i=s[t])}if(n&&void 0!==i)return i;const s=this.getBaseTargetFromProps(this.props,t);return void 0===s||Rn(s)?void 0!==this.initialValues[t]&&void 0===i?void 0:this.baseTarget[t]:s}on(t,e){return this.events[t]||(this.events[t]=new Pn),this.events[t].add(e)}notify(t,...e){this.events[t]&&this.events[t].notify(...e)}}class Qs extends Js{constructor(){super(...arguments),this.KeyframeResolver=se}sortInstanceNodePosition(t,e){return 2&t.compareDocumentPosition(e)?1:-1}getBaseTargetFromProps(t,e){return t.style?t.style[e]:void 0}removeValueFromRenderState(t,{vars:e,style:n}){delete e[t],delete n[t]}}const to=(t,e)=>e&&"number"==typeof t?e.transform(t):t,eo={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},no=m.length;function io(t,e,n){let i="",s=!0;for(let o=0;o<no;o++){const r=m[o],a=t[r];if(void 0===a)continue;let l=!0;if(l="number"==typeof a?a===(r.startsWith("scale")?1:0):0===parseFloat(a),!l||n){const t=to(a,Qt[r]);if(!l){s=!1;i+=`${eo[r]||r}(${t}) `}n&&(e[r]=t)}}return i=i.trim(),n?i=n(e,s?"":i):s&&(i="none"),i}function so(t,e,n){const{style:i,vars:s,transformOrigin:o}=t;let r=!1,a=!1;for(const t in e){const n=e[t];if(f.has(t))r=!0;else if(q(t))s[t]=n;else{const e=to(n,Qt[t]);t.startsWith("origin")?(a=!0,o[t]=e):i[t]=e}}if(e.transform||(r||n?i.transform=io(e,t.transform,n):i.transform&&(i.transform="none")),a){const{originX:t="50%",originY:e="50%",originZ:n=0}=o;i.transformOrigin=`${t} ${e} ${n}`}}function oo(t,e,n){return"string"==typeof t?t:ut.transform(e+n*t)}const ro={offset:"stroke-dashoffset",array:"stroke-dasharray"},ao={offset:"strokeDashoffset",array:"strokeDasharray"};function lo(t,{attrX:e,attrY:n,attrScale:i,originX:s,originY:o,pathLength:r,pathSpacing:a=1,pathOffset:l=0,...u},c,h){if(so(t,u,h),c)return void(t.style.viewBox&&(t.attrs.viewBox=t.style.viewBox));t.attrs=t.style,t.style={};const{attrs:d,style:p,dimensions:m}=t;d.transform&&(m&&(p.transform=d.transform),delete d.transform),m&&(void 0!==s||void 0!==o||p.transform)&&(p.transformOrigin=function(t,e,n){return`${oo(e,t.x,t.width)} ${oo(n,t.y,t.height)}`}(m,void 0!==s?s:.5,void 0!==o?o:.5)),void 0!==e&&(d.x=e),void 0!==n&&(d.y=n),void 0!==i&&(d.scale=i),void 0!==r&&function(t,e,n=1,i=0,s=!0){t.pathLength=1;const o=s?ro:ao;t[o.offset]=ut.transform(-i);const r=ut.transform(e),a=ut.transform(n);t[o.array]=`${r} ${a}`}(d,r,a,l,!1)}const uo=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function co(t,{style:e,vars:n},i,s){Object.assign(t.style,e,s&&s.getProjectionStyles(i));for(const e in n)t.style.setProperty(e,n[e])}function ho(t,e,n,i){co(t,e,void 0,i);for(const n in e.attrs)t.setAttribute(uo.has(n)?n:Cn(n),e.attrs[n])}const po=t=>"string"==typeof t&&"svg"===t.toLowerCase();class mo extends Qs{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=bi}getBaseTargetFromProps(t,e){return t[e]}readValueFromInstance(t,e){if(f.has(e)){const t=ee(e);return t&&t.default||0}return e=uo.has(e)?e:Cn(e),t.getAttribute(e)}scrapeMotionValuesFromProps(t,e,n){return Ns(t,e,n)}build(t,e,n){lo(t,e,this.isSVGTag,n.transformTemplate)}renderInstance(t,e,n,i){ho(t,e,0,i)}mount(t){this.isSVGTag=po(t.tagName),super.mount(t)}}class fo extends Qs{constructor(){super(...arguments),this.type="html",this.renderInstance=co}readValueFromInstance(t,e){if(f.has(e)){const t=ee(e);return t&&t.default||0}{const i=(n=t,window.getComputedStyle(n)),s=(q(e)?i.getPropertyValue(e):i[e])||0;return"string"==typeof s?s.trim():s}var n}measureInstanceViewportBox(t,{transformPagePoint:e}){return Ui(t,e)}build(t,e,n){so(t,e,n.transformTemplate)}scrapeMotionValuesFromProps(t,e,n){return Ws(t,e,n)}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:t}=this.props;Rn(t)&&(this.childSubscription=t.on("change",t=>{this.current&&(this.current.textContent=""+t)}))}}class go extends Js{constructor(){super(...arguments),this.type="object"}readValueFromInstance(t,e){if(function(t,e){return t in e}(e,t)){const n=t[e];if("string"==typeof n||"number"==typeof n)return n}}getBaseTargetFromProps(){}removeValueFromRenderState(t,e){delete e.output[t]}measureInstanceViewportBox(){return{x:{min:0,max:0},y:{min:0,max:0}}}build(t,e){Object.assign(t.output,e)}renderInstance(t,{output:e}){Object.assign(t,e)}sortInstanceNodePosition(){return 0}}function yo(t){const e={presenceContext:null,props:{},visualState:{renderState:{transform:{},transformOrigin:{},style:{},vars:{},attrs:{}},latestValues:{}}},n=Is(t)?new mo(e):new fo(e);n.mount(t),Os.set(t,n)}function vo(t){const e=new go({presenceContext:null,props:{},visualState:{renderState:{output:{}},latestValues:{}}});e.mount(t),Os.set(t,e)}function xo(t,e,n){const i=Rn(t)?t:bn(t);return i.start(vn("",i,e,n)),i.animation}function wo(t,e,n,i){const s=[];if(function(t,e){return Rn(t)||"number"==typeof t||"string"==typeof t&&!bs(e)}(t,e))s.push(xo(t,bs(e)&&e.default||e,n&&n.default||n));else{const o=As(t,e,i),r=o.length;for(let t=0;t<r;t++){const i=o[t],a=i instanceof Element?yo:vo;Os.has(i)||a(i);const l=Os.get(i),u={...n};"delay"in u&&"function"==typeof u.delay&&(u.delay=u.delay(t,r)),s.push(...Ln(l,{...e,transition:u},{}))}}return s}function Po(t,e,n){const i=[];return function(t,{defaultTransition:e={},...n}={},i,s){const o=e.duration||.3,r=new Map,a=new Map,l={},u=new Map;let c=0,h=0,d=0;for(let n=0;n<t.length;n++){const r=t[n];if("string"==typeof r){u.set(r,h);continue}if(!Array.isArray(r)){u.set(r.name,Es(h,r.at,c,u));continue}let[p,m,f={}]=r;void 0!==f.at&&(h=Es(h,f.at,c,u));let y=0;const v=(t,n,i,r=0,a=0)=>{const l=Ls(t),{delay:u=0,times:c=Ge(l),type:p="keyframes",...m}=n;let{ease:f=e.ease||"easeOut",duration:v}=n;const x="function"==typeof u?u(r,a):u,w=l.length,P=oe(p)?p:null==s?void 0:s[p];if(w<=2&&P){let t=100;if(2===w&&js(l)){const e=l[1]-l[0];t=Math.abs(e)}const e={...m};void 0!==v&&(e.duration=g(v));const n=Ss(e,t,P);f=n.ease,v=n.duration}null!=v||(v=o);const S=h+x,T=S+v;1===c.length&&0===c[0]&&(c[1]=1);const b=c.length-l.length;b>0&&Xe(c,b),1===l.length&&l.unshift(null),Vs(i,l,f,c,S,T),y=Math.max(x+v,y),d=Math.max(T,d)};if(Rn(p)){v(m,f,ks("default",Ds(p,a)))}else{const t=As(p,m,i,l),e=t.length;for(let n=0;n<e;n++){m=m,f=f;const i=Ds(t[n],a);for(const t in m)v(m[t],Bs(f,t),ks(t,i),n,e)}}c=h,h+=y}return a.forEach((t,i)=>{for(const s in t){const o=t[s];o.sort(Rs);const a=[],l=[],u=[];for(let t=0;t<o.length;t++){const{at:e,value:n,easing:i}=o[t];a.push(n),l.push(Re(0,d,e)),u.push(i||"easeOut")}0!==l[0]&&(l.unshift(0),a.unshift(a[0]),u.unshift("easeInOut")),1!==l[l.length-1]&&(l.push(1),a.push(null)),r.has(i)||r.set(i,{keyframes:{},transition:{}});const c=r.get(i);c.keyframes[s]=a,c.transition[s]={...e,duration:d,ease:u,times:l,...n}}}),r}(t,e,n,{spring:xe}).forEach(({keyframes:t,transition:e},n)=>{i.push(...wo(n,t,e))}),i}function So(t){return function(e,n,i){let s=[];var o;o=e,s=Array.isArray(o)&&Array.isArray(o[0])?Po(e,n,t):wo(e,n,i,t);const r=new yn(s);return t&&t.animations.push(r),r}}const To=So();function bo(t,e,n){t.style.setProperty("--"+e,n)}function Ao(t,e,n){t.style[e]=n}const Eo=nn(()=>{try{document.createElement("div").animate({opacity:[1]})}catch(t){return!1}return!0}),Co=new WeakMap;function Mo(t){const e=Co.get(t)||new Map;return Co.set(t,e),Co.get(t)}class Vo{constructor(t,e,n,i){const s=e.startsWith("--");this.setValue=s?bo:Ao,this.options=i,this.updateFinishedPromise(),G("string"!=typeof i.type);const o=Mo(t).get(e);o&&o.stop();if(Array.isArray(n)||(n=[n]),function(t,e,n){for(let i=0;i<e.length;i++)null===e[i]&&(e[i]=0===i?n():e[i-1]),"number"==typeof e[i]&&qt[t]&&(e[i]=qt[t].transform(e[i]));!Eo()&&e.length<2&&e.unshift(n())}(e,n,()=>e.startsWith("--")?t.style.getPropertyValue(e):window.getComputedStyle(t)[e]),oe(i.type)){const t=Ss(i,100,i.type);i.ease=rn()?t.ease:"easeOut",i.duration=g(t.duration),i.type="keyframes"}else i.ease=i.ease||"easeOut";this.removeAnimation=()=>{var n;return null===(n=Co.get(t))||void 0===n?void 0:n.delete(e)};const r=()=>{this.setValue(t,e,E(n,this.options)),this.cancel(),this.resolveFinishedPromise()};pn()?(this.animation=hn(t,e,n,i),!1===i.autoplay&&this.animation.pause(),this.animation.onfinish=r,this.pendingTimeline&&dn(this.animation,this.pendingTimeline),Mo(t).set(e,this)):r()}get duration(){return y(this.options.duration||300)}get time(){var t;return this.animation?y((null===(t=this.animation)||void 0===t?void 0:t.currentTime)||0):0}set time(t){this.animation&&(this.animation.currentTime=g(t))}get speed(){return this.animation?this.animation.playbackRate:1}set speed(t){this.animation&&(this.animation.playbackRate=t)}get state(){return this.animation?this.animation.playState:"finished"}get startTime(){return this.animation?this.animation.startTime:null}play(){"finished"===this.state&&this.updateFinishedPromise(),this.animation&&this.animation.play()}pause(){this.animation&&this.animation.pause()}stop(){this.animation&&"idle"!==this.state&&"finished"!==this.state&&(this.animation.commitStyles&&this.animation.commitStyles(),this.cancel())}complete(){this.animation&&this.animation.finish()}cancel(){this.removeAnimation();try{this.animation&&this.animation.cancel()}catch(t){}}then(t,e){return this.currentFinishedPromise.then(t,e)}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}attachTimeline(t){return this.animation?dn(this.animation,t):this.pendingTimeline=t,C}}const Ro=t=>function(e,n,i){return new yn(function(t,e,n,i){const s=Ts(t,i),o=s.length,r=[];for(let t=0;t<o;t++){const i=s[t],a={...n};"function"==typeof a.delay&&(a.delay=a.delay(t,o));for(const t in e){const s=e[t],o={...S(n,t)};o.duration=o.duration?g(o.duration):o.duration,o.delay=g(o.delay||0),r.push(new Vo(i,t,s,o))}}return r}(e,n,i,t))},Do=Ro(),ko=new WeakMap;let Lo;function Bo({target:t,contentRect:e,borderBoxSize:n}){var i;null===(i=ko.get(t))||void 0===i||i.forEach(i=>{i({target:t,contentSize:e,get size(){return function(t,e){if(e){const{inlineSize:t,blockSize:n}=e[0];return{width:t,height:n}}return t instanceof SVGElement&&"getBBox"in t?t.getBBox():{width:t.offsetWidth,height:t.offsetHeight}}(t,n)}})})}function Fo(t){t.forEach(Bo)}function jo(t,e){Lo||"undefined"!=typeof ResizeObserver&&(Lo=new ResizeObserver(Fo));const n=Ts(t);return n.forEach(t=>{let n=ko.get(t);n||(n=new Set,ko.set(t,n)),n.add(e),null==Lo||Lo.observe(t)}),()=>{n.forEach(t=>{const n=ko.get(t);null==n||n.delete(e),(null==n?void 0:n.size)||null==Lo||Lo.unobserve(t)})}}const Oo=new Set;let Io;function Uo(t){return Oo.add(t),Io||(Io=()=>{const t={width:window.innerWidth,height:window.innerHeight},e={target:window,size:t,contentSize:t};Oo.forEach(t=>t(e))},window.addEventListener("resize",Io)),()=>{Oo.delete(t),!Oo.size&&Io&&(Io=void 0)}}const Wo={x:{length:"Width",position:"Left"},y:{length:"Height",position:"Top"}};function No(t,e,n,i){const s=n[e],{length:o,position:r}=Wo[e],a=s.current,l=n.time;s.current=t["scroll"+r],s.scrollLength=t["scroll"+o]-t["client"+o],s.offset.length=0,s.offset[0]=0,s.offset[1]=s.scrollLength,s.progress=Re(0,s.scrollLength,s.current);const u=i-l;s.velocity=u>50?0:de(s.current-a,u)}const zo={Enter:[[0,1],[1,1]],Exit:[[0,0],[1,0]],Any:[[1,0],[0,1]],All:[[0,0],[1,1]]},$o={start:0,center:.5,end:1};function Ho(t,e,n=0){let i=0;if(t in $o&&(t=$o[t]),"string"==typeof t){const e=parseFloat(t);t.endsWith("px")?i=e:t.endsWith("%")?t=e/100:t.endsWith("vw")?i=e/100*document.documentElement.clientWidth:t.endsWith("vh")?i=e/100*document.documentElement.clientHeight:t=e}return"number"==typeof t&&(i=e*t),n+i}const Yo=[0,0];function Xo(t,e,n,i){let s=Array.isArray(t)?t:Yo,o=0,r=0;return"number"==typeof t?s=[t,t]:"string"==typeof t&&(s=(t=t.trim()).includes(" ")?t.split(" "):[t,$o[t]?t:"0"]),o=Ho(s[0],n,i),r=Ho(s[1],e),o-r}const Go={x:0,y:0};function Ko(t,e,n){const{offset:i=zo.All}=n,{target:s=t,axis:o="y"}=n,r="y"===o?"height":"width",a=s!==t?function(t,e){const n={x:0,y:0};let i=t;for(;i&&i!==e;)if(i instanceof HTMLElement)n.x+=i.offsetLeft,n.y+=i.offsetTop,i=i.offsetParent;else if("svg"===i.tagName){const t=i.getBoundingClientRect();i=i.parentElement;const e=i.getBoundingClientRect();n.x+=t.left-e.left,n.y+=t.top-e.top}else{if(!(i instanceof SVGGraphicsElement))break;{const{x:t,y:e}=i.getBBox();n.x+=t,n.y+=e;let s=null,o=i.parentNode;for(;!s;)"svg"===o.tagName&&(s=o),o=i.parentNode;i=s}}return n}(s,t):Go,l=s===t?{width:t.scrollWidth,height:t.scrollHeight}:function(t){return"getBBox"in t&&"svg"!==t.tagName?t.getBBox():{width:t.clientWidth,height:t.clientHeight}}(s),u={width:t.clientWidth,height:t.clientHeight};e[o].offset.length=0;let c=!e[o].interpolate;const h=i.length;for(let t=0;t<h;t++){const n=Xo(i[t],u[r],l[r],a[o]);c||n===e[o].interpolatorOffsets[t]||(c=!0),e[o].offset[t]=n}c&&(e[o].interpolate=Ye(e[o].offset,Ge(i)),e[o].interpolatorOffsets=[...e[o].offset]),e[o].progress=e[o].interpolate(e[o].current)}function _o(t,e,n,i={}){return{measure:()=>function(t,e=t,n){if(n.x.targetOffset=0,n.y.targetOffset=0,e!==t){let i=e;for(;i&&i!==t;)n.x.targetOffset+=i.offsetLeft,n.y.targetOffset+=i.offsetTop,i=i.offsetParent}n.x.targetLength=e===t?e.scrollWidth:e.clientWidth,n.y.targetLength=e===t?e.scrollHeight:e.clientHeight,n.x.containerLength=t.clientWidth,n.y.containerLength=t.clientHeight}(t,i.target,n),update:e=>{!function(t,e,n){No(t,"x",e,n),No(t,"y",e,n),e.time=n}(t,n,e),(i.offset||i.target)&&Ko(t,n,i)},notify:()=>e(n)}}const qo=new WeakMap,Zo=new WeakMap,Jo=new WeakMap,Qo=t=>t===document.documentElement?window:t;function tr(t,{container:e=document.documentElement,...n}={}){let i=Jo.get(e);i||(i=new Set,Jo.set(e,i));const s=_o(e,t,{time:0,x:{current:0,offset:[],progress:0,scrollLength:0,targetOffset:0,targetLength:0,containerLength:0,velocity:0},y:{current:0,offset:[],progress:0,scrollLength:0,targetOffset:0,targetLength:0,containerLength:0,velocity:0}},n);if(i.add(s),!qo.has(e)){const t=()=>{for(const t of i)t.measure()},n=()=>{for(const t of i)t.update(k.timestamp)},s=()=>{for(const t of i)t.notify()},a=()=>{R.read(t,!1,!0),R.read(n,!1,!0),R.update(s,!1,!0)};qo.set(e,a);const l=Qo(e);window.addEventListener("resize",a,{passive:!0}),e!==document.documentElement&&Zo.set(e,(r=a,"function"==typeof(o=e)?Uo(o):jo(o,r))),l.addEventListener("scroll",a,{passive:!0})}var o,r;const a=qo.get(e);return R.read(a,!1,!0),()=>{var t;D(a);const n=Jo.get(e);if(!n)return;if(n.delete(s),n.size)return;const i=qo.get(e);qo.delete(e),i&&(Qo(e).removeEventListener("scroll",i),null===(t=Zo.get(e))||void 0===t||t(),window.removeEventListener("resize",i))}}function er(t,e){let n;const i=()=>{const{currentTime:i}=e,s=(null===i?0:i.value)/100;n!==s&&t(s),n=s};return R.update(i,!0),()=>D(i)}const nr=new Map;function ir({source:t,container:e=document.documentElement,axis:n="y"}={}){t&&(e=t),nr.has(e)||nr.set(e,{});const i=nr.get(e);return i[n]||(i[n]=gn()?new ScrollTimeline({source:e,axis:n}):function({source:t,container:e,axis:n="y"}){t&&(e=t);const i={value:0},s=tr(t=>{i.value=100*t[n].progress},{container:e,axis:n});return{currentTime:i,cancel:s}}({source:e,axis:n})),i[n]}function sr(t){return t&&(t.target||t.offset)}function or(t,{axis:e="y",...n}={}){const i={axis:e,...n};return"function"==typeof t?function(t,e){return function(t){return 2===t.length}(t)||sr(e)?tr(n=>{t(n[e.axis].progress,n)},e):er(t,ir(e))}(t,i):function(t,e){if(sr(e))return t.pause(),tr(n=>{t.time=t.duration*n[e.axis].progress},e);{const n=ir(e);return t.attachTimeline(n,t=>(t.pause(),er(e=>{t.time=t.duration*e},n)))}}(t,i)}const rr={some:0,all:1};function ar(t,e,{root:n,margin:i,amount:s="some"}={}){const o=Ts(t),r=new WeakMap,a=new IntersectionObserver(t=>{t.forEach(t=>{const n=r.get(t.target);if(t.isIntersecting!==Boolean(n))if(t.isIntersecting){const n=e(t);"function"==typeof n?r.set(t.target,n):a.unobserve(t.target)}else n&&(n(t),r.delete(t.target))})},{root:n,rootMargin:i,threshold:"number"==typeof s?s:rr[s]});return o.forEach(t=>a.observe(t)),()=>a.disconnect()}function lr(...t){const e=!Array.isArray(t[0]),n=e?0:-1,i=t[0+n],s=t[1+n],o=t[2+n],r=t[3+n],a=Ye(s,o,{mixer:(l=o[0],(t=>t&&"object"==typeof t&&t.mix)(l)?l.mix:void 0),...r});var l;return e?a(i):a}const ur=R,cr=M.reduce((t,e)=>(t[e]=t=>D(t),t),{}),{schedule:hr,cancel:dr}=V(queueMicrotask,!1),pr={type:"projectionFrame",totalNodes:0,resolvedTargetDeltas:0,recalculatedProjection:0},mr="undefined"!=typeof window&&void 0!==window.MotionDebug,fr=["","X","Y","Z"],gr={visibility:"hidden"};let yr=0;function vr(t,e,n,i){const{latestValues:s}=e;s[t]&&(n[t]=s[t],e.setStaticValue(t,0),i&&(i[t]=0))}function xr({attachResizeListener:t,defaultParent:e,measureScroll:n,checkIsScrollRoot:i,resetTransform:s}){return class{constructor(t={},n=(null==e?void 0:e())){this.id=yr++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,mr&&(pr.totalNodes=pr.resolvedTargetDeltas=pr.recalculatedProjection=0),this.nodes.forEach(Sr),this.nodes.forEach(Vr),this.nodes.forEach(Rr),this.nodes.forEach(Tr),mr&&window.MotionDebug.record(pr)},this.resolvedRelativeTargetAt=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=t,this.root=n?n.root||n:this,this.path=n?[...n.path,n]:[],this.parent=n,this.depth=n?n.depth+1:0;for(let t=0;t<this.path.length;t++)this.path[t].shouldResetTransform=!0;this.root===this&&(this.nodes=new vs)}addEventListener(t,e){return this.eventHandlers.has(t)||this.eventHandlers.set(t,new Pn),this.eventHandlers.get(t).add(e)}notifyListeners(t,...e){const n=this.eventHandlers.get(t);n&&n.notify(...e)}hasListeners(t){return this.eventHandlers.has(t)}mount(e,n=this.root.hasTreeAnimated){if(this.instance)return;this.isSVG=Is(e),this.instance=e;const{layoutId:i,layout:s,visualElement:o}=this.options;if(o&&!o.current&&o.mount(e),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),n&&(s||i)&&(this.isLayoutDirty=!0),t){let n;const i=()=>this.root.updateBlockedByResize=!1;t(e,()=>{this.root.updateBlockedByResize=!0,n&&n(),n=Ps(i,250),ws.hasAnimatedSinceResize&&(ws.hasAnimatedSinceResize=!1,this.nodes.forEach(Mr))})}i&&this.root.registerSharedNode(i,this),!1!==this.options.animate&&o&&(i||s)&&this.addEventListener("didUpdate",({delta:t,hasLayoutChanged:e,hasRelativeTargetChanged:n,layout:i})=>{if(this.isTreeAnimationBlocked())return this.target=void 0,void(this.relativeTarget=void 0);const s=this.options.transition||o.getDefaultTransition()||jr,{onLayoutAnimationStart:r,onLayoutAnimationComplete:a}=o.getProps(),l=!this.targetLayout||!hs(this.targetLayout,i)||n,u=!e&&n;if(this.options.layoutRoot||this.resumeFrom&&this.resumeFrom.instance||u||e&&(l||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(t,u);const e={...S(s,"layout"),onPlay:r,onComplete:a};(o.shouldReduceMotion||this.options.layoutRoot)&&(e.delay=0,e.type=!1),this.startAnimation(e)}else e||Mr(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=i})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const t=this.getStack();t&&t.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,D(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(Dr),this.animationId++)}getTransformTemplate(){const{visualElement:t}=this.options;return t&&t.getProps().transformTemplate}willUpdate(t=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked())return void(this.options.onExitComplete&&this.options.onExitComplete());if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&function t(e){if(e.hasCheckedOptimisedAppear=!0,e.root===e)return;const{visualElement:n}=e.options;if(!n)return;const i=Vn(n);if(window.MotionHasOptimisedAnimation(i,"transform")){const{layout:t,layoutId:n}=e.options;window.MotionCancelOptimisedAnimation(i,"transform",R,!(t||n))}const{parent:s}=e;s&&!s.hasCheckedOptimisedAppear&&t(s)}(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let t=0;t<this.path.length;t++){const e=this.path[t];e.shouldResetTransform=!0,e.updateScroll("snapshot"),e.options.layoutRoot&&e.willUpdate(!1)}const{layoutId:e,layout:n}=this.options;if(void 0===e&&!n)return;const i=this.getTransformTemplate();this.prevTransformTemplateValue=i?i(this.latestValues,""):void 0,this.updateSnapshot(),t&&this.notifyListeners("willUpdate")}update(){this.updateScheduled=!1;if(this.isUpdateBlocked())return this.unblockUpdate(),this.clearAllSnapshots(),void this.nodes.forEach(Ar);this.isUpdating||this.nodes.forEach(Er),this.isUpdating=!1,this.nodes.forEach(Cr),this.nodes.forEach(wr),this.nodes.forEach(Pr),this.clearAllSnapshots();const t=le.now();k.delta=nt(0,1e3/60,t-k.timestamp),k.timestamp=t,k.isProcessing=!0,L.update.process(k),L.preRender.process(k),L.render.process(k),k.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,hr.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(br),this.sharedNodes.forEach(kr)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,R.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){R.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){!this.snapshot&&this.instance&&(this.snapshot=this.measure())}updateLayout(){if(!this.instance)return;if(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead()||this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let t=0;t<this.path.length;t++){this.path[t].updateScroll()}const t=this.layout;this.layout=this.measure(!1),this.layoutCorrected={x:{min:0,max:0},y:{min:0,max:0}},this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:e}=this.options;e&&e.notify("LayoutMeasure",this.layout.layoutBox,t?t.layoutBox:void 0)}updateScroll(t="measure"){let e=Boolean(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===t&&(e=!1),e){const e=i(this.instance);this.scroll={animationId:this.root.animationId,phase:t,isRoot:e,offset:n(this.instance),wasRoot:this.scroll?this.scroll.isRoot:e}}}resetTransform(){if(!s)return;const t=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,e=this.projectionDelta&&!ls(this.projectionDelta),n=this.getTransformTemplate(),i=n?n(this.latestValues,""):void 0,o=i!==this.prevTransformTemplateValue;t&&(e||Vi(this.latestValues)||o)&&(s(this.instance,i),this.shouldResetTransform=!1,this.scheduleRender())}measure(t=!0){const e=this.measurePageBox();let n=this.removeElementScroll(e);var i;return t&&(n=this.removeTransform(n)),Ur((i=n).x),Ur(i.y),{animationId:this.root.animationId,measuredBox:e,layoutBox:n,latestValues:{},source:this.id}}measurePageBox(){var t;const{visualElement:e}=this.options;if(!e)return{x:{min:0,max:0},y:{min:0,max:0}};const n=e.measureViewportBox();if(!((null===(t=this.scroll)||void 0===t?void 0:t.wasRoot)||this.path.some(Nr))){const{scroll:t}=this.root;t&&(ji(n.x,t.offset.x),ji(n.y,t.offset.y))}return n}removeElementScroll(t){var e;const n={x:{min:0,max:0},y:{min:0,max:0}};if(ts(n,t),null===(e=this.scroll)||void 0===e?void 0:e.wasRoot)return n;for(let e=0;e<this.path.length;e++){const i=this.path[e],{scroll:s,options:o}=i;i!==this.root&&s&&o.layoutScroll&&(s.wasRoot&&ts(n,t),ji(n.x,s.offset.x),ji(n.y,s.offset.y))}return n}applyTransform(t,e=!1){const n={x:{min:0,max:0},y:{min:0,max:0}};ts(n,t);for(let t=0;t<this.path.length;t++){const i=this.path[t];!e&&i.options.layoutScroll&&i.scroll&&i!==i.root&&Ii(n,{x:-i.scroll.offset.x,y:-i.scroll.offset.y}),Vi(i.latestValues)&&Ii(n,i.latestValues)}return Vi(this.latestValues)&&Ii(n,this.latestValues),n}removeTransform(t){const e={x:{min:0,max:0},y:{min:0,max:0}};ts(e,t);for(let t=0;t<this.path.length;t++){const n=this.path[t];if(!n.instance)continue;if(!Vi(n.latestValues))continue;Mi(n.latestValues)&&n.updateSnapshot();const i={x:{min:0,max:0},y:{min:0,max:0}};ts(i,n.measurePageBox()),rs(e,n.latestValues,n.snapshot?n.snapshot.layoutBox:void 0,i)}return Vi(this.latestValues)&&rs(e,this.latestValues),e}setTargetDelta(t){this.targetDelta=t,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(t){this.options={...this.options,...t,crossfade:void 0===t.crossfade||t.crossfade}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==k.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(t=!1){var e;const n=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=n.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=n.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=n.isSharedProjectionDirty);const i=Boolean(this.resumingFrom)||this!==n;if(!(t||i&&this.isSharedProjectionDirty||this.isProjectionDirty||(null===(e=this.parent)||void 0===e?void 0:e.isProjectionDirty)||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:s,layoutId:o}=this.options;if(this.layout&&(s||o)){if(this.resolvedRelativeTargetAt=k.timestamp,!this.targetDelta&&!this.relativeTarget){const t=this.getClosestProjectingParent();t&&t.layout&&1!==this.animationProgress?(this.relativeParent=t,this.forceRelativeParentToResolveTarget(),this.relativeTarget={x:{min:0,max:0},y:{min:0,max:0}},this.relativeTargetOrigin={x:{min:0,max:0},y:{min:0,max:0}},vi(this.relativeTargetOrigin,this.layout.layoutBox,t.layout.layoutBox),ts(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(this.relativeTarget||this.targetDelta){var r,a,l;if(this.target||(this.target={x:{min:0,max:0},y:{min:0,max:0}},this.targetWithTransforms={x:{min:0,max:0},y:{min:0,max:0}}),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),r=this.target,a=this.relativeTarget,l=this.relativeParent.target,gi(r.x,a.x,l.x),gi(r.y,a.y,l.y)):this.targetDelta?(Boolean(this.resumingFrom)?this.target=this.applyTransform(this.layout.layoutBox):ts(this.target,this.layout.layoutBox),Fi(this.target,this.targetDelta)):ts(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget){this.attemptToResolveRelativeTarget=!1;const t=this.getClosestProjectingParent();t&&Boolean(t.resumingFrom)===Boolean(this.resumingFrom)&&!t.options.layoutScroll&&t.target&&1!==this.animationProgress?(this.relativeParent=t,this.forceRelativeParentToResolveTarget(),this.relativeTarget={x:{min:0,max:0},y:{min:0,max:0}},this.relativeTargetOrigin={x:{min:0,max:0},y:{min:0,max:0}},vi(this.relativeTargetOrigin,this.target,t.target),ts(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}mr&&pr.resolvedTargetDeltas++}}}getClosestProjectingParent(){if(this.parent&&!Mi(this.parent.latestValues)&&!Ri(this.parent.latestValues))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return Boolean((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){var t;const e=this.getLead(),n=Boolean(this.resumingFrom)||this!==e;let i=!0;if((this.isProjectionDirty||(null===(t=this.parent)||void 0===t?void 0:t.isProjectionDirty))&&(i=!1),n&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(i=!1),this.resolvedRelativeTargetAt===k.timestamp&&(i=!1),i)return;const{layout:s,layoutId:o}=this.options;if(this.isTreeAnimating=Boolean(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!s&&!o)return;ts(this.layoutCorrected,this.layout.layoutBox);const r=this.treeScale.x,a=this.treeScale.y;!function(t,e,n,i=!1){const s=n.length;if(!s)return;let o,r;e.x=e.y=1;for(let a=0;a<s;a++){o=n[a],r=o.projectionDelta;const{visualElement:s}=o.options;s&&s.props.style&&"contents"===s.props.style.display||(i&&o.options.layoutScroll&&o.scroll&&o!==o.root&&Ii(t,{x:-o.scroll.offset.x,y:-o.scroll.offset.y}),r&&(e.x*=r.x.scale,e.y*=r.y.scale,Fi(t,r)),i&&Vi(o.latestValues)&&Ii(t,o.latestValues))}e.x<1.0000000000001&&e.x>.999999999999&&(e.x=1),e.y<1.0000000000001&&e.y>.999999999999&&(e.y=1)}(this.layoutCorrected,this.treeScale,this.path,n),!e.layout||e.target||1===this.treeScale.x&&1===this.treeScale.y||(e.target=e.layout.layoutBox,e.targetWithTransforms={x:{min:0,max:0},y:{min:0,max:0}});const{target:l}=e;l?(this.projectionDelta&&this.prevProjectionDelta?(es(this.prevProjectionDelta.x,this.projectionDelta.x),es(this.prevProjectionDelta.y,this.projectionDelta.y)):this.createProjectionDeltas(),fi(this.projectionDelta,this.layoutCorrected,l,this.latestValues),this.treeScale.x===r&&this.treeScale.y===a&&ps(this.projectionDelta.x,this.prevProjectionDelta.x)&&ps(this.projectionDelta.y,this.prevProjectionDelta.y)||(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",l)),mr&&pr.recalculatedProjection++):this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender())}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(t=!0){var e;if(null===(e=this.options.visualElement)||void 0===e||e.scheduleRender(),t){const t=this.getStack();t&&t.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}},this.projectionDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}},this.projectionDeltaWithTransform={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}}}setAnimationOrigin(t,e=!1){const n=this.snapshot,i=n?n.latestValues:{},s={...this.latestValues},o={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};this.relativeParent&&this.relativeParent.options.layoutRoot||(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!e;const r={x:{min:0,max:0},y:{min:0,max:0}},a=(n?n.source:void 0)!==(this.layout?this.layout.source:void 0),l=this.getStack(),u=!l||l.members.length<=1,c=Boolean(a&&!u&&!0===this.options.crossfade&&!this.path.some(Fr));let h;this.animationProgress=0,this.mixTargetDelta=e=>{const n=e/1e3;var l,d;Lr(o.x,t.x,n),Lr(o.y,t.y,n),this.setTargetDelta(o),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(vi(r,this.layout.layoutBox,this.relativeParent.layout.layoutBox),function(t,e,n,i){Br(t.x,e.x,n.x,i),Br(t.y,e.y,n.y,i)}(this.relativeTarget,this.relativeTargetOrigin,r,n),h&&(l=this.relativeTarget,d=h,us(l.x,d.x)&&us(l.y,d.y))&&(this.isProjectionDirty=!1),h||(h={x:{min:0,max:0},y:{min:0,max:0}}),ts(h,this.relativeTarget)),a&&(this.animationValues=s,function(t,e,n,i,s,o){s?(t.opacity=De(0,void 0!==n.opacity?n.opacity:1,qi(i)),t.opacityExit=De(void 0!==e.opacity?e.opacity:1,0,Zi(i))):o&&(t.opacity=De(void 0!==e.opacity?e.opacity:1,void 0!==n.opacity?n.opacity:1,i));for(let s=0;s<Xi;s++){const o=`border${Yi[s]}Radius`;let r=_i(e,o),a=_i(n,o);if(void 0===r&&void 0===a)continue;r||(r=0),a||(a=0);0===r||0===a||Ki(r)===Ki(a)?(t[o]=Math.max(De(Gi(r),Gi(a),i),0),(lt.test(a)||lt.test(r))&&(t[o]+="%")):t[o]=a}(e.rotate||n.rotate)&&(t.rotate=De(e.rotate||0,n.rotate||0,i))}(s,i,this.latestValues,n,c,u)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=n},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(t){this.notifyListeners("animationStart"),this.currentAnimation&&this.currentAnimation.stop(),this.resumingFrom&&this.resumingFrom.currentAnimation&&this.resumingFrom.currentAnimation.stop(),this.pendingAnimation&&(D(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=R.update(()=>{ws.hasAnimatedSinceResize=!0,this.currentAnimation=xo(0,1e3,{...t,onUpdate:e=>{this.mixTargetDelta(e),t.onUpdate&&t.onUpdate(e)},onComplete:()=>{t.onComplete&&t.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const t=this.getStack();t&&t.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(1e3),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const t=this.getLead();let{targetWithTransforms:e,target:n,layout:i,latestValues:s}=t;if(e&&n&&i){if(this!==t&&this.layout&&i&&Wr(this.options.animationType,this.layout.layoutBox,i.layoutBox)){n=this.target||{x:{min:0,max:0},y:{min:0,max:0}};const e=pi(this.layout.layoutBox.x);n.x.min=t.target.x.min,n.x.max=n.x.min+e;const i=pi(this.layout.layoutBox.y);n.y.min=t.target.y.min,n.y.max=n.y.min+i}ts(e,n),Ii(e,s),fi(this.projectionDeltaWithTransform,this.layoutCorrected,e,s)}}registerSharedNode(t,e){this.sharedNodes.has(t)||this.sharedNodes.set(t,new ms);this.sharedNodes.get(t).add(e);const n=e.options.initialPromotionConfig;e.promote({transition:n?n.transition:void 0,preserveFollowOpacity:n&&n.shouldPreserveFollowOpacity?n.shouldPreserveFollowOpacity(e):void 0})}isLead(){const t=this.getStack();return!t||t.lead===this}getLead(){var t;const{layoutId:e}=this.options;return e&&(null===(t=this.getStack())||void 0===t?void 0:t.lead)||this}getPrevLead(){var t;const{layoutId:e}=this.options;return e?null===(t=this.getStack())||void 0===t?void 0:t.prevLead:void 0}getStack(){const{layoutId:t}=this.options;if(t)return this.root.sharedNodes.get(t)}promote({needsReset:t,transition:e,preserveFollowOpacity:n}={}){const i=this.getStack();i&&i.promote(this,n),t&&(this.projectionDelta=void 0,this.needsReset=!0),e&&this.setOptions({transition:e})}relegate(){const t=this.getStack();return!!t&&t.relegate(this)}resetSkewAndRotation(){const{visualElement:t}=this.options;if(!t)return;let e=!1;const{latestValues:n}=t;if((n.z||n.rotate||n.rotateX||n.rotateY||n.rotateZ||n.skewX||n.skewY)&&(e=!0),!e)return;const i={};n.z&&vr("z",t,i,this.animationValues);for(let e=0;e<fr.length;e++)vr("rotate"+fr[e],t,i,this.animationValues),vr("skew"+fr[e],t,i,this.animationValues);t.render();for(const e in i)t.setStaticValue(e,i[e]),this.animationValues&&(this.animationValues[e]=i[e]);t.scheduleRender()}getProjectionStyles(t){var e,n;if(!this.instance||this.isSVG)return;if(!this.isVisible)return gr;const i={visibility:""},s=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,i.opacity="",i.pointerEvents=xs(null==t?void 0:t.pointerEvents)||"",i.transform=s?s(this.latestValues,""):"none",i;const o=this.getLead();if(!this.projectionDelta||!this.layout||!o.target){const e={};return this.options.layoutId&&(e.opacity=void 0!==this.latestValues.opacity?this.latestValues.opacity:1,e.pointerEvents=xs(null==t?void 0:t.pointerEvents)||""),this.hasProjected&&!Vi(this.latestValues)&&(e.transform=s?s({},""):"none",this.hasProjected=!1),e}const r=o.animationValues||o.latestValues;this.applyTransformsToTarget(),i.transform=function(t,e,n){let i="";const s=t.x.translate/e.x,o=t.y.translate/e.y,r=(null==n?void 0:n.z)||0;if((s||o||r)&&(i=`translate3d(${s}px, ${o}px, ${r}px) `),1===e.x&&1===e.y||(i+=`scale(${1/e.x}, ${1/e.y}) `),n){const{transformPerspective:t,rotate:e,rotateX:s,rotateY:o,skewX:r,skewY:a}=n;t&&(i=`perspective(${t}px) ${i}`),e&&(i+=`rotate(${e}deg) `),s&&(i+=`rotateX(${s}deg) `),o&&(i+=`rotateY(${o}deg) `),r&&(i+=`skewX(${r}deg) `),a&&(i+=`skewY(${a}deg) `)}const a=t.x.scale*e.x,l=t.y.scale*e.y;return 1===a&&1===l||(i+=`scale(${a}, ${l})`),i||"none"}(this.projectionDeltaWithTransform,this.treeScale,r),s&&(i.transform=s(r,i.transform));const{x:a,y:l}=this.projectionDelta;i.transformOrigin=`${100*a.origin}% ${100*l.origin}% 0`,o.animationValues?i.opacity=o===this?null!==(n=null!==(e=r.opacity)&&void 0!==e?e:this.latestValues.opacity)&&void 0!==n?n:1:this.preserveOpacity?this.latestValues.opacity:r.opacityExit:i.opacity=o===this?void 0!==r.opacity?r.opacity:"":void 0!==r.opacityExit?r.opacityExit:0;for(const t in fs){if(void 0===r[t])continue;const{correct:e,applyTo:n}=fs[t],s="none"===i.transform?r[t]:e(r[t],o);if(n){const t=n.length;for(let e=0;e<t;e++)i[n[e]]=s}else i[t]=s}return this.options.layoutId&&(i.pointerEvents=o===this?xs(null==t?void 0:t.pointerEvents)||"":"none"),i}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(t=>{var e;return null===(e=t.currentAnimation)||void 0===e?void 0:e.stop()}),this.root.nodes.forEach(Ar),this.root.sharedNodes.clear()}}}function wr(t){t.updateLayout()}function Pr(t){var e;const n=(null===(e=t.resumeFrom)||void 0===e?void 0:e.snapshot)||t.snapshot;if(t.isLead()&&t.layout&&n&&t.hasListeners("didUpdate")){const{layoutBox:e,measuredBox:i}=t.layout,{animationType:s}=t.options,o=n.source!==t.layout.source;"size"===s?Ai(t=>{const i=o?n.measuredBox[t]:n.layoutBox[t],s=pi(i);i.min=e[t].min,i.max=i.min+s}):Wr(s,n.layoutBox,e)&&Ai(i=>{const s=o?n.measuredBox[i]:n.layoutBox[i],r=pi(e[i]);s.max=s.min+r,t.relativeTarget&&!t.currentAnimation&&(t.isProjectionDirty=!0,t.relativeTarget[i].max=t.relativeTarget[i].min+r)});const r={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};fi(r,e,n.layoutBox);const a={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};o?fi(a,t.applyTransform(i,!0),n.measuredBox):fi(a,e,n.layoutBox);const l=!ls(r);let u=!1;if(!t.resumeFrom){const i=t.getClosestProjectingParent();if(i&&!i.resumeFrom){const{snapshot:s,layout:o}=i;if(s&&o){const r={x:{min:0,max:0},y:{min:0,max:0}};vi(r,n.layoutBox,s.layoutBox);const a={x:{min:0,max:0},y:{min:0,max:0}};vi(a,e,o.layoutBox),hs(r,a)||(u=!0),i.options.layoutRoot&&(t.relativeTarget=a,t.relativeTargetOrigin=r,t.relativeParent=i)}}}t.notifyListeners("didUpdate",{layout:e,snapshot:n,delta:a,layoutDelta:r,hasLayoutChanged:l,hasRelativeTargetChanged:u})}else if(t.isLead()){const{onExitComplete:e}=t.options;e&&e()}t.options.transition=void 0}function Sr(t){mr&&pr.totalNodes++,t.parent&&(t.isProjecting()||(t.isProjectionDirty=t.parent.isProjectionDirty),t.isSharedProjectionDirty||(t.isSharedProjectionDirty=Boolean(t.isProjectionDirty||t.parent.isProjectionDirty||t.parent.isSharedProjectionDirty)),t.isTransformDirty||(t.isTransformDirty=t.parent.isTransformDirty))}function Tr(t){t.isProjectionDirty=t.isSharedProjectionDirty=t.isTransformDirty=!1}function br(t){t.clearSnapshot()}function Ar(t){t.clearMeasurements()}function Er(t){t.isLayoutDirty=!1}function Cr(t){const{visualElement:e}=t.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),t.resetTransform()}function Mr(t){t.finishAnimation(),t.targetDelta=t.relativeTarget=t.target=void 0,t.isProjectionDirty=!0}function Vr(t){t.resolveTargetDelta()}function Rr(t){t.calcProjection()}function Dr(t){t.resetSkewAndRotation()}function kr(t){t.removeLeadSnapshot()}function Lr(t,e,n){t.translate=De(e.translate,0,n),t.scale=De(e.scale,1,n),t.origin=e.origin,t.originPoint=e.originPoint}function Br(t,e,n,i){t.min=De(e.min,n.min,i),t.max=De(e.max,n.max,i)}function Fr(t){return t.animationValues&&void 0!==t.animationValues.opacityExit}const jr={duration:.45,ease:[.4,0,.1,1]},Or=t=>"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(t),Ir=Or("applewebkit/")&&!Or("chrome/")?Math.round:C;function Ur(t){t.min=Ir(t.min),t.max=Ir(t.max)}function Wr(t,e,n){return"position"===t||"preserve-aspect"===t&&(i=ds(e),s=ds(n),o=.2,!(Math.abs(i-s)<=o));var i,s,o}function Nr(t){var e;return t!==t.root&&(null===(e=t.scroll)||void 0===e?void 0:e.wasRoot)}const zr=xr({attachResizeListener:(t,e)=>qn(t,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),$r={current:void 0},Hr=xr({measureScroll:t=>({x:t.scrollLeft,y:t.scrollTop}),defaultParent:()=>{if(!$r.current){const t=new zr({});t.mount(window),t.setOptions({layoutScroll:!0}),$r.current=t}return $r.current},resetTransform:(t,e)=>{t.style.transform=void 0!==e?e:"none"},checkIsScrollRoot:t=>Boolean("fixed"===window.getComputedStyle(t).position)}),Yr=t=>!t.isLayoutDirty&&t.willUpdate(!1);function Xr(){const t=new Set,e=new WeakMap,n=()=>t.forEach(Yr);return{add:i=>{t.add(i),e.set(i,i.addEventListener("willUpdate",n))},remove:i=>{t.delete(i);const s=e.get(i);s&&(s(),e.delete(i)),n()},dirty:n}}function Gr(t,e){return e.max===e.min?0:t/(e.max-e.min)*100}const Kr={correct:(t,e)=>{if(!e.target)return t;if("string"==typeof t){if(!ut.test(t))return t;t=parseFloat(t)}return`${Gr(t,e.target.x)}% ${Gr(t,e.target.y)}%`}},_r={correct:(t,{treeScale:e,projectionDelta:n})=>{const i=t,s=Yt.parse(t);if(s.length>5)return i;const o=Yt.createTransformer(t),r="number"!=typeof s[0]?1:0,a=n.x.scale*e.x,l=n.y.scale*e.y;s[0+r]/=a,s[1+r]/=l;const u=De(a,l,.5);return"number"==typeof s[2+r]&&(s[2+r]/=u),"number"==typeof s[3+r]&&(s[3+r]/=u),o(s)}};var qr=React,Zr=Symbol.for("react.element"),Jr=Symbol.for("react.fragment"),Qr=Object.prototype.hasOwnProperty,ta=qr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,ea={key:!0,ref:!0,__self:!0,__source:!0};function na(t,e,n){var i,s={},o=null,r=null;for(i in void 0!==n&&(o=""+n),void 0!==e.key&&(o=""+e.key),void 0!==e.ref&&(r=e.ref),e)Qr.call(e,i)&&!ea.hasOwnProperty(i)&&(s[i]=e[i]);if(t&&t.defaultProps)for(i in e=t.defaultProps)void 0===s[i]&&(s[i]=e[i]);return{$$typeof:Zr,type:t,key:o,ref:r,props:s,_owner:ta.current}}const ia=Jr,sa=na,oa=na,ra=e.createContext(null);function aa(){const t=e.useContext(ra);if(null===t)return[!0,null];const{isPresent:n,onExitComplete:i,register:s}=t,o=e.useId();e.useEffect(()=>s(o),[]);const r=e.useCallback(()=>i&&i(o),[o,i]);return!n&&i?[!1,r]:[!0]}const la=e.createContext({}),ua=e.createContext({});class ca extends e.Component{componentDidMount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:n,layoutId:i}=this.props,{projection:s}=t;gs(da),s&&(e.group&&e.group.add(s),n&&n.register&&i&&n.register(s),s.root.didUpdate(),s.addEventListener("animationComplete",()=>{this.safeToRemove()}),s.setOptions({...s.options,onExitComplete:()=>this.safeToRemove()})),ws.hasEverUpdated=!0}getSnapshotBeforeUpdate(t){const{layoutDependency:e,visualElement:n,drag:i,isPresent:s}=this.props,o=n.projection;return o?(o.isPresent=s,i||t.layoutDependency!==e||void 0===e?o.willUpdate():this.safeToRemove(),t.isPresent!==s&&(s?o.promote():o.relegate()||R.postRender(()=>{const t=o.getStack();t&&t.members.length||this.safeToRemove()})),null):null}componentDidUpdate(){const{projection:t}=this.props.visualElement;t&&(t.root.didUpdate(),hr.postRender(()=>{!t.currentAnimation&&t.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:n}=this.props,{projection:i}=t;i&&(i.scheduleCheckAfterUnmount(),e&&e.group&&e.group.remove(i),n&&n.deregister&&n.deregister(i))}safeToRemove(){const{safeToRemove:t}=this.props;t&&t()}render(){return null}}function ha(t){const[n,i]=aa(),s=e.useContext(la);return sa(ca,{...t,layoutGroup:s,switchLayoutGroup:e.useContext(ua),isPresent:n,safeToRemove:i})}const da={borderRadius:{...Kr,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:Kr,borderTopRightRadius:Kr,borderBottomLeftRadius:Kr,borderBottomRightRadius:Kr,boxShadow:_r},pa={pan:{Feature:class extends Hn{constructor(){super(...arguments),this.removePointerDownListener=C}onPointerDown(t){this.session=new ti(t,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:Wi(this.node)})}createPanHandlers(){const{onPanSessionStart:t,onPanStart:e,onPan:n,onPanEnd:i}=this.node.getProps();return{onSessionStart:Hi(t),onStart:Hi(e),onMove:n,onEnd:(t,e)=>{delete this.session,i&&R.postRender(()=>i(t,e))}}}mount(){this.removePointerDownListener=Zn(this.node.current,"pointerdown",t=>this.onPointerDown(t))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}},drag:{Feature:class extends Hn{constructor(t){super(t),this.removeGroupControls=C,this.removeListeners=C,this.controls=new zi(t)}mount(){const{dragControls:t}=this.node.getProps();t&&(this.removeGroupControls=t.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||C}unmount(){this.removeGroupControls(),this.removeListeners()}},ProjectionNode:Hr,MeasureLayout:ha}};function ma(t,e){const n=e?"pointerenter":"pointerleave",i=e?"onHoverStart":"onHoverEnd";return Zn(t.current,n,(n,s)=>{if("touch"===n.pointerType||hi())return;const o=t.getProps();t.animationState&&o.whileHover&&t.animationState.setActive("whileHover",e);const r=o[i];r&&R.postRender(()=>r(n,s))},{passive:!t.getProps()[i]})}const fa=(t,e)=>!!e&&(t===e||fa(t,e.parentElement));function ga(t,e){if(!e)return;const n=new PointerEvent("pointer"+t);e(n,Kn(n))}const ya=new WeakMap,va=new WeakMap,xa=t=>{const e=ya.get(t.target);e&&e(t)},wa=t=>{t.forEach(xa)};function Pa(t,e,n){const i=function({root:t,...e}){const n=t||document;va.has(n)||va.set(n,{});const i=va.get(n),s=JSON.stringify(e);return i[s]||(i[s]=new IntersectionObserver(wa,{root:t,...e})),i[s]}(e);return ya.set(t,n),i.observe(t),()=>{ya.delete(t),i.unobserve(t)}}const Sa={some:0,all:1};const Ta={inView:{Feature:class extends Hn{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:t={}}=this.node.getProps(),{root:e,margin:n,amount:i="some",once:s}=t,o={root:e?e.current:void 0,rootMargin:n,threshold:"number"==typeof i?i:Sa[i]};return Pa(this.node.current,o,t=>{const{isIntersecting:e}=t;if(this.isInView===e)return;if(this.isInView=e,s&&!e&&this.hasEnteredView)return;e&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",e);const{onViewportEnter:n,onViewportLeave:i}=this.node.getProps(),o=e?n:i;o&&o(t)})}mount(){this.startObserver()}update(){if("undefined"==typeof IntersectionObserver)return;const{props:t,prevProps:e}=this.node;["amount","margin","root"].some(function({viewport:t={}},{viewport:e={}}={}){return n=>t[n]!==e[n]}(t,e))&&this.startObserver()}unmount(){}}},tap:{Feature:class extends Hn{constructor(){super(...arguments),this.removeStartListeners=C,this.removeEndListeners=C,this.removeAccessibleListeners=C,this.startPointerPress=(t,e)=>{if(this.isPressing)return;this.removeEndListeners();const n=this.node.getProps(),i=Zn(window,"pointerup",(t,e)=>{if(!this.checkPressEnd())return;const{onTap:n,onTapCancel:i,globalTapTarget:s}=this.node.getProps(),o=s||fa(this.node.current,t.target)?n:i;o&&R.update(()=>o(t,e))},{passive:!(n.onTap||n.onPointerUp)}),s=Zn(window,"pointercancel",(t,e)=>this.cancelPress(t,e),{passive:!(n.onTapCancel||n.onPointerCancel)});this.removeEndListeners=Ve(i,s),this.startPress(t,e)},this.startAccessiblePress=()=>{const t=qn(this.node.current,"keydown",t=>{if("Enter"!==t.key||this.isPressing)return;this.removeEndListeners(),this.removeEndListeners=qn(this.node.current,"keyup",t=>{"Enter"===t.key&&this.checkPressEnd()&&ga("up",(t,e)=>{const{onTap:n}=this.node.getProps();n&&R.postRender(()=>n(t,e))})}),ga("down",(t,e)=>{this.startPress(t,e)})}),e=qn(this.node.current,"blur",()=>{this.isPressing&&ga("cancel",(t,e)=>this.cancelPress(t,e))});this.removeAccessibleListeners=Ve(t,e)}}startPress(t,e){this.isPressing=!0;const{onTapStart:n,whileTap:i}=this.node.getProps();i&&this.node.animationState&&this.node.animationState.setActive("whileTap",!0),n&&R.postRender(()=>n(t,e))}checkPressEnd(){this.removeEndListeners(),this.isPressing=!1;return this.node.getProps().whileTap&&this.node.animationState&&this.node.animationState.setActive("whileTap",!1),!hi()}cancelPress(t,e){if(!this.checkPressEnd())return;const{onTapCancel:n}=this.node.getProps();n&&R.postRender(()=>n(t,e))}mount(){const t=this.node.getProps(),e=Zn(t.globalTapTarget?window:this.node.current,"pointerdown",this.startPointerPress,{passive:!(t.onTapStart||t.onPointerStart)}),n=qn(this.node.current,"focus",this.startAccessiblePress);this.removeStartListeners=Ve(e,n)}unmount(){this.removeStartListeners(),this.removeEndListeners(),this.removeAccessibleListeners()}}},focus:{Feature:class extends Hn{constructor(){super(...arguments),this.isActive=!1}onFocus(){let t=!1;try{t=this.node.current.matches(":focus-visible")}catch(e){t=!0}t&&this.node.animationState&&(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){this.isActive&&this.node.animationState&&(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=Ve(qn(this.node.current,"focus",()=>this.onFocus()),qn(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}},hover:{Feature:class extends Hn{mount(){this.unmount=Ve(ma(this.node,!0),ma(this.node,!1))}unmount(){}}}},ba={layout:{ProjectionNode:Hr,MeasureLayout:ha}},Aa=e.createContext({transformPagePoint:t=>t,isStatic:!1,reducedMotion:"never"}),Ea=e.createContext({}),Ca=zs?e.useLayoutEffect:e.useEffect,Ma=e.createContext({strict:!1});function Va(t,n,i,s,o){var r,a;const{visualElement:l}=e.useContext(Ea),u=e.useContext(Ma),c=e.useContext(ra),h=e.useContext(Aa).reducedMotion,d=e.useRef();s=s||u.renderer,!d.current&&s&&(d.current=s(t,{visualState:n,parent:l,props:i,presenceContext:c,blockInitialAnimation:!!c&&!1===c.initial,reducedMotionConfig:h}));const p=d.current,m=e.useContext(ua);!p||p.projection||!o||"html"!==p.type&&"svg"!==p.type||function(t,e,n,i){const{layoutId:s,layout:o,drag:r,dragConstraints:a,layoutScroll:l,layoutRoot:u}=e;t.projection=new n(t.latestValues,e["data-framer-portal-id"]?void 0:function t(e){return e?!1!==e.options.allowProjection?e.projection:t(e.parent):void 0}(t.parent)),t.projection.setOptions({layoutId:s,layout:o,alwaysMeasureLayout:Boolean(r)||a&&di(a),visualElement:t,animationType:"string"==typeof o?o:"both",initialPromotionConfig:i,layoutScroll:l,layoutRoot:u})}(d.current,i,o,m),e.useInsertionEffect(()=>{p&&p.update(i,c)});const f=i[Mn],g=e.useRef(Boolean(f)&&!(null===(r=window.MotionHandoffIsComplete)||void 0===r?void 0:r.call(window,f))&&(null===(a=window.MotionHasOptimisedAnimation)||void 0===a?void 0:a.call(window,f)));return Ca(()=>{p&&(window.MotionIsMounted=!0,p.updateFeatures(),hr.render(p.render),g.current&&p.animationState&&p.animationState.animateChanges())}),e.useEffect(()=>{p&&(!g.current&&p.animationState&&p.animationState.animateChanges(),g.current&&(queueMicrotask(()=>{var t;null===(t=window.MotionHandoffMarkAsComplete)||void 0===t||t.call(window,f)}),g.current=!1))}),p}function Ra(t,n,i){return e.useCallback(e=>{e&&t.mount&&t.mount(e),n&&(e?n.mount(e):n.unmount()),i&&("function"==typeof i?i(e):di(i)&&(i.current=e))},[n])}function Da(t){const{initial:n,animate:i}=function(t,e){if(Xs(t)){const{initial:e,animate:n}=t;return{initial:!1===e||l(e)?e:void 0,animate:l(n)?n:void 0}}return!1!==t.inherit?e:{}}(t,e.useContext(Ea));return e.useMemo(()=>({initial:n,animate:i}),[ka(n),ka(i)])}function ka(t){return Array.isArray(t)?t.join(" "):t}function La(t){for(const e in t)_s[e]={..._s[e],...t[e]}}const Ba=Symbol.for("motionComponentSymbol");function Fa({preloadedFeatures:t,createVisualElement:n,useRender:i,useVisualState:s,Component:o}){t&&La(t);const r=e.forwardRef((function(t,r){let a;const l={...e.useContext(Aa),...t,layoutId:ja(t)},{isStatic:u}=l,c=Da(t),h=s(t,u);if(!u&&zs){e.useContext(Ma).strict;const t=function(t){const{drag:e,layout:n}=_s;if(!e&&!n)return{};const i={...e,...n};return{MeasureLayout:(null==e?void 0:e.isEnabled(t))||(null==n?void 0:n.isEnabled(t))?i.MeasureLayout:void 0,ProjectionNode:i.ProjectionNode}}(l);a=t.MeasureLayout,c.visualElement=Va(o,h,l,n,t.ProjectionNode)}return oa(Ea.Provider,{value:c,children:[a&&c.visualElement?sa(a,{visualElement:c.visualElement,...l}):null,i(o,t,Ra(h,c.visualElement,r),h,u,c.visualElement)]})}));return r[Ba]=o,r}function ja({layoutId:t}){const n=e.useContext(la).id;return n&&void 0!==t?n+"-"+t:t}const Oa=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function Ia(t){return"string"==typeof t&&!t.includes("-")&&!!(Oa.indexOf(t)>-1||/[A-Z]/u.test(t))}function Ua(t){const n=e.useRef(null);return null===n.current&&(n.current=t()),n.current}const Wa=t=>(n,i)=>{const s=e.useContext(Ea),o=e.useContext(ra),r=()=>function({scrapeMotionValuesFromProps:t,createRenderState:e,onMount:n},i,s,o){const r={latestValues:Na(i,s,o,t),renderState:e()};return n&&(r.mount=t=>n(i,t,r)),r}(t,n,s,o);return i?r():Ua(r)};function Na(t,e,n,i){const s={},r=i(t,{});for(const t in r)s[t]=xs(r[t]);let{initial:a,animate:l}=t;const u=Xs(t),h=Gs(t);e&&h&&!u&&!1!==t.inherit&&(void 0===a&&(a=e.initial),void 0===l&&(l=e.animate));let d=!!n&&!1===n.initial;d=d||!1===a;const p=d?l:a;if(p&&"boolean"!=typeof p&&!o(p)){const e=Array.isArray(p)?p:[p];for(let n=0;n<e.length;n++){const i=c(t,e[n]);if(i){const{transitionEnd:t,transition:e,...n}=i;for(const t in n){let e=n[t];if(Array.isArray(e)){e=e[d?e.length-1:0]}null!==e&&(s[t]=e)}for(const e in t)s[e]=t[e]}}}return s}const za=()=>({style:{},transform:{},transformOrigin:{},vars:{}}),$a=()=>({style:{},transform:{},transformOrigin:{},vars:{},attrs:{}}),Ha={useVisualState:Wa({scrapeMotionValuesFromProps:Ns,createRenderState:$a,onMount:(t,e,{renderState:n,latestValues:i})=>{R.read(()=>{try{n.dimensions="function"==typeof e.getBBox?e.getBBox():e.getBoundingClientRect()}catch(t){n.dimensions={x:0,y:0,width:0,height:0}}}),R.render(()=>{lo(n,i,po(e.tagName),t.transformTemplate),ho(e,n)})}})},Ya={useVisualState:Wa({scrapeMotionValuesFromProps:Ws,createRenderState:za})};function Xa(t,e,n){for(const i in e)Rn(e[i])||Us(i,n)||(t[i]=e[i])}function Ga(t,n){const i={};return Xa(i,t.style||{},t),Object.assign(i,function({transformTemplate:t},n){return e.useMemo(()=>{const e={style:{},transform:{},transformOrigin:{},vars:{}};return so(e,n,t),Object.assign({},e.vars,e.style)},[n])}(t,n)),i}function Ka(t,e){const n={},i=Ga(t,e);return t.drag&&!1!==t.dragListener&&(n.draggable=!1,i.userSelect=i.WebkitUserSelect=i.WebkitTouchCallout="none",i.touchAction=!0===t.drag?"none":"pan-"+("x"===t.drag?"y":"x")),void 0===t.tabIndex&&(t.onTap||t.onTapStart||t.whileTap)&&(n.tabIndex=0),n.style=i,n}const _a=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function qa(t){return t.startsWith("while")||t.startsWith("drag")&&"draggable"!==t||t.startsWith("layout")||t.startsWith("onTap")||t.startsWith("onPan")||t.startsWith("onLayout")||_a.has(t)}let Za=t=>!qa(t);function Ja(t){t&&(Za=e=>e.startsWith("on")?!qa(e):t(e))}try{Ja(require("@emotion/is-prop-valid").default)}catch(t){}function Qa(t,e,n){const i={};for(const s in t)"values"===s&&"object"==typeof t.values||(Za(s)||!0===n&&qa(s)||!e&&!qa(s)||t.draggable&&s.startsWith("onDrag"))&&(i[s]=t[s]);return i}function tl(t,n,i,s){const o=e.useMemo(()=>{const e={style:{},transform:{},transformOrigin:{},vars:{},attrs:{}};return lo(e,n,po(s),t.transformTemplate),{...e.attrs,style:{...e.style}}},[n]);if(t.style){const e={};Xa(e,t.style,t),o.style={...e,...o.style}}return o}function el(t=!1){return(n,i,s,{latestValues:o},r)=>{const a=(Ia(n)?tl:Ka)(i,o,r,n),l=Qa(i,"string"==typeof n,t),u=n!==e.Fragment?{...l,...a,ref:s}:{},{children:c}=i,h=e.useMemo(()=>Rn(c)?c.get():c,[c]);return e.createElement(n,{...u,children:h})}}function nl(t,e){return function(n,{forwardMotionProps:i}={forwardMotionProps:!1}){return Fa({...Ia(n)?Ha:Ya,preloadedFeatures:t,useRender:el(i),createVisualElement:e,Component:n})}}const il=(t,n)=>Ia(t)?new mo(n):new fo(n,{allowProjection:t!==e.Fragment}),sl=s(nl({...Xn,...Ta,...pa,...ba},il)),ol=s(nl());class rl extends i.Component{getSnapshotBeforeUpdate(t){const e=this.props.childRef.current;if(e&&t.isPresent&&!this.props.isPresent){const t=this.props.sizeRef.current;t.height=e.offsetHeight||0,t.width=e.offsetWidth||0,t.top=e.offsetTop,t.left=e.offsetLeft}return null}componentDidUpdate(){}render(){return this.props.children}}function al({children:t,isPresent:n,parentDom:s}){const o=e.useId(),r=e.useRef(null),a=e.useRef({width:0,height:0,top:0,left:0}),{nonce:l}=e.useContext(Aa);return e.useInsertionEffect(()=>{const{width:t,height:e,top:i,left:u}=a.current;if(n||!r.current||!t||!e)return;r.current.dataset.motionPopId=o;const c=document.createElement("style");l&&(c.nonce=l);const h=null!=s?s:document.head;return h.appendChild(c),c.sheet&&c.sheet.insertRule(`\n          [data-motion-pop-id="${o}"] {\n            position: absolute !important;\n            width: ${t}px !important;\n            height: ${e}px !important;\n            top: ${i}px !important;\n            left: ${u}px !important;\n          }\n        `),()=>{h.removeChild(c)}},[n]),sa(rl,{isPresent:n,childRef:r,sizeRef:a,children:i.cloneElement(t,{ref:r})})}const ll=({children:t,initial:n,isPresent:s,onExitComplete:o,custom:r,presenceAffectsLayout:a,mode:l,parentDom:u})=>{const c=Ua(ul),h=e.useId(),d=e.useCallback(t=>{c.set(t,!0);for(const t of c.values())if(!t)return;o&&o()},[c,o]),p=e.useMemo(()=>({id:h,initial:n,isPresent:s,custom:r,onExitComplete:d,register:t=>(c.set(t,!1),()=>c.delete(t))}),a?[Math.random(),d]:[s,d]);return e.useMemo(()=>{c.forEach((t,e)=>c.set(e,!1))},[s]),i.useEffect(()=>{!s&&!c.size&&o&&o()},[s]),"popLayout"===l&&(t=sa(al,{isPresent:s,parentDom:u,children:t})),sa(ra.Provider,{value:p,children:t})};function ul(){return new Map}function cl(t){return e.useEffect(()=>()=>t(),[])}function hl(){const t=function(){const t=e.useRef(!1);return Ca(()=>(t.current=!0,()=>{t.current=!1}),[]),t}(),[n,i]=e.useState(0),s=e.useCallback(()=>{t.current&&i(n+1)},[n]);return[e.useCallback(()=>R.postRender(s),[s]),n]}const dl=t=>t.key||"";function pl(t){const n=[];return e.Children.forEach(t,t=>{e.isValidElement(t)&&n.push(t)}),n}function ml(t){return"function"==typeof t}const fl=e.createContext(null),gl=t=>!0===t,yl=({children:t,id:n,inherit:i=!0})=>{const s=e.useContext(la),o=e.useContext(fl),[r,a]=hl(),l=e.useRef(null),u=s.id||o;null===l.current&&((t=>gl(!0===t)||"id"===t)(i)&&u&&(n=n?u+"-"+n:u),l.current={id:n,group:gl(i)&&s.group||Xr()});const c=e.useMemo(()=>({...l.current,forceRender:r}),[a]);return sa(la.Provider,{value:c,children:t})},vl=e.createContext(null);function xl({children:t,as:n="ul",axis:i="y",onReorder:s,values:o,...r},a){const l=Ua(()=>sl[n]),u=[],c=e.useRef(!1),h={axis:i,registerItem:(t,e)=>{const n=u.findIndex(e=>t===e.value);-1!==n?u[n].layout=e[i]:u.push({value:t,layout:e[i]}),u.sort(Sl)},updateOrder:(t,e,n)=>{if(c.current)return;const i=function(t,e,n,i){if(!i)return t;const s=t.findIndex(t=>t.value===e);if(-1===s)return t;const o=i>0?1:-1,r=t[s+o];if(!r)return t;const a=t[s],l=r.layout,u=De(l.min,l.max,.5);return 1===o&&a.layout.max+n>u||-1===o&&a.layout.min+n<u?function([...t],e,n){const i=e<0?t.length+e:e;if(i>=0&&i<t.length){const i=n<0?t.length+n:n,[s]=t.splice(e,1);t.splice(i,0,s)}return t}(t,s,s+o):t}(u,t,e,n);u!==i&&(c.current=!0,s(i.map(Pl).filter(t=>-1!==o.indexOf(t))))}};return e.useEffect(()=>{c.current=!1}),sa(l,{...r,ref:a,ignoreStrict:!0,children:sa(vl.Provider,{value:h,children:t})})}const wl=e.forwardRef(xl);function Pl(t){return t.value}function Sl(t,e){return t.layout.min-e.layout.min}function Tl(t){const n=Ua(()=>bn(t)),{isStatic:i}=e.useContext(Aa);if(i){const[,i]=e.useState(t);e.useEffect(()=>n.on("change",i),[])}return n}function bl(t,e){const n=Tl(e()),i=()=>n.set(e());return i(),Ca(()=>{const e=()=>R.preRender(i,!1,!0),n=t.map(t=>t.on("change",e));return()=>{n.forEach(t=>t()),D(i)}}),n}function Al(t,e,n,i){if("function"==typeof t)return function(t){Sn.current=[],t();const e=bl(Sn.current,t);return Sn.current=void 0,e}(t);const s="function"==typeof e?e:lr(e,n,i);return Array.isArray(t)?El(t,s):El([t],([t])=>s(t))}function El(t,e){const n=Ua(()=>[]);return bl(t,()=>{n.length=0;const i=t.length;for(let e=0;e<i;e++)n[e]=t[e].get();return e(n)})}function Cl(t,e=0){return Rn(t)?t:Tl(e)}function Ml({children:t,style:n={},value:i,as:s="li",onDrag:o,layout:r=!0,...a},l){const u=Ua(()=>sl[s]),c=e.useContext(vl),h={x:Cl(n.x),y:Cl(n.y)},d=Al([h.x,h.y],([t,e])=>t||e?1:"unset"),{axis:p,registerItem:m,updateOrder:f}=c;return sa(u,{drag:p,...a,dragSnapToOrigin:!0,style:{...n,x:h.x,y:h.y,zIndex:d},layout:r,onDrag:(t,e)=>{const{velocity:n}=e;n[p]&&f(i,h[p].get(),n[p]),o&&o(t,e)},onLayoutMeasure:t=>m(i,t),ref:l,ignoreStrict:!0,children:t})}const Vl=e.forwardRef(Ml);var Rl=Object.freeze({__proto__:null,Group:wl,Item:Vl});const Dl={renderer:il,...Xn},kl={renderer:il,...Xn,...Ta},Ll={...kl,...pa,...ba};function Bl(t){return"number"==typeof t?t:parseFloat(t)}function Fl(t,n,i){e.useInsertionEffect(()=>t.on(n,i),[t,n,i])}function jl(t,e){X(Boolean(!e||e.current))}const Ol=()=>({scrollX:bn(0),scrollY:bn(0),scrollXProgress:bn(0),scrollYProgress:bn(0)});function Il({container:t,target:n,layoutEffect:i=!0,...s}={}){const o=Ua(Ol);return(i?Ca:e.useEffect)(()=>(jl(0,n),jl(0,t),or((t,{x:e,y:n})=>{o.scrollX.set(e.current),o.scrollXProgress.set(e.progress),o.scrollY.set(n.current),o.scrollYProgress.set(n.progress)},{...s,container:(null==t?void 0:t.current)||void 0,target:(null==n?void 0:n.current)||void 0})),[t,n,JSON.stringify(s.offset)]),o}function Ul(t){const n=e.useRef(0),{isStatic:i}=e.useContext(Aa);e.useEffect(()=>{if(i)return;const e=({timestamp:e,delta:i})=>{n.current||(n.current=e),t(e-n.current,i)};return R.update(e,!0),()=>D(e)},[t])}class Wl extends Tn{constructor(){super(...arguments),this.values=[]}add(t){const e=function(t){return f.has(t)?"transform":en.has(t)?Cn(t):void 0}(t);e&&(xn(this.values,e),this.update())}update(){this.set(this.values.length?this.values.join(", "):"auto")}}function Nl(){!Hs.current&&Ys();const[t]=e.useState($s.current);return t}function zl(t,e){[...e].reverse().forEach(n=>{const i=t.getVariant(n);i&&En(t,i),t.variantChildren&&t.variantChildren.forEach(t=>{zl(t,e)})})}function $l(){const t=new Set,e={subscribe:e=>(t.add(e),()=>{t.delete(e)}),start(e,n){const i=[];return t.forEach(t=>{i.push(jn(t,e,{transitionOverride:n}))}),Promise.all(i)},set:e=>t.forEach(t=>{!function(t,e){Array.isArray(e)?zl(t,e):"string"==typeof e?zl(t,[e]):En(t,e)}(t,e)}),stop(){t.forEach(t=>{!function(t){t.values.forEach(t=>t.stop())}(t)})},mount:()=>()=>{e.stop()}};return e}function Hl(){const t=Ua($l);return Ca(t.mount,[]),t}const Yl=Hl;class Xl{constructor(){this.componentControls=new Set}subscribe(t){return this.componentControls.add(t),()=>this.componentControls.delete(t)}start(t,e){this.componentControls.forEach(n=>{n.start(t.nativeEvent||t,e)})}}const Gl=()=>new Xl;function Kl(t){return null!==t&&"object"==typeof t&&Ba in t}function _l(){return ql}function ql(t){$r.current&&($r.current.isUpdating=!1,$r.current.blockUpdate(),t&&t())}const Zl=(t,e)=>`${t}: ${f.has(e)?"transform":e}`,Jl=new Map,Ql=new Map;function tu(t,e,n){var i;const s=Zl(t,e),o=Jl.get(s);if(!o)return null;const{animation:r,startTime:a}=o;function l(){var i;null===(i=window.MotionCancelOptimisedAnimation)||void 0===i||i.call(window,t,e,n)}return r.onfinish=l,null===a||(null===(i=window.MotionHandoffIsComplete)||void 0===i?void 0:i.call(window,t))?(l(),null):a}let eu,nu;const iu=new Set;function su(){iu.forEach(t=>{t.animation.play(),t.animation.startTime=t.startTime}),iu.clear()}const ou=()=>({});class ru extends Js{constructor(){super(...arguments),this.measureInstanceViewportBox=bi}build(){}resetTransform(){}restoreTransform(){}removeValueFromRenderState(){}renderInstance(){}scrapeMotionValuesFromProps(){return{}}getBaseTargetFromProps(){}readValueFromInstance(t,e,n){return n.initialState[e]||0}sortInstanceNodePosition(){return 0}}const au=Wa({scrapeMotionValuesFromProps:ou,createRenderState:ou});const lu=t=>t>.001?1/t:1e5;let uu=0;t.AcceleratedAnimation=fn,t.AnimatePresence=({children:t,exitBeforeEnter:n,custom:i,initial:s=!0,onExitComplete:o,presenceAffectsLayout:r=!0,mode:a="sync",parentDom:l})=>{const u=e.useMemo(()=>pl(t),[t]),c=u.map(dl),h=e.useRef(!0),d=e.useRef(u),p=Ua(()=>new Map),[m,f]=e.useState(u),[g,y]=e.useState(u);Ca(()=>{h.current=!1,d.current=u;for(let t=0;t<g.length;t++){const e=dl(g[t]);c.includes(e)?p.delete(e):!0!==p.get(e)&&p.set(e,!1)}},[g,c.length,c.join("-")]);const v=[];if(u!==m){let t=[...u];for(let e=0;e<g.length;e++){const n=g[e],i=dl(n);c.includes(i)||(t.splice(e,0,n),v.push(n))}return"wait"===a&&v.length&&(t=v),y(pl(t)),void f(u)}const{forceRender:x}=e.useContext(la);return sa(ia,{children:g.map(t=>{const e=dl(t),n=u===g||c.includes(e);return sa(ll,{isPresent:n,initial:!(h.current&&!s)&&void 0,custom:n?void 0:i,presenceAffectsLayout:r,mode:a,parentDom:l,onExitComplete:n?void 0:()=>{if(!p.has(e))return;p.set(e,!0);let t=!0;p.forEach(e=>{e||(t=!1)}),t&&(null==x||x(),y(d.current),o&&o())},children:t},e)})})},t.AnimateSharedLayout=({children:t})=>(i.useEffect(()=>{},[]),sa(yl,{id:Ua(()=>"asl-"+uu++),children:t})),t.DeprecatedLayoutGroupContext=fl,t.DragControls=Xl,t.FlatTree=vs,t.LayoutGroup=yl,t.LayoutGroupContext=la,t.LazyMotion=function({children:t,features:n,strict:i=!1}){const[,s]=e.useState(!ml(n)),o=e.useRef(void 0);if(!ml(n)){const{renderer:t,...e}=n;o.current=t,La(e)}return e.useEffect(()=>{ml(n)&&n().then(({renderer:t,...e})=>{La(e),o.current=t,s(!0)})},[]),sa(Ma.Provider,{value:{renderer:o.current,strict:i},children:t})},t.MotionConfig=function({children:t,isValidProp:n,...i}){n&&Ja(n),(i={...e.useContext(Aa),...i}).isStatic=Ua(()=>i.isStatic);const s=e.useMemo(()=>i,[JSON.stringify(i.transition),i.transformPagePoint,i.reducedMotion]);return sa(Aa.Provider,{value:s,children:t})},t.MotionConfigContext=Aa,t.MotionContext=Ea,t.MotionGlobalConfig=T,t.MotionValue=Tn,t.PresenceContext=ra,t.Reorder=Rl,t.SwitchLayoutGroupContext=ua,t.VisualElement=Js,t.addPointerEvent=Zn,t.addPointerInfo=_n,t.addScaleCorrector=gs,t.animate=To,t.animateMini=Do,t.animateValue=tn,t.animateVisualElement=jn,t.animationControls=$l,t.animations=Xn,t.anticipate=N,t.backIn=U,t.backInOut=W,t.backOut=I,t.buildTransform=io,t.calcLength=pi,t.cancelFrame=D,t.cancelSync=cr,t.circIn=z,t.circInOut=H,t.circOut=$,t.clamp=nt,t.color=It,t.complex=Yt,t.createBox=bi,t.createRendererMotionComponent=Fa,t.createScopedAnimate=So,t.cubicBezier=F,t.delay=Ps,t.disableInstantTransitions=function(){b.current=!1},t.distance=Jn,t.distance2D=Qn,t.domAnimation=kl,t.domMax=Ll,t.domMin=Dl,t.easeIn=Pe,t.easeInOut=Te,t.easeOut=Se,t.filterProps=Qa,t.findSpring=me,t.frame=R,t.frameData=k,t.frameSteps=L,t.inView=ar,t.inertia=we,t.interpolate=Ye,t.invariant=G,t.isBrowser=zs,t.isDragActive=hi,t.isMotionComponent=Kl,t.isMotionValue=Rn,t.isValidMotionProp=qa,t.keyframes=Ke,t.m=ol,t.makeUseVisualState=Wa,t.mirrorEasing=j,t.mix=He,t.motion=sl,t.motionValue=bn,t.optimizedAppearDataAttribute=Mn,t.pipe=Ve,t.progress=Re,t.px=ut,t.resolveMotionValue=xs,t.reverseEasing=O,t.scroll=or,t.scrollInfo=tr,t.spring=xe,t.stagger=function(t=.1,{startDelay:e=0,from:n=0,ease:i}={}){return(s,o)=>{const r="number"==typeof n?n:function(t,e){if("first"===t)return 0;{const n=e-1;return"last"===t?n:n/2}}(n,o),a=Math.abs(r-s);let l=t*a;if(i){const e=o*t;l=Ce(i)(l/e)*e}return e+l}},t.startOptimizedAppearAnimation=function(t,e,n,i,s){if(window.MotionIsMounted)return;const o=t.dataset.framerAppearId;if(!o)return;window.MotionHandoffAnimation=tu;const r=Zl(o,e);nu||(nu=hn(t,e,[n[0],n[0]],{duration:1e4,ease:"linear"}),Jl.set(r,{animation:nu,startTime:null}),window.MotionHandoffAnimation=tu,window.MotionHasOptimisedAnimation=(t,e)=>{if(!t)return!1;if(!e)return Ql.has(t);const n=Zl(t,e);return Boolean(Jl.get(n))},window.MotionHandoffMarkAsComplete=t=>{Ql.has(t)&&Ql.set(t,!0)},window.MotionHandoffIsComplete=t=>!0===Ql.get(t),window.MotionCancelOptimisedAnimation=(t,e,n,i)=>{const s=Zl(t,e),o=Jl.get(s);o&&(n&&void 0===i?n.postRender(()=>{n.postRender(()=>{o.animation.cancel()})}):o.animation.cancel(),n&&i?(iu.add(o),n.render(su)):(Jl.delete(s),Jl.size||(window.MotionCancelOptimisedAnimation=void 0)))},window.MotionCheckAppearSync=(t,e,n)=>{var i,s;const o=Vn(t);if(!o)return;const r=null===(i=window.MotionHasOptimisedAnimation)||void 0===i?void 0:i.call(window,o,e),a=null===(s=t.props.values)||void 0===s?void 0:s[e];if(!r||!a)return;const l=n.on("change",t=>{var n;a.get()!==t&&(null===(n=window.MotionCancelOptimisedAnimation)||void 0===n||n.call(window,o,e),l())});return l});const a=()=>{nu.cancel();const o=hn(t,e,n,i);void 0===eu&&(eu=performance.now()),o.startTime=eu,Jl.set(r,{animation:o,startTime:eu}),s&&s(o)};Ql.set(o,!1),nu.ready?nu.ready.then(a).catch(C):a()},t.steps=function(t,e="end"){return n=>{const i=(n="end"===e?Math.min(n,.999):Math.max(n,.001))*t,s="end"===e?Math.floor(i):Math.ceil(i);return nt(0,1,s/t)}},t.sync=ur,t.transform=lr,t.unwrapMotionComponent=function(t){if(Kl(t))return t[Ba]},t.useAnimate=function(){const t=Ua(()=>({current:null,animations:[]})),e=Ua(()=>So(t));return cl(()=>{t.animations.forEach(t=>t.stop())}),[t,e]},t.useAnimateMini=function(){const t=Ua(()=>({current:null,animations:[]})),e=Ua(()=>Ro(t));return cl(()=>{t.animations.forEach(t=>t.stop())}),[t,e]},t.useAnimation=Yl,t.useAnimationControls=Hl,t.useAnimationFrame=Ul,t.useCycle=function(...t){const n=e.useRef(0),[i,s]=e.useState(t[n.current]);return[i,e.useCallback(e=>{n.current="number"!=typeof e?Cs(0,t.length,n.current+1):e,s(t[n.current])},[t.length,...t])]},t.useDeprecatedAnimatedState=function(t){const[n,i]=e.useState(t),s=au({},!1),o=Ua(()=>new ru({props:{onUpdate:t=>{i({...t})}},visualState:s,presenceContext:null},{initialState:t}));return e.useLayoutEffect(()=>(o.mount({}),()=>o.unmount()),[o]),[n,Ua(()=>t=>jn(o,t))]},t.useDeprecatedInvertedScale=function(t){let n=Tl(1),i=Tl(1);const{visualElement:s}=e.useContext(Ea);return t?(n=t.scaleX||n,i=t.scaleY||i):s&&(n=s.getValue("scaleX",1),i=s.getValue("scaleY",1)),{scaleX:Al(n,lu),scaleY:Al(i,lu)}},t.useDomEvent=function(t,n,i,s){e.useEffect(()=>{const e=t.current;if(i&&e)return qn(e,n,i,s)},[t,n,i,s])},t.useDragControls=function(){return Ua(Gl)},t.useElementScroll=function(t){return Il({container:t})},t.useForceUpdate=hl,t.useInView=function(t,{root:n,margin:i,amount:s,once:o=!1}={}){const[r,a]=e.useState(!1);return e.useEffect(()=>{if(!t.current||o&&r)return;const e={root:n&&n.current||void 0,margin:i,amount:s};return ar(t.current,()=>(a(!0),o?void 0:()=>a(!1)),e)},[n,t,i,o,s]),r},t.useInstantLayoutTransition=_l,t.useInstantTransition=function(){const[t,n]=hl(),i=_l(),s=e.useRef();return e.useEffect(()=>{R.postRender(()=>R.postRender(()=>{n===s.current&&(b.current=!1)}))},[n]),e=>{i(()=>{b.current=!0,t(),e(),s.current=n+1})}},t.useIsPresent=function(){return null===(t=e.useContext(ra))||t.isPresent;var t},t.useIsomorphicLayoutEffect=Ca,t.useMotionTemplate=function(t,...e){const n=t.length;return bl(e.filter(Rn),(function(){let i="";for(let s=0;s<n;s++){i+=t[s];const n=e[s];n&&(i+=Rn(n)?n.get():n)}return i}))},t.useMotionValue=Tl,t.useMotionValueEvent=Fl,t.usePresence=aa,t.useReducedMotion=Nl,t.useReducedMotionConfig=function(){const t=Nl(),{reducedMotion:n}=e.useContext(Aa);return"never"!==n&&("always"===n||t)},t.useResetProjection=function(){return e.useCallback(()=>{const t=$r.current;t&&t.resetTree()},[])},t.useScroll=Il,t.useSpring=function(t,n={}){const{isStatic:i}=e.useContext(Aa),s=e.useRef(null),o=Tl(Rn(t)?Bl(t.get()):t),r=e.useRef(o.get()),a=e.useRef(()=>{}),l=()=>{const t=s.current;t&&0===t.time&&t.sample(k.delta),u(),s.current=tn({keyframes:[o.get(),r.current],velocity:o.getVelocity(),type:"spring",restDelta:.001,restSpeed:.01,...n,onUpdate:a.current})},u=()=>{s.current&&s.current.stop()};return e.useInsertionEffect(()=>o.attach((t,e)=>i?e(t):(r.current=t,a.current=e,R.update(l),o.get()),u),[JSON.stringify(n)]),Ca(()=>{if(Rn(t))return t.on("change",t=>o.set(Bl(t)))},[o]),o},t.useTime=function(){const t=Tl(0);return Ul(e=>t.set(e)),t},t.useTransform=Al,t.useUnmountEffect=cl,t.useVelocity=function(t){const e=Tl(t.getVelocity()),n=()=>{const i=t.getVelocity();e.set(i),i&&R.update(n)};return Fl(t,"change",()=>{R.update(n,!1,!0)}),e},t.useViewportScroll=function(){return Il()},t.useWillChange=function(){return Ua(()=>new Wl("auto"))},t.visualElementStore=Os,t.warning=X,t.wrap=Cs}));
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 4f7aaeb940c99197af0487499dab88ecbc401026..955ebe54654f121a67849281013efab0d96dc7f0 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,11 +1,7 @@
 /// <reference types="react" />
 import * as React$1 from 'react';
-import { SVGAttributes as SVGAttributes$1, CSSProperties, PropsWithoutRef, RefAttributes, JSX, useEffect, RefObject as RefObject$1 } from 'react';
+import { SVGAttributes as SVGAttributes$1, CSSProperties, PropsWithoutRef, RefAttributes, ReactHTML, DetailedHTMLFactory, HTMLAttributes, useEffect, RefObject as RefObject$1 } from 'react';
 import * as react_jsx_runtime from 'react/jsx-runtime';
-export { invariant, noop } from 'motion-utils';
-import * as motion_dom from 'motion-dom';
-import { ElementOrSelector, AnimationScope } from 'motion-dom';
-export { isDragActive } from 'motion-dom';
 
 type EasingFunction = (v: number) => number;
 type EasingModifier = (easing: EasingFunction) => EasingFunction;
@@ -457,25 +453,6 @@ interface Spring extends Repeat {
      * @public
      */
     duration?: number;
-    /**
-     * If visualDuration is set, this will override duration.
-     *
-     * The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.
-     *
-     * In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.
-     *
-     * This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.
-     *
-     * ```jsx
-     * <motion.div
-     *   animate={{ x: 100 }}
-     *   transition={{ type: "spring", visualDuration: 0.5 }}
-     * />
-     * ```
-     *
-     * @public
-     */
-    visualDuration?: number;
     /**
      * `bounce` determines the "bounciness" of a spring animation.
      *
@@ -1782,7 +1759,6 @@ interface AnimationState<V> {
 interface KeyframeGenerator<V> {
     calculatedDuration: null | number;
     next: (t: number) => AnimationState<V>;
-    toString: () => string;
 }
 
 interface AnimationPlaybackLifecycles<V> {
@@ -1817,6 +1793,10 @@ interface ValueAnimationOptionsWithRenderContext<V extends string | number = num
     motionValue?: MotionValue<V>;
     element?: VisualElement;
 }
+interface AnimationScope<T = any> {
+    readonly current: T;
+    animations: AnimationPlaybackControls[];
+}
 type StyleTransitions = {
     [K in keyof CSSStyleDeclarationWithTransform]?: Transition;
 };
@@ -1833,6 +1813,7 @@ type AnimationOptionsWithValueOverrides<V = any> = StyleTransitions & SVGPathTra
 interface DynamicAnimationOptions extends Omit<AnimationOptionsWithValueOverrides, "delay"> {
     delay?: number | DynamicOption<number>;
 }
+type ElementOrSelector = Element | Element[] | NodeListOf<Element> | string;
 /**
  * @public
  */
@@ -1849,7 +1830,6 @@ interface AnimationPlaybackControls {
     cancel: () => void;
     then: (onResolve: VoidFunction, onReject?: VoidFunction) => Promise<void>;
     attachTimeline?: (timeline: ProgressTimeline, fallback?: (animation: AnimationPlaybackControls) => VoidFunction) => VoidFunction;
-    flatten: () => void;
 }
 type DynamicOption<T> = (i: number, total: number) => T;
 interface CSSStyleDeclarationWithTransform extends Omit<CSSStyleDeclaration, "direction" | "transition" | "x" | "y" | "z"> {
@@ -1894,7 +1874,6 @@ interface AnimationPlaybackOptions {
 }
 interface DurationSpringOptions {
     duration?: number;
-    visualDuration?: number;
     bounce?: number;
 }
 interface SpringOptions extends DurationSpringOptions, VelocityOptions {
@@ -2016,7 +1995,7 @@ declare class MotionValue<V = any> {
      */
     version: string;
     /**
-     * If a MotionValue has an owner, it was created internally within Motion
+     * If a MotionValue has an owner, it was created internally within Framer Motion
      * and therefore has no external listeners. It is therefore safe to animate via WAAPI.
      */
     owner?: Owner;
@@ -2035,11 +2014,11 @@ declare class MotionValue<V = any> {
     /**
      * The last time the `MotionValue` was updated.
      */
-    updatedAt: number;
+    private updatedAt;
     /**
      * The time `prevFrameValue` was updated.
      */
-    prevUpdatedAt: number | undefined;
+    private prevUpdatedAt;
     private stopPassiveEffect?;
     /**
      * A reference to the currently-controlling animation.
@@ -2465,7 +2444,7 @@ interface DraggableProps extends DragHandlers {
      * }
      * ```
      */
-    dragConstraints?: false | Partial<BoundingBox> | RefObject<Element | null>;
+    dragConstraints?: false | Partial<BoundingBox> | RefObject<Element>;
     /**
      * The degree of movement allowed outside constraints. 0 = no movement, 1 =
      * full movement.
@@ -2915,7 +2894,7 @@ interface HoverHandlers {
 
 type ViewportEventHandler = (entry: IntersectionObserverEntry | null) => void;
 interface ViewportOptions {
-    root?: RefObject<Element | null>;
+    root?: RefObject<Element>;
     once?: boolean;
     margin?: string;
     amount?: "some" | "all" | number;
@@ -3149,7 +3128,7 @@ interface MotionProps extends AnimationProps, EventProps, PanHandlers, TapHandle
      */
     style?: MotionStyle;
     /**
-     * By default, Motion generates a `transform` property with a sensible transform order. `transformTemplate`
+     * By default, Framer Motion generates a `transform` property with a sensible transform order. `transformTemplate`
      * can be used to create a different order, or to append/preprend the automatically generated `transform` property.
      *
      * ```jsx
@@ -3162,7 +3141,7 @@ interface MotionProps extends AnimationProps, EventProps, PanHandlers, TapHandle
      * ```
      *
      * @param transform - The latest animated transform props.
-     * @param generatedTransform - The transform string as automatically generated by Motion
+     * @param generatedTransform - The transform string as automatically generated by Framer Motion
      *
      * @public
      */
@@ -3276,131 +3255,13 @@ interface AnimationLifecycles {
 type EventProps = LayoutLifecycles & AnimationLifecycles;
 type CreateVisualElement<Instance> = (Component: string | React.ComponentType<React.PropsWithChildren<unknown>>, options: VisualElementOptions<Instance>) => VisualElement<Instance>;
 
-type UnionStringArray<T extends Readonly<string[]>> = T[number];
+type UnionStringArray$1<T extends Readonly<string[]>> = T[number];
 declare const svgElements: readonly ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "svg", "switch", "symbol", "text", "tspan", "use", "view", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "linearGradient", "radialGradient", "textPath"];
-type SVGElements = UnionStringArray<typeof svgElements>;
-
-interface HTMLElements {
-    a: HTMLAnchorElement;
-    abbr: HTMLElement;
-    address: HTMLElement;
-    area: HTMLAreaElement;
-    article: HTMLElement;
-    aside: HTMLElement;
-    audio: HTMLAudioElement;
-    b: HTMLElement;
-    base: HTMLBaseElement;
-    bdi: HTMLElement;
-    bdo: HTMLElement;
-    big: HTMLElement;
-    blockquote: HTMLQuoteElement;
-    body: HTMLBodyElement;
-    br: HTMLBRElement;
-    button: HTMLButtonElement;
-    canvas: HTMLCanvasElement;
-    caption: HTMLElement;
-    center: HTMLElement;
-    cite: HTMLElement;
-    code: HTMLElement;
-    col: HTMLTableColElement;
-    colgroup: HTMLTableColElement;
-    data: HTMLDataElement;
-    datalist: HTMLDataListElement;
-    dd: HTMLElement;
-    del: HTMLModElement;
-    details: HTMLDetailsElement;
-    dfn: HTMLElement;
-    dialog: HTMLDialogElement;
-    div: HTMLDivElement;
-    dl: HTMLDListElement;
-    dt: HTMLElement;
-    em: HTMLElement;
-    embed: HTMLEmbedElement;
-    fieldset: HTMLFieldSetElement;
-    figcaption: HTMLElement;
-    figure: HTMLElement;
-    footer: HTMLElement;
-    form: HTMLFormElement;
-    h1: HTMLHeadingElement;
-    h2: HTMLHeadingElement;
-    h3: HTMLHeadingElement;
-    h4: HTMLHeadingElement;
-    h5: HTMLHeadingElement;
-    h6: HTMLHeadingElement;
-    head: HTMLHeadElement;
-    header: HTMLElement;
-    hgroup: HTMLElement;
-    hr: HTMLHRElement;
-    html: HTMLHtmlElement;
-    i: HTMLElement;
-    iframe: HTMLIFrameElement;
-    img: HTMLImageElement;
-    input: HTMLInputElement;
-    ins: HTMLModElement;
-    kbd: HTMLElement;
-    keygen: HTMLElement;
-    label: HTMLLabelElement;
-    legend: HTMLLegendElement;
-    li: HTMLLIElement;
-    link: HTMLLinkElement;
-    main: HTMLElement;
-    map: HTMLMapElement;
-    mark: HTMLElement;
-    menu: HTMLElement;
-    menuitem: HTMLElement;
-    meta: HTMLMetaElement;
-    meter: HTMLMeterElement;
-    nav: HTMLElement;
-    noindex: HTMLElement;
-    noscript: HTMLElement;
-    object: HTMLObjectElement;
-    ol: HTMLOListElement;
-    optgroup: HTMLOptGroupElement;
-    option: HTMLOptionElement;
-    output: HTMLOutputElement;
-    p: HTMLParagraphElement;
-    param: HTMLParamElement;
-    picture: HTMLElement;
-    pre: HTMLPreElement;
-    progress: HTMLProgressElement;
-    q: HTMLQuoteElement;
-    rp: HTMLElement;
-    rt: HTMLElement;
-    ruby: HTMLElement;
-    s: HTMLElement;
-    samp: HTMLElement;
-    search: HTMLElement;
-    slot: HTMLSlotElement;
-    script: HTMLScriptElement;
-    section: HTMLElement;
-    select: HTMLSelectElement;
-    small: HTMLElement;
-    source: HTMLSourceElement;
-    span: HTMLSpanElement;
-    strong: HTMLElement;
-    style: HTMLStyleElement;
-    sub: HTMLElement;
-    summary: HTMLElement;
-    sup: HTMLElement;
-    table: HTMLTableElement;
-    template: HTMLTemplateElement;
-    tbody: HTMLTableSectionElement;
-    td: HTMLTableDataCellElement;
-    textarea: HTMLTextAreaElement;
-    tfoot: HTMLTableSectionElement;
-    th: HTMLTableHeaderCellElement;
-    thead: HTMLTableSectionElement;
-    time: HTMLTimeElement;
-    title: HTMLTitleElement;
-    tr: HTMLTableRowElement;
-    track: HTMLTrackElement;
-    u: HTMLElement;
-    ul: HTMLUListElement;
-    var: HTMLElement;
-    video: HTMLVideoElement;
-    wbr: HTMLElement;
-    webview: HTMLWebViewElement;
-}
+type SVGElements = UnionStringArray$1<typeof svgElements>;
+
+type UnionStringArray<T extends Readonly<string[]>> = T[number];
+declare const htmlElements: readonly ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "webview"];
+type HTMLElements = UnionStringArray<typeof htmlElements>;
 
 interface TransformOrigin {
     originX?: number | string;
@@ -3435,20 +3296,25 @@ interface HTMLRenderState {
 type ForwardRefComponent<T, P> = {
     readonly $$typeof: symbol;
 } & ((props: PropsWithoutRef<P> & RefAttributes<T>) => JSX.Element);
-type AttributesWithoutMotionProps<Attributes> = {
+/**
+ * Support for React component props
+ */
+type UnwrapFactoryAttributes<F> = F extends DetailedHTMLFactory<infer P, any> ? P : never;
+type UnwrapFactoryElement<F> = F extends DetailedHTMLFactory<any, infer P> ? P : never;
+type HTMLAttributesWithoutMotionProps<Attributes extends HTMLAttributes<Element>, Element extends HTMLElement> = {
     [K in Exclude<keyof Attributes, keyof MotionProps>]?: Attributes[K];
 };
 /**
  * @public
  */
-type HTMLMotionProps<Tag extends keyof HTMLElements> = AttributesWithoutMotionProps<JSX.IntrinsicElements[Tag]> & MotionProps;
+type HTMLMotionProps<TagName extends keyof ReactHTML> = HTMLAttributesWithoutMotionProps<UnwrapFactoryAttributes<ReactHTML[TagName]>, UnwrapFactoryElement<ReactHTML[TagName]>> & MotionProps;
 /**
  * Motion-optimised versions of React's HTML components.
  *
  * @public
  */
 type HTMLMotionComponents = {
-    [K in keyof HTMLElements]: ForwardRefComponent<HTMLElements[K], HTMLMotionProps<K>>;
+    [K in HTMLElements]: ForwardRefComponent<UnwrapFactoryElement<ReactHTML[K]>, HTMLMotionProps<K>>;
 };
 
 interface SVGAttributesWithoutMotionProps<T> extends Pick<SVGAttributes$1<T>, Exclude<keyof SVGAttributes$1<T>, keyof MotionProps>> {
@@ -3550,20 +3416,20 @@ type MotionComponentProps<Props> = {
  */
 declare function createRendererMotionComponent<Props extends {}, Instance, RenderState>({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component, }: MotionComponentConfig<Instance, RenderState>): React$1.ForwardRefExoticComponent<React$1.RefAttributes<unknown>>;
 
-declare const motion: (<Props, TagName extends string = "div">(Component: string | TagName | React$1.ComponentType<Props>, { forwardMotionProps }?: {
+declare const motion: (<Props, TagName extends string = "div">(Component: string | TagName | React$1.ForwardRefExoticComponent<Props>, { forwardMotionProps }?: {
     forwardMotionProps: boolean;
-}) => TagName extends "symbol" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "animate" | "text" | "path" | "image" | "circle" | "switch" | "svg" | keyof HTMLElements | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "textPath" | "tspan" | "use" | "view" ? DOMMotionComponents[TagName] : React$1.ComponentType<MotionComponentProps<React$1.PropsWithChildren<Props>>>) & HTMLMotionComponents & SVGMotionComponents & {
-    create: <Props, TagName extends string = "div">(Component: string | TagName | React$1.ComponentType<Props>, { forwardMotionProps }?: {
+}) => TagName extends "symbol" | "object" | "map" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "a" | "b" | "var" | "style" | "animate" | "progress" | "text" | "ruby" | "table" | "small" | "embed" | "sub" | "path" | "image" | "button" | "meter" | "textarea" | "circle" | "pre" | "caption" | "menu" | "menuitem" | "article" | "dialog" | "figure" | "form" | "img" | "link" | "main" | "option" | "switch" | "time" | "div" | "abbr" | "address" | "area" | "aside" | "audio" | "base" | "bdi" | "bdo" | "blockquote" | "body" | "br" | "canvas" | "cite" | "code" | "col" | "colgroup" | "data" | "datalist" | "dd" | "del" | "details" | "dfn" | "dl" | "dt" | "em" | "fieldset" | "figcaption" | "footer" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "head" | "header" | "hgroup" | "hr" | "html" | "i" | "iframe" | "input" | "ins" | "kbd" | "label" | "legend" | "li" | "mark" | "meta" | "nav" | "noscript" | "ol" | "optgroup" | "output" | "p" | "picture" | "q" | "rp" | "rt" | "s" | "samp" | "script" | "section" | "select" | "source" | "span" | "strong" | "summary" | "sup" | "tbody" | "td" | "tfoot" | "th" | "thead" | "title" | "tr" | "track" | "u" | "ul" | "video" | "wbr" | "big" | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "svg" | "textPath" | "tspan" | "use" | "view" | "keygen" | "param" | "webview" ? DOMMotionComponents[TagName] : React$1.ForwardRefExoticComponent<MotionComponentProps<React$1.PropsWithChildren<Props>>>) & HTMLMotionComponents & SVGMotionComponents & {
+    create: <Props, TagName extends string = "div">(Component: string | TagName | React$1.ForwardRefExoticComponent<Props>, { forwardMotionProps }?: {
         forwardMotionProps: boolean;
-    }) => TagName extends "symbol" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "animate" | "text" | "path" | "image" | "circle" | "switch" | "svg" | keyof HTMLElements | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "textPath" | "tspan" | "use" | "view" ? DOMMotionComponents[TagName] : React$1.ComponentType<MotionComponentProps<React$1.PropsWithChildren<Props>>>;
+    }) => TagName extends "symbol" | "object" | "map" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "a" | "b" | "var" | "style" | "animate" | "progress" | "text" | "ruby" | "table" | "small" | "embed" | "sub" | "path" | "image" | "button" | "meter" | "textarea" | "circle" | "pre" | "caption" | "menu" | "menuitem" | "article" | "dialog" | "figure" | "form" | "img" | "link" | "main" | "option" | "switch" | "time" | "div" | "abbr" | "address" | "area" | "aside" | "audio" | "base" | "bdi" | "bdo" | "blockquote" | "body" | "br" | "canvas" | "cite" | "code" | "col" | "colgroup" | "data" | "datalist" | "dd" | "del" | "details" | "dfn" | "dl" | "dt" | "em" | "fieldset" | "figcaption" | "footer" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "head" | "header" | "hgroup" | "hr" | "html" | "i" | "iframe" | "input" | "ins" | "kbd" | "label" | "legend" | "li" | "mark" | "meta" | "nav" | "noscript" | "ol" | "optgroup" | "output" | "p" | "picture" | "q" | "rp" | "rt" | "s" | "samp" | "script" | "section" | "select" | "source" | "span" | "strong" | "summary" | "sup" | "tbody" | "td" | "tfoot" | "th" | "thead" | "title" | "tr" | "track" | "u" | "ul" | "video" | "wbr" | "big" | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "svg" | "textPath" | "tspan" | "use" | "view" | "keygen" | "param" | "webview" ? DOMMotionComponents[TagName] : React$1.ForwardRefExoticComponent<MotionComponentProps<React$1.PropsWithChildren<Props>>>;
 };
 
-declare const m: (<Props, TagName extends string = "div">(Component: string | TagName | React$1.ComponentType<Props>, { forwardMotionProps }?: {
+declare const m: (<Props, TagName extends string = "div">(Component: string | TagName | React$1.ForwardRefExoticComponent<Props>, { forwardMotionProps }?: {
     forwardMotionProps: boolean;
-}) => TagName extends "symbol" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "animate" | "text" | "path" | "image" | "circle" | "switch" | "svg" | keyof HTMLElements | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "textPath" | "tspan" | "use" | "view" ? DOMMotionComponents[TagName] : React$1.ComponentType<MotionComponentProps<React$1.PropsWithChildren<Props>>>) & HTMLMotionComponents & SVGMotionComponents & {
-    create: <Props, TagName extends string = "div">(Component: string | TagName | React$1.ComponentType<Props>, { forwardMotionProps }?: {
+}) => TagName extends "symbol" | "object" | "map" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "a" | "b" | "var" | "style" | "animate" | "progress" | "text" | "ruby" | "table" | "small" | "embed" | "sub" | "path" | "image" | "button" | "meter" | "textarea" | "circle" | "pre" | "caption" | "menu" | "menuitem" | "article" | "dialog" | "figure" | "form" | "img" | "link" | "main" | "option" | "switch" | "time" | "div" | "abbr" | "address" | "area" | "aside" | "audio" | "base" | "bdi" | "bdo" | "blockquote" | "body" | "br" | "canvas" | "cite" | "code" | "col" | "colgroup" | "data" | "datalist" | "dd" | "del" | "details" | "dfn" | "dl" | "dt" | "em" | "fieldset" | "figcaption" | "footer" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "head" | "header" | "hgroup" | "hr" | "html" | "i" | "iframe" | "input" | "ins" | "kbd" | "label" | "legend" | "li" | "mark" | "meta" | "nav" | "noscript" | "ol" | "optgroup" | "output" | "p" | "picture" | "q" | "rp" | "rt" | "s" | "samp" | "script" | "section" | "select" | "source" | "span" | "strong" | "summary" | "sup" | "tbody" | "td" | "tfoot" | "th" | "thead" | "title" | "tr" | "track" | "u" | "ul" | "video" | "wbr" | "big" | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "svg" | "textPath" | "tspan" | "use" | "view" | "keygen" | "param" | "webview" ? DOMMotionComponents[TagName] : React$1.ForwardRefExoticComponent<MotionComponentProps<React$1.PropsWithChildren<Props>>>) & HTMLMotionComponents & SVGMotionComponents & {
+    create: <Props, TagName extends string = "div">(Component: string | TagName | React$1.ForwardRefExoticComponent<Props>, { forwardMotionProps }?: {
         forwardMotionProps: boolean;
-    }) => TagName extends "symbol" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "animate" | "text" | "path" | "image" | "circle" | "switch" | "svg" | keyof HTMLElements | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "textPath" | "tspan" | "use" | "view" ? DOMMotionComponents[TagName] : React$1.ComponentType<MotionComponentProps<React$1.PropsWithChildren<Props>>>;
+    }) => TagName extends "symbol" | "object" | "map" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "a" | "b" | "var" | "style" | "animate" | "progress" | "text" | "ruby" | "table" | "small" | "embed" | "sub" | "path" | "image" | "button" | "meter" | "textarea" | "circle" | "pre" | "caption" | "menu" | "menuitem" | "article" | "dialog" | "figure" | "form" | "img" | "link" | "main" | "option" | "switch" | "time" | "div" | "abbr" | "address" | "area" | "aside" | "audio" | "base" | "bdi" | "bdo" | "blockquote" | "body" | "br" | "canvas" | "cite" | "code" | "col" | "colgroup" | "data" | "datalist" | "dd" | "del" | "details" | "dfn" | "dl" | "dt" | "em" | "fieldset" | "figcaption" | "footer" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "head" | "header" | "hgroup" | "hr" | "html" | "i" | "iframe" | "input" | "ins" | "kbd" | "label" | "legend" | "li" | "mark" | "meta" | "nav" | "noscript" | "ol" | "optgroup" | "output" | "p" | "picture" | "q" | "rp" | "rt" | "s" | "samp" | "script" | "section" | "select" | "source" | "span" | "strong" | "summary" | "sup" | "tbody" | "td" | "tfoot" | "th" | "thead" | "title" | "tr" | "track" | "u" | "ul" | "video" | "wbr" | "big" | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "svg" | "textPath" | "tspan" | "use" | "view" | "keygen" | "param" | "webview" ? DOMMotionComponents[TagName] : React$1.ForwardRefExoticComponent<MotionComponentProps<React$1.PropsWithChildren<Props>>>;
 };
 
 /**
@@ -3624,6 +3490,11 @@ interface AnimatePresenceProps {
      * @public
      */
     mode?: "sync" | "popLayout" | "wait";
+    /**
+     * Parent DOM element used when injecting styles, used when mode === `"popLayout"`.
+     * This defaults to document.head but can be overridden e.g. for use in shadow DOM.
+     */
+    parentDom?: HTMLElement | ShadowRoot;
     /**
      * Internal. Used in Framer to flag that sibling children *shouldn't* re-render as a result of a
      * child being removed.
@@ -3795,7 +3666,7 @@ interface Props$1<V> {
      *
      * @public
      */
-    as?: keyof HTMLElements;
+    as?: keyof ReactHTML;
     /**
      * The axis to reorder along. By default, items will be draggable on this axis.
      * To make draggable on both axes, set `<Reorder.Item drag />`
@@ -3841,7 +3712,7 @@ interface Props<V> {
      *
      * @public
      */
-    as?: keyof HTMLElements;
+    as?: keyof ReactHTML;
     /**
      * The value in the list that this component represents.
      *
@@ -3946,7 +3817,31 @@ declare const animate: {
     <O extends {}>(object: O | O[], keyframes: ObjectTarget<O>, options?: DynamicAnimationOptions): AnimationPlaybackControls;
 };
 
-declare const animateMini: (elementOrSelector: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions) => AnimationPlaybackControls;
+declare class GroupPlaybackControls implements AnimationPlaybackControls {
+    animations: AnimationPlaybackControls[];
+    constructor(animations: Array<AnimationPlaybackControls | undefined>);
+    then(onResolve: VoidFunction, onReject?: VoidFunction): Promise<void>;
+    /**
+     * TODO: Filter out cancelled or stopped animations before returning
+     */
+    private getAll;
+    private setAll;
+    attachTimeline(timeline: any, fallback: (animation: AnimationPlaybackControls) => VoidFunction): () => void;
+    get time(): number;
+    set time(time: number);
+    get speed(): number;
+    set speed(speed: number);
+    get startTime(): any;
+    get duration(): number;
+    private runAll;
+    play(): void;
+    pause(): void;
+    stop: () => void;
+    cancel(): void;
+    complete(): void;
+}
+
+declare const animateMini: (elementOrSelector: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions) => GroupPlaybackControls;
 
 interface ScrollOptions {
     source?: HTMLElement;
@@ -4003,12 +3898,12 @@ declare global {
         ScrollTimeline: ScrollTimeline;
     }
 }
-declare function scroll(onScroll: OnScroll | AnimationPlaybackControls, { axis, ...options }?: ScrollOptions): VoidFunction;
+declare function scroll(onScroll: OnScroll | GroupPlaybackControls, { axis, ...options }?: ScrollOptions): VoidFunction;
 
 declare function scrollInfo(onScroll: OnScrollInfo, { container, ...options }?: ScrollInfoOptions): () => void;
 
 type ViewChangeHandler = (entry: IntersectionObserverEntry) => void;
-type MarginValue = `${number}${"px" | "%"}`;
+type MarginValue = `${number}${'px' | '%'}`;
 type MarginType = MarginValue | `${MarginValue} ${MarginValue}` | `${MarginValue} ${MarginValue} ${MarginValue}` | `${MarginValue} ${MarginValue} ${MarginValue} ${MarginValue}`;
 interface InViewOptions {
     root?: Element | Document;
@@ -4040,7 +3935,7 @@ declare const mirrorEasing: EasingModifier;
 
 declare const reverseEasing: EasingModifier;
 
-declare function spring(optionsOrVisualDuration?: ValueAnimationOptions<number> | number, bounce?: number): KeyframeGenerator<number>;
+declare function spring({ keyframes, restDelta, restSpeed, ...options }: ValueAnimationOptions<number>): KeyframeGenerator<number>;
 
 declare function inertia({ keyframes, velocity, power, timeConstant, bounceDamping, bounceStiffness, modifyTarget, min, max, restDelta, restSpeed, }: ValueAnimationOptions<number>): KeyframeGenerator<number>;
 
@@ -4158,6 +4053,10 @@ declare function delay(callback: DelayedFunction, timeout: number): () => void;
 declare const distance: (a: number, b: number) => number;
 declare function distance2D(a: Point, b: Point): number;
 
+type DevMessage = (check: boolean, message: string) => void;
+declare let warning: DevMessage;
+declare let invariant: DevMessage;
+
 type Mix<T> = (v: number) => T;
 type MixerFactory<T> = (from: T, to: T) => Mix<T>;
 interface InterpolateOptions<T> {
@@ -4222,19 +4121,6 @@ declare const cancelFrame: (process: Process) => void;
 declare const frameData: FrameData;
 declare const frameSteps: Steps;
 
-/**
- * An eventloop-synchronous alternative to performance.now().
- *
- * Ensures that time measurements remain consistent within a synchronous context.
- * Usually calling performance.now() twice within the same synchronous context
- * will return different values which isn't useful for animations when we're usually
- * trying to sync animations to the same frame.
- */
-declare const time: {
-    now: () => number;
-    set: (newTime: number) => void;
-};
-
 /**
  * @deprecated
  *
@@ -4261,6 +4147,8 @@ declare const createBox: () => Box;
 
 declare function calcLength(axis: Axis): number;
 
+declare function isDragActive(): boolean;
+
 type EventListenerWithPointInfo = (e: PointerEvent, info: EventInfo) => void;
 declare const addPointerInfo: (handler: EventListenerWithPointInfo) => EventListener;
 
@@ -4358,7 +4246,7 @@ type MultiTransformer<I, O> = (input: I[]) => O;
  *
  *
  * The input range must be a linear series of numbers. The output range
- * can be any value type supported by Motion: numbers, colors, shadows, etc.
+ * can be any value type supported by Framer Motion: numbers, colors, shadows, etc.
  *
  * Every value in the output range must be of the same type and in the same format.
  *
@@ -4468,8 +4356,8 @@ declare function useSpring(source: MotionValue<string> | MotionValue<number> | n
 declare function useVelocity(value: MotionValue<number>): MotionValue<number>;
 
 interface UseScrollOptions extends Omit<ScrollInfoOptions, "container" | "target"> {
-    container?: RefObject$1<HTMLElement | null>;
-    target?: RefObject$1<HTMLElement | null>;
+    container?: RefObject$1<HTMLElement>;
+    target?: RefObject$1<HTMLElement>;
     layoutEffect?: boolean;
 }
 declare function useScroll({ container, target, layoutEffect, ...options }?: UseScrollOptions): {
@@ -4482,7 +4370,7 @@ declare function useScroll({ container, target, layoutEffect, ...options }?: Use
 /**
  * @deprecated useElementScroll is deprecated. Convert to useScroll({ container: ref })
  */
-declare function useElementScroll(ref: RefObject$1<HTMLElement | null>): {
+declare function useElementScroll(ref: RefObject$1<HTMLElement>): {
     scrollX: MotionValue<number>;
     scrollY: MotionValue<number>;
     scrollXProgress: MotionValue<number>;
@@ -4549,11 +4437,11 @@ declare function useAnimate<T extends Element = any>(): [AnimationScope<T>, {
     (value: string | MotionValue<string>, keyframes: string | GenericKeyframesTarget<string>, options?: ValueAnimationTransition<string> | undefined): AnimationPlaybackControls;
     (value: number | MotionValue<number>, keyframes: number | GenericKeyframesTarget<number>, options?: ValueAnimationTransition<number> | undefined): AnimationPlaybackControls;
     <V>(value: V | MotionValue<V>, keyframes: V | GenericKeyframesTarget<V>, options?: ValueAnimationTransition<V> | undefined): AnimationPlaybackControls;
-    (element: motion_dom.ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions | undefined): AnimationPlaybackControls;
+    (element: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions | undefined): AnimationPlaybackControls;
     <O extends {}>(object: O | O[], keyframes: ObjectTarget<O>, options?: DynamicAnimationOptions | undefined): AnimationPlaybackControls;
 }];
 
-declare function useAnimateMini<T extends Element = any>(): [AnimationScope<T>, (elementOrSelector: motion_dom.ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions | undefined) => AnimationPlaybackControls];
+declare function useAnimateMini<T extends Element = any>(): [AnimationScope<T>, (elementOrSelector: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions | undefined) => GroupPlaybackControls];
 
 /**
  * Creates `AnimationControls`, which can be used to manually start, stop
@@ -4683,11 +4571,11 @@ declare function usePresence(): AlwaysPresent | Present | NotPresent;
 declare function useIsPresent(): boolean;
 
 interface UseInViewOptions extends Omit<InViewOptions, "root" | "amount"> {
-    root?: RefObject$1<Element | null>;
+    root?: RefObject$1<Element>;
     once?: boolean;
     amount?: "some" | "all" | number;
 }
-declare function useInView(ref: RefObject$1<Element | null>, { root, margin, amount, once }?: UseInViewOptions): boolean;
+declare function useInView(ref: RefObject$1<Element>, { root, margin, amount, once }?: UseInViewOptions): boolean;
 
 /**
  * Attaches an event listener directly to the provided DOM element.
@@ -4710,7 +4598,7 @@ declare function useInView(ref: RefObject$1<Element | null>, { root, margin, amo
  *
  * @public
  */
-declare function useDomEvent(ref: RefObject$1<EventTarget | null>, eventName: string, handler?: EventListener | undefined, options?: AddEventListenerOptions): void;
+declare function useDomEvent(ref: RefObject$1<EventTarget>, eventName: string, handler?: EventListener | undefined, options?: AddEventListenerOptions): void;
 
 /**
  * Checks if a component is a `motion` component.
@@ -4819,7 +4707,6 @@ declare abstract class BaseAnimation<T extends string | number, Resolved> implem
      * reject if its cancels.
      */
     then(resolve: VoidFunction, reject?: VoidFunction): Promise<void>;
-    flatten(): void;
     protected updateFinishedPromise(): void;
 }
 
@@ -4878,7 +4765,6 @@ declare class MainThreadAnimation<T extends string | number> extends BaseAnimati
      */
     startTime: number | null;
     constructor(options: ValueAnimationOptions<T>);
-    flatten(): void;
     protected initPlayback(keyframes: ResolvedKeyframes<T>): {
         generator: KeyframeGenerator<any>;
         mirroredGenerator: KeyframeGenerator<T> | undefined;
@@ -5022,7 +4908,7 @@ declare class AcceleratedAnimation<T extends string | number> extends BaseAnimat
 interface NativeAnimationOptions {
     delay?: number;
     duration?: number;
-    ease?: EasingFunction | Easing | Easing[];
+    ease?: Easing | Easing[];
     times?: number[];
     repeat?: number;
     repeatType?: "loop" | "reverse" | "mirror";
@@ -5045,7 +4931,7 @@ interface WithAppearProps {
 type HandoffFunction = (storeId: string, valueName: string, frame: Batcher) => number | null;
 /**
  * The window global object acts as a bridge between our inline script
- * triggering the optimized appear animations, and Motion.
+ * triggering the optimized appear animations, and Framer Motion.
  */
 declare global {
     interface Window {
@@ -5132,4 +5018,4 @@ declare function useInvertedScale(scale?: Partial<ScaleMotionValues>): ScaleMoti
 
 declare const AnimateSharedLayout: React$1.FunctionComponent<React$1.PropsWithChildren<unknown>>;
 
-export { type AbsoluteKeyframe, AcceleratedAnimation, AnimatePresence, type AnimatePresenceProps, AnimateSharedLayout, type AnimationControls, type AnimationDefinition, type AnimationGeneratorType, type AnimationLifecycles, type AnimationOptionsWithValueOverrides, type AnimationPlaybackControls, type AnimationPlaybackLifecycles, type AnimationPlaybackOptions, type AnimationProps, type AnimationSequence, type AnimationType, type At, type Axis, type AxisDelta, type BezierDefinition, type BoundingBox, type Box, type CSSStyleDeclarationWithTransform, type CreateVisualElement, type CustomValueType, type Cycle, type CycleState, type DOMKeyframesDefinition, type DOMMotionComponents, type DOMSegment, type DOMSegmentWithTransition, type DecayOptions, type DelayedFunction, type Delta, DeprecatedLayoutGroupContext, type Direction, DragControls, type DragElastic, type DragHandlers, type DraggableProps, type DurationSpringOptions, type DynamicAnimationOptions, type DynamicOption, type Easing, type EasingDefinition, type EasingFunction, type EasingModifier, type EventInfo, type FeatureBundle, type FeatureDefinition, type FeatureDefinitions, type FeaturePackage, type FeaturePackages, FlatTree, type FocusHandlers, type ForwardRefComponent, type GeneratorFactory, type HTMLMotionProps, type HoverHandlers, type HydratedFeatureDefinition, type HydratedFeatureDefinitions, type IProjectionNode, type Inertia, type InertiaOptions$1 as InertiaOptions, type InterpolateOptions, type KeyframeOptions, type Keyframes, type KeyframesTarget, LayoutGroup, LayoutGroupContext, type LayoutProps, type LazyFeatureBundle$1 as LazyFeatureBundle, LazyMotion, type LazyProps, type MixerFactory, type MotionAdvancedProps, MotionConfig, MotionConfigContext, type MotionConfigProps, MotionContext, MotionGlobalConfig, type MotionProps, type MotionStyle, type MotionTransform, MotionValue, type MotionValueSegment, type MotionValueSegmentWithTransition, type None, type ObjectSegment, type ObjectSegmentWithTransition, type ObjectTarget, type Orchestration, type PanHandlers, type PanInfo, type PassiveEffect, type Point, PresenceContext, type RenderComponent, namespace_d as Reorder, type Repeat, type RepeatType, type ResolveKeyframes, type ResolvedAnimationDefinition, type ResolvedAnimationDefinitions, type ResolvedKeyframesTarget, type ResolvedSingleTarget, type ResolvedValueTarget, type ResolvedValues, type SVGAttributesAsMotionValues, type SVGKeyframesDefinition, type SVGMotionProps, type SVGPathKeyframesDefinition, type SVGPathTransitions, type SVGTransitions, type ScrapeMotionValuesFromProps, type ScrollMotionValues, type Segment, type SequenceLabel, type SequenceLabelWithTime, type SequenceMap, type SequenceOptions, type SequenceTime, type SingleTarget, type Spring, type SpringOptions, type StyleKeyframesDefinition, type StyleTransitions, type Subscriber, SwitchLayoutGroupContext, type TapHandlers, type TapInfo, type Target, type TargetAndTransition, type TransformPoint, type Transition$1 as Transition, type Tween, type UnresolvedValueKeyframe, type UseInViewOptions, type UseScrollOptions, type ValueAnimationOptions, type ValueAnimationOptionsWithRenderContext, type ValueAnimationTransition, type ValueKeyframe, type ValueKeyframesDefinition, type ValueSequence, type ValueTarget, type ValueType, type VariableKeyframesDefinition, type VariableTransitions, type Variant, type VariantLabels, type Variants, type VelocityOptions, VisualElement, type VisualState, addPointerEvent, addPointerInfo, addScaleCorrector, animate, animateMini, animateValue, animateVisualElement, animationControls, animations, anticipate, backIn, backInOut, backOut, buildTransform, calcLength, cancelFrame, cancelSync, circIn, circInOut, circOut, clamp, color, complex, createBox, createRendererMotionComponent, createScopedAnimate, cubicBezier, delay, disableInstantTransitions, distance, distance2D, domAnimation, domMax, domMin, easeIn, easeInOut, easeOut, filterProps, findSpring, frame, frameData, frameSteps, inView, inertia, interpolate, isBrowser, isMotionComponent, isMotionValue, isValidMotionProp, keyframes, m, makeUseVisualState, mirrorEasing, mix, motion, motionValue, optimizedAppearDataAttribute, pipe, progress, px, resolveMotionValue, reverseEasing, scroll, scrollInfo, spring, stagger, startOptimizedAppearAnimation, steps, sync, time, transform, unwrapMotionComponent, useAnimate, useAnimateMini, useAnimation, useAnimationControls, useAnimationFrame, useCycle, useAnimatedState as useDeprecatedAnimatedState, useInvertedScale as useDeprecatedInvertedScale, useDomEvent, useDragControls, useElementScroll, useForceUpdate, useInView, useInstantLayoutTransition, useInstantTransition, useIsPresent, useIsomorphicLayoutEffect, useMotionTemplate, useMotionValue, useMotionValueEvent, usePresence, useReducedMotion, useReducedMotionConfig, useResetProjection, useScroll, useSpring, useTime, useTransform, useUnmountEffect, useVelocity, useViewportScroll, useWillChange, visualElementStore, wrap };
+export { type AbsoluteKeyframe, AcceleratedAnimation, AnimatePresence, type AnimatePresenceProps, AnimateSharedLayout, type AnimationControls, type AnimationDefinition, type AnimationGeneratorType, type AnimationLifecycles, type AnimationOptionsWithValueOverrides, type AnimationPlaybackControls, type AnimationPlaybackLifecycles, type AnimationPlaybackOptions, type AnimationProps, type AnimationScope, type AnimationSequence, type AnimationType, type At, type Axis, type AxisDelta, type BezierDefinition, type BoundingBox, type Box, type CSSStyleDeclarationWithTransform, type CreateVisualElement, type CustomValueType, type Cycle, type CycleState, type DOMKeyframesDefinition, type DOMMotionComponents, type DOMSegment, type DOMSegmentWithTransition, type DecayOptions, type DelayedFunction, type Delta, DeprecatedLayoutGroupContext, type DevMessage, type Direction, DragControls, type DragElastic, type DragHandlers, type DraggableProps, type DurationSpringOptions, type DynamicAnimationOptions, type DynamicOption, type Easing, type EasingDefinition, type EasingFunction, type EasingModifier, type ElementOrSelector, type EventInfo, type FeatureBundle, type FeatureDefinition, type FeatureDefinitions, type FeaturePackage, type FeaturePackages, FlatTree, type FocusHandlers, type ForwardRefComponent, type GeneratorFactory, type HTMLMotionProps, type HoverHandlers, type HydratedFeatureDefinition, type HydratedFeatureDefinitions, type IProjectionNode, type Inertia, type InertiaOptions$1 as InertiaOptions, type InterpolateOptions, type KeyframeOptions, type Keyframes, type KeyframesTarget, LayoutGroup, LayoutGroupContext, type LayoutProps, type LazyFeatureBundle$1 as LazyFeatureBundle, LazyMotion, type LazyProps, type MixerFactory, type MotionAdvancedProps, MotionConfig, MotionConfigContext, type MotionConfigProps, MotionContext, MotionGlobalConfig, type MotionProps, type MotionStyle, type MotionTransform, MotionValue, type MotionValueSegment, type MotionValueSegmentWithTransition, type None, type ObjectSegment, type ObjectSegmentWithTransition, type ObjectTarget, type Orchestration, type PanHandlers, type PanInfo, type PassiveEffect, type Point, PresenceContext, type RenderComponent, namespace_d as Reorder, type Repeat, type RepeatType, type ResolveKeyframes, type ResolvedAnimationDefinition, type ResolvedAnimationDefinitions, type ResolvedKeyframesTarget, type ResolvedSingleTarget, type ResolvedValueTarget, type ResolvedValues, type SVGAttributesAsMotionValues, type SVGKeyframesDefinition, type SVGMotionProps, type SVGPathKeyframesDefinition, type SVGPathTransitions, type SVGTransitions, type ScrapeMotionValuesFromProps, type ScrollMotionValues, type Segment, type SequenceLabel, type SequenceLabelWithTime, type SequenceMap, type SequenceOptions, type SequenceTime, type SingleTarget, type Spring, type SpringOptions, type StyleKeyframesDefinition, type StyleTransitions, type Subscriber, SwitchLayoutGroupContext, type TapHandlers, type TapInfo, type Target, type TargetAndTransition, type TransformPoint, type Transition$1 as Transition, type Tween, type UnresolvedValueKeyframe, type UseInViewOptions, type UseScrollOptions, type ValueAnimationOptions, type ValueAnimationOptionsWithRenderContext, type ValueAnimationTransition, type ValueKeyframe, type ValueKeyframesDefinition, type ValueSequence, type ValueTarget, type ValueType, type VariableKeyframesDefinition, type VariableTransitions, type Variant, type VariantLabels, type Variants, type VelocityOptions, VisualElement, type VisualState, addPointerEvent, addPointerInfo, addScaleCorrector, animate, animateMini, animateValue, animateVisualElement, animationControls, animations, anticipate, backIn, backInOut, backOut, buildTransform, calcLength, cancelFrame, cancelSync, circIn, circInOut, circOut, clamp, color, complex, createBox, createRendererMotionComponent, createScopedAnimate, cubicBezier, delay, disableInstantTransitions, distance, distance2D, domAnimation, domMax, domMin, easeIn, easeInOut, easeOut, filterProps, findSpring, frame, frameData, frameSteps, inView, inertia, interpolate, invariant, isBrowser, isDragActive, isMotionComponent, isMotionValue, isValidMotionProp, keyframes, m, makeUseVisualState, mirrorEasing, mix, motion, motionValue, optimizedAppearDataAttribute, pipe, progress, px, resolveMotionValue, reverseEasing, scroll, scrollInfo, spring, stagger, startOptimizedAppearAnimation, steps, sync, transform, unwrapMotionComponent, useAnimate, useAnimateMini, useAnimation, useAnimationControls, useAnimationFrame, useCycle, useAnimatedState as useDeprecatedAnimatedState, useInvertedScale as useDeprecatedInvertedScale, useDomEvent, useDragControls, useElementScroll, useForceUpdate, useInView, useInstantLayoutTransition, useInstantTransition, useIsPresent, useIsomorphicLayoutEffect, useMotionTemplate, useMotionValue, useMotionValueEvent, usePresence, useReducedMotion, useReducedMotionConfig, useResetProjection, useScroll, useSpring, useTime, useTransform, useUnmountEffect, useVelocity, useViewportScroll, useWillChange, visualElementStore, warning, wrap };
diff --git a/dist/m.d.ts b/dist/m.d.ts
index f74f6f91a2c3d54861e76f26dfd189562cd30b96..794fe49a290f9a93f3f91470791e5e51cfee33b9 100644
--- a/dist/m.d.ts
+++ b/dist/m.d.ts
@@ -1,6 +1,6 @@
 /// <reference types="react" />
 import * as React$1 from 'react';
-import { SVGAttributes, CSSProperties, PropsWithoutRef, RefAttributes, JSX } from 'react';
+import { SVGAttributes, CSSProperties, PropsWithoutRef, RefAttributes, ReactHTML, DetailedHTMLFactory, HTMLAttributes } from 'react';
 
 type EasingFunction = (v: number) => number;
 type BezierDefinition = readonly [number, number, number, number];
@@ -426,25 +426,6 @@ interface Spring extends Repeat {
      * @public
      */
     duration?: number;
-    /**
-     * If visualDuration is set, this will override duration.
-     *
-     * The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.
-     *
-     * In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.
-     *
-     * This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.
-     *
-     * ```jsx
-     * <motion.div
-     *   animate={{ x: 100 }}
-     *   transition={{ type: "spring", visualDuration: 0.5 }}
-     * />
-     * ```
-     *
-     * @public
-     */
-    visualDuration?: number;
     /**
      * `bounce` determines the "bounciness" of a spring animation.
      *
@@ -982,7 +963,6 @@ interface AnimationState<V> {
 interface KeyframeGenerator<V> {
     calculatedDuration: null | number;
     next: (t: number) => AnimationState<V>;
-    toString: () => string;
 }
 
 interface AnimationPlaybackLifecycles<V> {
@@ -1027,7 +1007,6 @@ interface AnimationPlaybackControls {
     cancel: () => void;
     then: (onResolve: VoidFunction, onReject?: VoidFunction) => Promise<void>;
     attachTimeline?: (timeline: ProgressTimeline, fallback?: (animation: AnimationPlaybackControls) => VoidFunction) => VoidFunction;
-    flatten: () => void;
 }
 type ValueKeyframe = string | number;
 type UnresolvedValueKeyframe = ValueKeyframe | null;
@@ -1048,7 +1027,6 @@ interface AnimationPlaybackOptions {
 }
 interface DurationSpringOptions {
     duration?: number;
-    visualDuration?: number;
     bounce?: number;
 }
 interface SpringOptions extends DurationSpringOptions, VelocityOptions {
@@ -1163,7 +1141,7 @@ declare class MotionValue<V = any> {
      */
     version: string;
     /**
-     * If a MotionValue has an owner, it was created internally within Motion
+     * If a MotionValue has an owner, it was created internally within Framer Motion
      * and therefore has no external listeners. It is therefore safe to animate via WAAPI.
      */
     owner?: Owner;
@@ -1182,11 +1160,11 @@ declare class MotionValue<V = any> {
     /**
      * The last time the `MotionValue` was updated.
      */
-    updatedAt: number;
+    private updatedAt;
     /**
      * The time `prevFrameValue` was updated.
      */
-    prevUpdatedAt: number | undefined;
+    private prevUpdatedAt;
     private stopPassiveEffect?;
     /**
      * A reference to the currently-controlling animation.
@@ -1584,7 +1562,7 @@ interface DraggableProps extends DragHandlers {
      * }
      * ```
      */
-    dragConstraints?: false | Partial<BoundingBox> | RefObject<Element | null>;
+    dragConstraints?: false | Partial<BoundingBox> | RefObject<Element>;
     /**
      * The degree of movement allowed outside constraints. 0 = no movement, 1 =
      * full movement.
@@ -2034,7 +2012,7 @@ interface HoverHandlers {
 
 type ViewportEventHandler = (entry: IntersectionObserverEntry | null) => void;
 interface ViewportOptions {
-    root?: RefObject<Element | null>;
+    root?: RefObject<Element>;
     once?: boolean;
     margin?: string;
     amount?: "some" | "all" | number;
@@ -2268,7 +2246,7 @@ interface MotionProps extends AnimationProps, EventProps, PanHandlers, TapHandle
      */
     style?: MotionStyle$1;
     /**
-     * By default, Motion generates a `transform` property with a sensible transform order. `transformTemplate`
+     * By default, Framer Motion generates a `transform` property with a sensible transform order. `transformTemplate`
      * can be used to create a different order, or to append/preprend the automatically generated `transform` property.
      *
      * ```jsx
@@ -2281,7 +2259,7 @@ interface MotionProps extends AnimationProps, EventProps, PanHandlers, TapHandle
      * ```
      *
      * @param transform - The latest animated transform props.
-     * @param generatedTransform - The transform string as automatically generated by Motion
+     * @param generatedTransform - The transform string as automatically generated by Framer Motion
      *
      * @public
      */
@@ -2294,131 +2272,13 @@ type MotionComponentProps<Props> = {
     [K in Exclude<keyof Props, keyof MotionProps>]?: Props[K];
 } & MotionProps;
 
-type UnionStringArray<T extends Readonly<string[]>> = T[number];
+type UnionStringArray$1<T extends Readonly<string[]>> = T[number];
 declare const svgElements: readonly ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "svg", "switch", "symbol", "text", "tspan", "use", "view", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "linearGradient", "radialGradient", "textPath"];
-type SVGElements = UnionStringArray<typeof svgElements>;
+type SVGElements = UnionStringArray$1<typeof svgElements>;
 
-interface HTMLElements {
-    a: HTMLAnchorElement;
-    abbr: HTMLElement;
-    address: HTMLElement;
-    area: HTMLAreaElement;
-    article: HTMLElement;
-    aside: HTMLElement;
-    audio: HTMLAudioElement;
-    b: HTMLElement;
-    base: HTMLBaseElement;
-    bdi: HTMLElement;
-    bdo: HTMLElement;
-    big: HTMLElement;
-    blockquote: HTMLQuoteElement;
-    body: HTMLBodyElement;
-    br: HTMLBRElement;
-    button: HTMLButtonElement;
-    canvas: HTMLCanvasElement;
-    caption: HTMLElement;
-    center: HTMLElement;
-    cite: HTMLElement;
-    code: HTMLElement;
-    col: HTMLTableColElement;
-    colgroup: HTMLTableColElement;
-    data: HTMLDataElement;
-    datalist: HTMLDataListElement;
-    dd: HTMLElement;
-    del: HTMLModElement;
-    details: HTMLDetailsElement;
-    dfn: HTMLElement;
-    dialog: HTMLDialogElement;
-    div: HTMLDivElement;
-    dl: HTMLDListElement;
-    dt: HTMLElement;
-    em: HTMLElement;
-    embed: HTMLEmbedElement;
-    fieldset: HTMLFieldSetElement;
-    figcaption: HTMLElement;
-    figure: HTMLElement;
-    footer: HTMLElement;
-    form: HTMLFormElement;
-    h1: HTMLHeadingElement;
-    h2: HTMLHeadingElement;
-    h3: HTMLHeadingElement;
-    h4: HTMLHeadingElement;
-    h5: HTMLHeadingElement;
-    h6: HTMLHeadingElement;
-    head: HTMLHeadElement;
-    header: HTMLElement;
-    hgroup: HTMLElement;
-    hr: HTMLHRElement;
-    html: HTMLHtmlElement;
-    i: HTMLElement;
-    iframe: HTMLIFrameElement;
-    img: HTMLImageElement;
-    input: HTMLInputElement;
-    ins: HTMLModElement;
-    kbd: HTMLElement;
-    keygen: HTMLElement;
-    label: HTMLLabelElement;
-    legend: HTMLLegendElement;
-    li: HTMLLIElement;
-    link: HTMLLinkElement;
-    main: HTMLElement;
-    map: HTMLMapElement;
-    mark: HTMLElement;
-    menu: HTMLElement;
-    menuitem: HTMLElement;
-    meta: HTMLMetaElement;
-    meter: HTMLMeterElement;
-    nav: HTMLElement;
-    noindex: HTMLElement;
-    noscript: HTMLElement;
-    object: HTMLObjectElement;
-    ol: HTMLOListElement;
-    optgroup: HTMLOptGroupElement;
-    option: HTMLOptionElement;
-    output: HTMLOutputElement;
-    p: HTMLParagraphElement;
-    param: HTMLParamElement;
-    picture: HTMLElement;
-    pre: HTMLPreElement;
-    progress: HTMLProgressElement;
-    q: HTMLQuoteElement;
-    rp: HTMLElement;
-    rt: HTMLElement;
-    ruby: HTMLElement;
-    s: HTMLElement;
-    samp: HTMLElement;
-    search: HTMLElement;
-    slot: HTMLSlotElement;
-    script: HTMLScriptElement;
-    section: HTMLElement;
-    select: HTMLSelectElement;
-    small: HTMLElement;
-    source: HTMLSourceElement;
-    span: HTMLSpanElement;
-    strong: HTMLElement;
-    style: HTMLStyleElement;
-    sub: HTMLElement;
-    summary: HTMLElement;
-    sup: HTMLElement;
-    table: HTMLTableElement;
-    template: HTMLTemplateElement;
-    tbody: HTMLTableSectionElement;
-    td: HTMLTableDataCellElement;
-    textarea: HTMLTextAreaElement;
-    tfoot: HTMLTableSectionElement;
-    th: HTMLTableHeaderCellElement;
-    thead: HTMLTableSectionElement;
-    time: HTMLTimeElement;
-    title: HTMLTitleElement;
-    tr: HTMLTableRowElement;
-    track: HTMLTrackElement;
-    u: HTMLElement;
-    ul: HTMLUListElement;
-    var: HTMLElement;
-    video: HTMLVideoElement;
-    wbr: HTMLElement;
-    webview: HTMLWebViewElement;
-}
+type UnionStringArray<T extends Readonly<string[]>> = T[number];
+declare const htmlElements: readonly ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "webview"];
+type HTMLElements = UnionStringArray<typeof htmlElements>;
 
 /**
  * @public
@@ -2426,20 +2286,25 @@ interface HTMLElements {
 type ForwardRefComponent<T, P> = {
     readonly $$typeof: symbol;
 } & ((props: PropsWithoutRef<P> & RefAttributes<T>) => JSX.Element);
-type AttributesWithoutMotionProps<Attributes> = {
+/**
+ * Support for React component props
+ */
+type UnwrapFactoryAttributes<F> = F extends DetailedHTMLFactory<infer P, any> ? P : never;
+type UnwrapFactoryElement<F> = F extends DetailedHTMLFactory<any, infer P> ? P : never;
+type HTMLAttributesWithoutMotionProps<Attributes extends HTMLAttributes<Element>, Element extends HTMLElement> = {
     [K in Exclude<keyof Attributes, keyof MotionProps>]?: Attributes[K];
 };
 /**
  * @public
  */
-type HTMLMotionProps<Tag extends keyof HTMLElements> = AttributesWithoutMotionProps<JSX.IntrinsicElements[Tag]> & MotionProps;
+type HTMLMotionProps<TagName extends keyof ReactHTML> = HTMLAttributesWithoutMotionProps<UnwrapFactoryAttributes<ReactHTML[TagName]>, UnwrapFactoryElement<ReactHTML[TagName]>> & MotionProps;
 /**
  * Motion-optimised versions of React's HTML components.
  *
  * @public
  */
 type HTMLMotionComponents = {
-    [K in keyof HTMLElements]: ForwardRefComponent<HTMLElements[K], HTMLMotionProps<K>>;
+    [K in HTMLElements]: ForwardRefComponent<UnwrapFactoryElement<ReactHTML[K]>, HTMLMotionProps<K>>;
 };
 
 interface SVGAttributesWithoutMotionProps<T> extends Pick<SVGAttributes<T>, Exclude<keyof SVGAttributes<T>, keyof MotionProps>> {
@@ -2522,7 +2387,7 @@ interface WithAppearProps {
 type HandoffFunction = (storeId: string, valueName: string, frame: Batcher) => number | null;
 /**
  * The window global object acts as a bridge between our inline script
- * triggering the optimized appear animations, and Motion.
+ * triggering the optimized appear animations, and Framer Motion.
  */
 declare global {
     interface Window {
@@ -2538,9 +2403,9 @@ declare global {
 
 type DOMMotionComponents = HTMLMotionComponents & SVGMotionComponents;
 
-declare const createMinimalMotionComponent: <Props, TagName extends string = "div">(Component: string | TagName | React$1.ComponentType<Props>, { forwardMotionProps }?: {
+declare const createMinimalMotionComponent: <Props, TagName extends string = "div">(Component: string | TagName | React$1.ForwardRefExoticComponent<Props>, { forwardMotionProps }?: {
     forwardMotionProps: boolean;
-}) => TagName extends "symbol" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "animate" | "text" | "path" | "image" | "circle" | "switch" | "svg" | keyof HTMLElements | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "textPath" | "tspan" | "use" | "view" ? DOMMotionComponents[TagName] : React$1.ComponentType<MotionComponentProps<React$1.PropsWithChildren<Props>>>;
+}) => TagName extends "symbol" | "object" | "map" | "filter" | "stop" | "clipPath" | "mask" | "marker" | "a" | "b" | "var" | "style" | "animate" | "progress" | "text" | "ruby" | "table" | "small" | "embed" | "sub" | "path" | "image" | "button" | "meter" | "textarea" | "circle" | "pre" | "caption" | "menu" | "menuitem" | "article" | "dialog" | "figure" | "form" | "img" | "link" | "main" | "option" | "switch" | "time" | "div" | "abbr" | "address" | "area" | "aside" | "audio" | "base" | "bdi" | "bdo" | "blockquote" | "body" | "br" | "canvas" | "cite" | "code" | "col" | "colgroup" | "data" | "datalist" | "dd" | "del" | "details" | "dfn" | "dl" | "dt" | "em" | "fieldset" | "figcaption" | "footer" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "head" | "header" | "hgroup" | "hr" | "html" | "i" | "iframe" | "input" | "ins" | "kbd" | "label" | "legend" | "li" | "mark" | "meta" | "nav" | "noscript" | "ol" | "optgroup" | "output" | "p" | "picture" | "q" | "rp" | "rt" | "s" | "samp" | "script" | "section" | "select" | "source" | "span" | "strong" | "summary" | "sup" | "tbody" | "td" | "tfoot" | "th" | "thead" | "title" | "tr" | "track" | "u" | "ul" | "video" | "wbr" | "big" | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feDropShadow" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "foreignObject" | "g" | "line" | "linearGradient" | "metadata" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "svg" | "textPath" | "tspan" | "use" | "view" | "keygen" | "param" | "webview" ? DOMMotionComponents[TagName] : React$1.ForwardRefExoticComponent<MotionComponentProps<React$1.PropsWithChildren<Props>>>;
 
 /**
  * HTML components
diff --git a/dist/mini.d.ts b/dist/mini.d.ts
index bdd682f46798e0c556f015aef810204e4adfb70e..25007b42a5e18619d7d23fbcd06d28ccdbefa52e 100644
--- a/dist/mini.d.ts
+++ b/dist/mini.d.ts
@@ -1,6 +1,3 @@
-import * as motion_dom from 'motion-dom';
-import { AnimationScope } from 'motion-dom';
-
 type EasingFunction = (v: number) => number;
 type BezierDefinition = readonly [number, number, number, number];
 type EasingDefinition = BezierDefinition | "linear" | "easeIn" | "easeOut" | "easeInOut" | "circIn" | "circOut" | "circInOut" | "backIn" | "backOut" | "backInOut" | "anticipate";
@@ -15,6 +12,15 @@ type EasingDefinition = BezierDefinition | "linear" | "easeIn" | "easeOut" | "ea
  */
 type Easing = EasingDefinition | EasingFunction;
 
+/**
+ * @public
+ */
+interface SVGPathProperties {
+    pathLength?: number;
+    pathOffset?: number;
+    pathSpacing?: number;
+}
+
 /**
  * An update function. It accepts a timestamp used to advance the animation.
  */
@@ -289,7 +295,6 @@ interface AnimationState<V> {
 interface KeyframeGenerator<V> {
     calculatedDuration: null | number;
     next: (t: number) => AnimationState<V>;
-    toString: () => string;
 }
 
 interface AnimationPlaybackLifecycles<V> {
@@ -318,6 +323,10 @@ interface ValueAnimationOptions<V extends string | number = number> extends Valu
     from?: V;
     isGenerator?: boolean;
 }
+interface AnimationScope<T = any> {
+    readonly current: T;
+    animations: AnimationPlaybackControls[];
+}
 type StyleTransitions = {
     [K in keyof CSSStyleDeclarationWithTransform]?: Transition;
 };
@@ -334,6 +343,7 @@ type AnimationOptionsWithValueOverrides<V = any> = StyleTransitions & SVGPathTra
 interface DynamicAnimationOptions extends Omit<AnimationOptionsWithValueOverrides, "delay"> {
     delay?: number | DynamicOption<number>;
 }
+type ElementOrSelector = Element | Element[] | NodeListOf<Element> | string;
 /**
  * @public
  */
@@ -350,7 +360,6 @@ interface AnimationPlaybackControls {
     cancel: () => void;
     then: (onResolve: VoidFunction, onReject?: VoidFunction) => Promise<void>;
     attachTimeline?: (timeline: ProgressTimeline, fallback?: (animation: AnimationPlaybackControls) => VoidFunction) => VoidFunction;
-    flatten: () => void;
 }
 type DynamicOption<T> = (i: number, total: number) => T;
 interface CSSStyleDeclarationWithTransform extends Omit<CSSStyleDeclaration, "direction" | "transition" | "x" | "y" | "z"> {
@@ -395,7 +404,6 @@ interface AnimationPlaybackOptions {
 }
 interface DurationSpringOptions {
     duration?: number;
-    visualDuration?: number;
     bounce?: number;
 }
 interface SpringOptions extends DurationSpringOptions, VelocityOptions {
@@ -420,266 +428,30 @@ interface KeyframeOptions {
     times?: number[];
 }
 
-/**
- * @public
- */
-type Subscriber<T> = (v: T) => void;
-interface MotionValueEventCallbacks<V> {
-    animationStart: () => void;
-    animationComplete: () => void;
-    animationCancel: () => void;
-    change: (latestValue: V) => void;
-    renderRequest: () => void;
-}
-interface ResolvedValues {
-    [key: string]: string | number;
-}
-interface Owner {
-    current: HTMLElement | unknown;
-    getProps: () => {
-        onUpdate?: (latest: ResolvedValues) => void;
-    };
-}
-/**
- * `MotionValue` is used to track the state and velocity of motion values.
- *
- * @public
- */
-declare class MotionValue<V = any> {
-    /**
-     * This will be replaced by the build step with the latest version number.
-     * When MotionValues are provided to motion components, warn if versions are mixed.
-     */
-    version: string;
-    /**
-     * If a MotionValue has an owner, it was created internally within Motion
-     * and therefore has no external listeners. It is therefore safe to animate via WAAPI.
-     */
-    owner?: Owner;
-    /**
-     * The current state of the `MotionValue`.
-     */
-    private current;
-    /**
-     * The previous state of the `MotionValue`.
-     */
-    private prev;
-    /**
-     * The previous state of the `MotionValue` at the end of the previous frame.
-     */
-    private prevFrameValue;
-    /**
-     * The last time the `MotionValue` was updated.
-     */
-    updatedAt: number;
-    /**
-     * The time `prevFrameValue` was updated.
-     */
-    prevUpdatedAt: number | undefined;
-    private stopPassiveEffect?;
-    /**
-     * A reference to the currently-controlling animation.
-     */
-    animation?: AnimationPlaybackControls;
-    setCurrent(current: V): void;
-    setPrevFrameValue(prevFrameValue?: V | undefined): void;
-    /**
-     * Adds a function that will be notified when the `MotionValue` is updated.
-     *
-     * It returns a function that, when called, will cancel the subscription.
-     *
-     * When calling `onChange` inside a React component, it should be wrapped with the
-     * `useEffect` hook. As it returns an unsubscribe function, this should be returned
-     * from the `useEffect` function to ensure you don't add duplicate subscribers..
-     *
-     * ```jsx
-     * export const MyComponent = () => {
-     *   const x = useMotionValue(0)
-     *   const y = useMotionValue(0)
-     *   const opacity = useMotionValue(1)
-     *
-     *   useEffect(() => {
-     *     function updateOpacity() {
-     *       const maxXY = Math.max(x.get(), y.get())
-     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
-     *       opacity.set(newOpacity)
-     *     }
-     *
-     *     const unsubscribeX = x.on("change", updateOpacity)
-     *     const unsubscribeY = y.on("change", updateOpacity)
-     *
-     *     return () => {
-     *       unsubscribeX()
-     *       unsubscribeY()
-     *     }
-     *   }, [])
-     *
-     *   return <motion.div style={{ x }} />
-     * }
-     * ```
-     *
-     * @param subscriber - A function that receives the latest value.
-     * @returns A function that, when called, will cancel this subscription.
-     *
-     * @deprecated
-     */
-    onChange(subscription: Subscriber<V>): () => void;
-    /**
-     * An object containing a SubscriptionManager for each active event.
-     */
-    private events;
-    on<EventName extends keyof MotionValueEventCallbacks<V>>(eventName: EventName, callback: MotionValueEventCallbacks<V>[EventName]): VoidFunction;
-    clearListeners(): void;
-    /**
-     * Sets the state of the `MotionValue`.
-     *
-     * @remarks
-     *
-     * ```jsx
-     * const x = useMotionValue(0)
-     * x.set(10)
-     * ```
-     *
-     * @param latest - Latest value to set.
-     * @param render - Whether to notify render subscribers. Defaults to `true`
-     *
-     * @public
-     */
-    set(v: V, render?: boolean): void;
-    setWithVelocity(prev: V, current: V, delta: number): void;
+declare class GroupPlaybackControls implements AnimationPlaybackControls {
+    animations: AnimationPlaybackControls[];
+    constructor(animations: Array<AnimationPlaybackControls | undefined>);
+    then(onResolve: VoidFunction, onReject?: VoidFunction): Promise<void>;
     /**
-     * Set the state of the `MotionValue`, stopping any active animations,
-     * effects, and resets velocity to `0`.
+     * TODO: Filter out cancelled or stopped animations before returning
      */
-    jump(v: V, endAnimation?: boolean): void;
-    updateAndNotify: (v: V, render?: boolean) => void;
-    /**
-     * Returns the latest state of `MotionValue`
-     *
-     * @returns - The latest state of `MotionValue`
-     *
-     * @public
-     */
-    get(): NonNullable<V>;
-    /**
-     * @public
-     */
-    getPrevious(): V | undefined;
-    /**
-     * Returns the latest velocity of `MotionValue`
-     *
-     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
-     *
-     * @public
-     */
-    getVelocity(): number;
-    hasAnimated: boolean;
-    /**
-     * Stop the currently active animation.
-     *
-     * @public
-     */
-    stop(): void;
-    /**
-     * Returns `true` if this value is currently animating.
-     *
-     * @public
-     */
-    isAnimating(): boolean;
-    private clearAnimation;
-    /**
-     * Destroy and clean up subscribers to this `MotionValue`.
-     *
-     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
-     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
-     * created a `MotionValue` via the `motionValue` function.
-     *
-     * @public
-     */
-    destroy(): void;
-}
-
-/**
- * @public
- */
-interface SVGPathProperties {
-    pathLength?: number;
-    pathOffset?: number;
-    pathSpacing?: number;
-}
-
-interface ScrollOptions {
-    source?: HTMLElement;
-    container?: HTMLElement;
-    target?: Element;
-    axis?: "x" | "y";
-    offset?: ScrollOffset;
-}
-type SupportedEdgeUnit = "px" | "vw" | "vh" | "%";
-type EdgeUnit = `${number}${SupportedEdgeUnit}`;
-type NamedEdges = "start" | "end" | "center";
-type EdgeString = NamedEdges | EdgeUnit | `${number}`;
-type Edge = EdgeString | number;
-type ProgressIntersection = [number, number];
-type Intersection = `${Edge} ${Edge}`;
-type ScrollOffset = Array<Edge | Intersection | ProgressIntersection>;
-
-declare class ScrollTimeline implements ProgressTimeline {
-    constructor(options: ScrollOptions);
-    currentTime: null | {
-        value: number;
-    };
-    cancel?: VoidFunction;
-}
-declare global {
-    interface Window {
-        ScrollTimeline: ScrollTimeline;
-    }
-}
-
-type Process = (data: FrameData) => void;
-type Schedule = (process: Process, keepAlive?: boolean, immediate?: boolean) => Process;
-type StepId = "read" | "resolveKeyframes" | "update" | "preRender" | "render" | "postRender";
-type Batcher = {
-    [key in StepId]: Schedule;
-};
-interface FrameData {
-    delta: number;
-    timestamp: number;
-    isProcessing: boolean;
-}
-
-declare const optimizedAppearDataAttribute: "data-framer-appear-id";
-
-/**
- * Expose only the needed part of the VisualElement interface to
- * ensure React types don't end up in the generic DOM bundle.
- */
-interface WithAppearProps {
-    props: {
-        [optimizedAppearDataAttribute]?: string;
-        values?: {
-            [key: string]: MotionValue<number> | MotionValue<string>;
-        };
-    };
-}
-type HandoffFunction = (storeId: string, valueName: string, frame: Batcher) => number | null;
-/**
- * The window global object acts as a bridge between our inline script
- * triggering the optimized appear animations, and Motion.
- */
-declare global {
-    interface Window {
-        MotionHandoffAnimation?: HandoffFunction;
-        MotionHandoffMarkAsComplete?: (elementId: string) => void;
-        MotionHandoffIsComplete?: (elementId: string) => boolean;
-        MotionHasOptimisedAnimation?: (elementId?: string, valueName?: string) => boolean;
-        MotionCancelOptimisedAnimation?: (elementId?: string, valueName?: string, frame?: Batcher, canResume?: boolean) => void;
-        MotionCheckAppearSync?: (visualElement: WithAppearProps, valueName: string, value: MotionValue) => VoidFunction | void;
-        MotionIsMounted?: boolean;
-    }
+    private getAll;
+    private setAll;
+    attachTimeline(timeline: any, fallback: (animation: AnimationPlaybackControls) => VoidFunction): () => void;
+    get time(): number;
+    set time(time: number);
+    get speed(): number;
+    set speed(speed: number);
+    get startTime(): any;
+    get duration(): number;
+    private runAll;
+    play(): void;
+    pause(): void;
+    stop: () => void;
+    cancel(): void;
+    complete(): void;
 }
 
-declare function useAnimateMini<T extends Element = any>(): [AnimationScope<T>, (elementOrSelector: motion_dom.ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions | undefined) => AnimationPlaybackControls];
+declare function useAnimateMini<T extends Element = any>(): [AnimationScope<T>, (elementOrSelector: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: DynamicAnimationOptions | undefined) => GroupPlaybackControls];
 
 export { useAnimateMini as useAnimate };
diff --git a/dist/mini.js b/dist/mini.js
index 915cccecd9d279979b49fe3c16ba74d5dcbed5a4..001902c17c8f9b23645bdfdce4dedf7cfaf5d01e 100644
--- a/dist/mini.js
+++ b/dist/mini.js
@@ -1 +1 @@
-!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Motion={},t.React)}(this,(function(t,e){"use strict";function i(t){const i=e.useRef(null);return null===i.current&&(i.current=t()),i.current}function n(t){let e;return()=>(void 0===e&&(e=t()),e)}const a=n(()=>void 0!==window.ScrollTimeline);class r{constructor(t){this.stop=()=>this.runAll("stop"),this.animations=t.filter(Boolean)}then(t,e){return Promise.all(this.animations).then(t).catch(e)}getAll(t){return this.animations[0][t]}setAll(t,e){for(let i=0;i<this.animations.length;i++)this.animations[i][t]=e}attachTimeline(t,e){const i=this.animations.map(i=>a()&&i.attachTimeline?i.attachTimeline(t):e(i));return()=>{i.forEach((t,e)=>{t&&t(),this.animations[e].stop()})}}get time(){return this.getAll("time")}set time(t){this.setAll("time",t)}get speed(){return this.getAll("speed")}set speed(t){this.setAll("speed",t)}get startTime(){return this.getAll("startTime")}get duration(){let t=0;for(let e=0;e<this.animations.length;e++)t=Math.max(t,this.animations[e].duration);return t}runAll(t){this.animations.forEach(e=>e[t]())}flatten(){this.runAll("flatten")}play(){this.runAll("play")}pause(){this.runAll("pause")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}const s=t=>t;let o=s;const l=t=>1e3*t,u=t=>t/1e3;const h=(t,e,i)=>{const n=e-t;return 0===n?1:(i-t)/n},c={linearEasing:void 0};function m(t,e){const i=n(t);return()=>{var t;return null!==(t=c[e])&&void 0!==t?t:i()}}const d=m(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch(t){return!1}return!0},"linearEasing"),p=([t,e,i,n])=>`cubic-bezier(${t}, ${e}, ${i}, ${n})`,f={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:p([0,.65,.55,1]),circOut:p([.55,0,1,.45]),backIn:p([.31,.01,.66,-.59]),backOut:p([.33,1.53,.69,.99])};function y(t,e){return t?"function"==typeof t&&d()?((t,e,i=10)=>{let n="";const a=Math.max(Math.round(e/i),2);for(let e=0;e<a;e++)n+=t(h(0,a-1,e))+", ";return`linear(${n.substring(0,n.length-2)})`})(t,e):(t=>Array.isArray(t)&&"number"==typeof t[0])(t)?p(t):Array.isArray(t)?t.map(t=>y(t,e)||f.easeOut):f[t]:void 0}const g=(t=>({test:e=>"string"==typeof e&&e.endsWith(t)&&1===e.split(" ").length,parse:parseFloat,transform:e=>`${e}${t}`}))("px"),A={borderWidth:g,borderTopWidth:g,borderRightWidth:g,borderBottomWidth:g,borderLeftWidth:g,borderRadius:g,radius:g,borderTopLeftRadius:g,borderTopRightRadius:g,borderBottomRightRadius:g,borderBottomLeftRadius:g,width:g,maxWidth:g,height:g,maxHeight:g,top:g,right:g,bottom:g,left:g,padding:g,paddingTop:g,paddingRight:g,paddingBottom:g,paddingLeft:g,margin:g,marginTop:g,marginRight:g,marginBottom:g,marginLeft:g,backgroundPositionX:g,backgroundPositionY:g};function v(t,e){t.timeline=e,t.onfinish=null}const b=t=>null!==t;function T(t,e,i){t.style.setProperty("--"+e,i)}function P(t,e,i){t.style[e]=i}const R=n(()=>{try{document.createElement("div").animate({opacity:[1]})}catch(t){return!1}return!0}),w=n(()=>Object.hasOwnProperty.call(Element.prototype,"animate")),x=new WeakMap;function k(t){const e=x.get(t)||new Map;return x.set(t,e),x.get(t)}class E{constructor(t,e,i,n){const a=e.startsWith("--");this.setValue=a?T:P,this.options=n,this.updateFinishedPromise(),o("string"!=typeof n.type);const r=k(t).get(e);r&&r.stop();if(Array.isArray(i)||(i=[i]),function(t,e,i){for(let n=0;n<e.length;n++)null===e[n]&&(e[n]=0===n?i():e[n-1]),"number"==typeof e[n]&&A[t]&&(e[n]=A[t].transform(e[n]));!R()&&e.length<2&&e.unshift(i())}(e,i,()=>e.startsWith("--")?t.style.getPropertyValue(e):window.getComputedStyle(t)[e]),"function"==typeof n.type){const t=function(t,e=100,i){const n=i({...t,keyframes:[0,e]}),a=Math.min(function(t){let e=0,i=t.next(e);for(;!i.done&&e<2e4;)e+=50,i=t.next(e);return e>=2e4?1/0:e}(n),2e4);return{type:"keyframes",ease:t=>n.next(a*t).value/e,duration:u(a)}}(n,100,n.type);n.ease=d()?t.ease:"easeOut",n.duration=l(t.duration),n.type="keyframes"}else n.ease=n.ease||"easeOut";this.removeAnimation=()=>{var i;return null===(i=x.get(t))||void 0===i?void 0:i.delete(e)};const s=()=>{this.setValue(t,e,function(t,{repeat:e,repeatType:i="loop"},n){const a=t.filter(b),r=e&&"loop"!==i&&e%2==1?0:a.length-1;return r&&void 0!==n?n:a[r]}(i,this.options)),this.cancel(),this.resolveFinishedPromise()};w()?(this.animation=function(t,e,i,{delay:n=0,duration:a=300,repeat:r=0,repeatType:s="loop",ease:o="easeInOut",times:l}={}){const u={[e]:i};l&&(u.offset=l);const h=y(o,a);return Array.isArray(h)&&(u.easing=h),t.animate(u,{delay:n,duration:a,easing:Array.isArray(h)?"linear":h,fill:"both",iterations:r+1,direction:"reverse"===s?"alternate":"normal"})}(t,e,i,n),!1===n.autoplay&&this.animation.pause(),this.animation.onfinish=s,this.pendingTimeline&&v(this.animation,this.pendingTimeline),k(t).set(e,this)):s()}get duration(){return u(this.options.duration||300)}get time(){var t;return this.animation?u((null===(t=this.animation)||void 0===t?void 0:t.currentTime)||0):0}set time(t){this.animation&&(this.animation.currentTime=l(t))}get speed(){return this.animation?this.animation.playbackRate:1}set speed(t){this.animation&&(this.animation.playbackRate=t)}get state(){return this.animation?this.animation.playState:"finished"}get startTime(){return this.animation?this.animation.startTime:null}flatten(){var t;this.animation&&(null===(t=this.animation.effect)||void 0===t||t.updateTiming({easing:"linear"}))}play(){"finished"===this.state&&this.updateFinishedPromise(),this.animation&&this.animation.play()}pause(){this.animation&&this.animation.pause()}stop(){this.animation&&"idle"!==this.state&&"finished"!==this.state&&(this.animation.commitStyles&&this.animation.commitStyles(),this.cancel())}complete(){this.animation&&this.animation.finish()}cancel(){this.removeAnimation();try{this.animation&&this.animation.cancel()}catch(t){}}then(t,e){return this.currentFinishedPromise.then(t,e)}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}attachTimeline(t){return this.animation?v(this.animation,t):this.pendingTimeline=t,s}}function O(t,e,i,n){const a=function(t,e,i){var n;if(t instanceof Element)return[t];if("string"==typeof t){let a=document;e&&(a=e.current);const r=null!==(n=null==i?void 0:i[t])&&void 0!==n?n:a.querySelectorAll(t);return r?Array.from(r):[]}return Array.from(t)}(t,n),r=a.length,s=[];for(let t=0;t<r;t++){const n=a[t],h={...i};"function"==typeof h.delay&&(h.delay=h.delay(t,r));for(const t in e){const i=e[t],a={...(o=h,u=t,o?o[u]||o.default||o:void 0)};a.duration=a.duration?l(a.duration):a.duration,a.delay=l(a.delay||0),s.push(new E(n,t,i,a))}}var o,u;return s}t.useAnimate=function(){const t=i(()=>({current:null,animations:[]})),n=i(()=>(t=>function(e,i,n){return new r(O(e,i,n,t))})(t));var a;return a=()=>{t.animations.forEach(t=>t.stop())},e.useEffect(()=>()=>a(),[]),[t,n]}}));
+!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Motion={},t.React)}(this,(function(t,e){"use strict";function i(t){const i=e.useRef(null);return null===i.current&&(i.current=t()),i.current}function n(t){let e;return()=>(void 0===e&&(e=t()),e)}const a=n(()=>void 0!==window.ScrollTimeline);class r{constructor(t){this.stop=()=>this.runAll("stop"),this.animations=t.filter(Boolean)}then(t,e){return Promise.all(this.animations).then(t).catch(e)}getAll(t){return this.animations[0][t]}setAll(t,e){for(let i=0;i<this.animations.length;i++)this.animations[i][t]=e}attachTimeline(t,e){const i=this.animations.map(i=>a()&&i.attachTimeline?i.attachTimeline(t):e(i));return()=>{i.forEach((t,e)=>{t&&t(),this.animations[e].stop()})}}get time(){return this.getAll("time")}set time(t){this.setAll("time",t)}get speed(){return this.getAll("speed")}set speed(t){this.setAll("speed",t)}get startTime(){return this.getAll("startTime")}get duration(){let t=0;for(let e=0;e<this.animations.length;e++)t=Math.max(t,this.animations[e].duration);return t}runAll(t){this.animations.forEach(e=>e[t]())}play(){this.runAll("play")}pause(){this.runAll("pause")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}const s=t=>t;let o=s;const l=t=>1e3*t,u=t=>t/1e3;const h=(t,e,i)=>{const n=e-t;return 0===n?1:(i-t)/n},c={linearEasing:void 0};function m(t,e){const i=n(t);return()=>{var t;return null!==(t=c[e])&&void 0!==t?t:i()}}const d=m(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch(t){return!1}return!0},"linearEasing"),p=([t,e,i,n])=>`cubic-bezier(${t}, ${e}, ${i}, ${n})`,f={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:p([0,.65,.55,1]),circOut:p([.55,0,1,.45]),backIn:p([.31,.01,.66,-.59]),backOut:p([.33,1.53,.69,.99])};function y(t,e){return t?"function"==typeof t&&d()?((t,e)=>{let i="";const n=Math.max(Math.round(e/10),2);for(let e=0;e<n;e++)i+=t(h(0,n-1,e))+", ";return`linear(${i.substring(0,i.length-2)})`})(t,e):(t=>Array.isArray(t)&&"number"==typeof t[0])(t)?p(t):Array.isArray(t)?t.map(t=>y(t,e)||f.easeOut):f[t]:void 0}const g=(t=>({test:e=>"string"==typeof e&&e.endsWith(t)&&1===e.split(" ").length,parse:parseFloat,transform:e=>`${e}${t}`}))("px"),A={borderWidth:g,borderTopWidth:g,borderRightWidth:g,borderBottomWidth:g,borderLeftWidth:g,borderRadius:g,radius:g,borderTopLeftRadius:g,borderTopRightRadius:g,borderBottomRightRadius:g,borderBottomLeftRadius:g,width:g,maxWidth:g,height:g,maxHeight:g,top:g,right:g,bottom:g,left:g,padding:g,paddingTop:g,paddingRight:g,paddingBottom:g,paddingLeft:g,margin:g,marginTop:g,marginRight:g,marginBottom:g,marginLeft:g,backgroundPositionX:g,backgroundPositionY:g};function b(t,e){t.timeline=e,t.onfinish=null}const v=t=>null!==t;function T(t,e,i){t.style.setProperty("--"+e,i)}function P(t,e,i){t.style[e]=i}const R=n(()=>{try{document.createElement("div").animate({opacity:[1]})}catch(t){return!1}return!0}),w=n(()=>Object.hasOwnProperty.call(Element.prototype,"animate")),x=new WeakMap;function k(t){const e=x.get(t)||new Map;return x.set(t,e),x.get(t)}class E{constructor(t,e,i,n){const a=e.startsWith("--");this.setValue=a?T:P,this.options=n,this.updateFinishedPromise(),o("string"!=typeof n.type);const r=k(t).get(e);r&&r.stop();if(Array.isArray(i)||(i=[i]),function(t,e,i){for(let n=0;n<e.length;n++)null===e[n]&&(e[n]=0===n?i():e[n-1]),"number"==typeof e[n]&&A[t]&&(e[n]=A[t].transform(e[n]));!R()&&e.length<2&&e.unshift(i())}(e,i,()=>e.startsWith("--")?t.style.getPropertyValue(e):window.getComputedStyle(t)[e]),"function"==typeof n.type){const t=function(t,e=100,i){const n=i({...t,keyframes:[0,e]}),a=Math.min(function(t){let e=0,i=t.next(e);for(;!i.done&&e<2e4;)e+=50,i=t.next(e);return e>=2e4?1/0:e}(n),2e4);return{type:"keyframes",ease:t=>n.next(a*t).value/e,duration:u(a)}}(n,100,n.type);n.ease=d()?t.ease:"easeOut",n.duration=l(t.duration),n.type="keyframes"}else n.ease=n.ease||"easeOut";this.removeAnimation=()=>{var i;return null===(i=x.get(t))||void 0===i?void 0:i.delete(e)};const s=()=>{this.setValue(t,e,function(t,{repeat:e,repeatType:i="loop"},n){const a=t.filter(v),r=e&&"loop"!==i&&e%2==1?0:a.length-1;return r&&void 0!==n?n:a[r]}(i,this.options)),this.cancel(),this.resolveFinishedPromise()};w()?(this.animation=function(t,e,i,{delay:n=0,duration:a=300,repeat:r=0,repeatType:s="loop",ease:o,times:l}={}){const u={[e]:i};l&&(u.offset=l);const h=y(o,a);return Array.isArray(h)&&(u.easing=h),t.animate(u,{delay:n,duration:a,easing:Array.isArray(h)?"linear":h,fill:"both",iterations:r+1,direction:"reverse"===s?"alternate":"normal"})}(t,e,i,n),!1===n.autoplay&&this.animation.pause(),this.animation.onfinish=s,this.pendingTimeline&&b(this.animation,this.pendingTimeline),k(t).set(e,this)):s()}get duration(){return u(this.options.duration||300)}get time(){var t;return this.animation?u((null===(t=this.animation)||void 0===t?void 0:t.currentTime)||0):0}set time(t){this.animation&&(this.animation.currentTime=l(t))}get speed(){return this.animation?this.animation.playbackRate:1}set speed(t){this.animation&&(this.animation.playbackRate=t)}get state(){return this.animation?this.animation.playState:"finished"}get startTime(){return this.animation?this.animation.startTime:null}play(){"finished"===this.state&&this.updateFinishedPromise(),this.animation&&this.animation.play()}pause(){this.animation&&this.animation.pause()}stop(){this.animation&&"idle"!==this.state&&"finished"!==this.state&&(this.animation.commitStyles&&this.animation.commitStyles(),this.cancel())}complete(){this.animation&&this.animation.finish()}cancel(){this.removeAnimation();try{this.animation&&this.animation.cancel()}catch(t){}}then(t,e){return this.currentFinishedPromise.then(t,e)}updateFinishedPromise(){this.currentFinishedPromise=new Promise(t=>{this.resolveFinishedPromise=t})}attachTimeline(t){return this.animation?b(this.animation,t):this.pendingTimeline=t,s}}function W(t,e,i,n){const a=function(t,e,i){var n;if("string"==typeof t){let a=document;e&&(o(Boolean(e.current)),a=e.current),i?(null!==(n=i[t])&&void 0!==n||(i[t]=a.querySelectorAll(t)),t=i[t]):t=a.querySelectorAll(t)}else t instanceof Element&&(t=[t]);return Array.from(t||[])}(t,n),r=a.length,s=[];for(let t=0;t<r;t++){const n=a[t],o={...i};"function"==typeof o.delay&&(o.delay=o.delay(t,r));for(const t in e){const a=e[t],r={...(u=i,h=t,u?u[h]||u.default||u:void 0)};r.duration=r.duration?l(r.duration):r.duration,r.delay=l(r.delay||0),s.push(new E(n,t,a,r))}}var u,h;return s}t.useAnimate=function(){const t=i(()=>({current:null,animations:[]})),n=i(()=>(t=>function(e,i,n){return new r(W(e,i,n,t))})(t));var a;return a=()=>{t.animations.forEach(t=>t.stop())},e.useEffect(()=>()=>a(),[]),[t,n]}}));
diff --git a/dist/three.d.ts b/dist/three.d.ts
index f4c7f31a0068108a6902194117f65093458b8158..f1dcc3fb442e8531caec3c759378449e1c3579bb 100644
--- a/dist/three.d.ts
+++ b/dist/three.d.ts
@@ -427,25 +427,6 @@ interface Spring extends Repeat {
      * @public
      */
     duration?: number;
-    /**
-     * If visualDuration is set, this will override duration.
-     *
-     * The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.
-     *
-     * In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.
-     *
-     * This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.
-     *
-     * ```jsx
-     * <motion.div
-     *   animate={{ x: 100 }}
-     *   transition={{ type: "spring", visualDuration: 0.5 }}
-     * />
-     * ```
-     *
-     * @public
-     */
-    visualDuration?: number;
     /**
      * `bounce` determines the "bounciness" of a spring animation.
      *
@@ -1494,7 +1475,6 @@ interface AnimationState<V> {
 interface KeyframeGenerator<V> {
     calculatedDuration: null | number;
     next: (t: number) => AnimationState<V>;
-    toString: () => string;
 }
 
 interface AnimationPlaybackLifecycles<V> {
@@ -1539,7 +1519,6 @@ interface AnimationPlaybackControls {
     cancel: () => void;
     then: (onResolve: VoidFunction, onReject?: VoidFunction) => Promise<void>;
     attachTimeline?: (timeline: ProgressTimeline, fallback?: (animation: AnimationPlaybackControls) => VoidFunction) => VoidFunction;
-    flatten: () => void;
 }
 type ValueKeyframe = string | number;
 type UnresolvedValueKeyframe = ValueKeyframe | null;
@@ -1560,7 +1539,6 @@ interface AnimationPlaybackOptions {
 }
 interface DurationSpringOptions {
     duration?: number;
-    visualDuration?: number;
     bounce?: number;
 }
 interface SpringOptions extends DurationSpringOptions, VelocityOptions {
@@ -1675,7 +1653,7 @@ declare class MotionValue<V = any> {
      */
     version: string;
     /**
-     * If a MotionValue has an owner, it was created internally within Motion
+     * If a MotionValue has an owner, it was created internally within Framer Motion
      * and therefore has no external listeners. It is therefore safe to animate via WAAPI.
      */
     owner?: Owner;
@@ -1694,11 +1672,11 @@ declare class MotionValue<V = any> {
     /**
      * The last time the `MotionValue` was updated.
      */
-    updatedAt: number;
+    private updatedAt;
     /**
      * The time `prevFrameValue` was updated.
      */
-    prevUpdatedAt: number | undefined;
+    private prevUpdatedAt;
     private stopPassiveEffect?;
     /**
      * A reference to the currently-controlling animation.
@@ -2096,7 +2074,7 @@ interface DraggableProps extends DragHandlers {
      * }
      * ```
      */
-    dragConstraints?: false | Partial<BoundingBox> | RefObject<Element | null>;
+    dragConstraints?: false | Partial<BoundingBox> | RefObject<Element>;
     /**
      * The degree of movement allowed outside constraints. 0 = no movement, 1 =
      * full movement.
@@ -2546,7 +2524,7 @@ interface HoverHandlers {
 
 type ViewportEventHandler = (entry: IntersectionObserverEntry | null) => void;
 interface ViewportOptions {
-    root?: RefObject<Element | null>;
+    root?: RefObject<Element>;
     once?: boolean;
     margin?: string;
     amount?: "some" | "all" | number;
@@ -2780,7 +2758,7 @@ interface MotionProps extends AnimationProps, EventProps, PanHandlers, TapHandle
      */
     style?: MotionStyle;
     /**
-     * By default, Motion generates a `transform` property with a sensible transform order. `transformTemplate`
+     * By default, Framer Motion generates a `transform` property with a sensible transform order. `transformTemplate`
      * can be used to create a different order, or to append/preprend the automatically generated `transform` property.
      *
      * ```jsx
@@ -2793,7 +2771,7 @@ interface MotionProps extends AnimationProps, EventProps, PanHandlers, TapHandle
      * ```
      *
      * @param transform - The latest animated transform props.
-     * @param generatedTransform - The transform string as automatically generated by Motion
+     * @param generatedTransform - The transform string as automatically generated by Framer Motion
      *
      * @public
      */
@@ -2963,6 +2941,8 @@ declare function calcLength(axis: Axis): number;
 
 declare function filterProps(props: MotionProps, isDom: boolean, forwardMotionProps: boolean): MotionProps;
 
+declare function isDragActive(): boolean;
+
 type EventListenerWithPointInfo = (e: PointerEvent, info: EventInfo) => void;
 declare const addPointerInfo: (handler: EventListenerWithPointInfo) => EventListener;
 
@@ -2978,4 +2958,4 @@ declare const useIsomorphicLayoutEffect: typeof useEffect;
 
 declare function useForceUpdate(): [VoidFunction, number];
 
-export { type AnimationType, MotionContext, type ResolvedValues, type ScrapeMotionValuesFromProps, type VisualState, addPointerEvent, addPointerInfo, animations, calcLength, createBox, filterProps, isBrowser, isMotionValue, makeUseVisualState, useForceUpdate, useIsomorphicLayoutEffect, useUnmountEffect };
+export { type AnimationType, MotionContext, type ResolvedValues, type ScrapeMotionValuesFromProps, type VisualState, addPointerEvent, addPointerInfo, animations, calcLength, createBox, filterProps, isBrowser, isDragActive, isMotionValue, makeUseVisualState, useForceUpdate, useIsomorphicLayoutEffect, useUnmountEffect };
